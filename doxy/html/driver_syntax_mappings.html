<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LDMud: mappings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LDMud
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('driver_syntax_mappings.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">mappings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="driver_syntax_mappings"></a>
mappings</h1>
<p>Guide to A step-by-step introduction to mappings #</p>
<p>A mapping is a datatype which allows to store data associated to a key. In other languages they are also known as 'dictionaries' or 'alists'. There are also alists in LPC but they are not a separate datatype but are implemented on top of arrays. Alists are the predecessors of mappings. The keys and the values can be of any type. But most common datatypes for keys are strings, integers and objects. Others like arrays, mappings or closures aren't a good choice because comparision between i.e. arrays often returns false even if they equal in content. This is because the driver compares i.e. two arrays by their internal pointers and not by their content. The reason for this is simple: speed.</p>
<p>Mappings are allways treated as references when passing them to functions. This means when you pass a mapping to another object and this object modifies the mapping the modification will take place in a global scope - visible to all objects holding this mapping in a variable.</p>
<h1>What are mappings good for?</h1>
<p>The term 'dictionary' probably describes the use of a mapping best. Opposed to arrays mappings don't have a specific order. They provide a mechanism to create a set of associations between values. Such an association consists of a unique key and data that is identified by the key. Think of a dictionary where you have a word and a definition of it. You use the word to lookup its definition.</p>
<p>Mappings can be used i.e. to hold aliases for commands. The key would then be the name of the alias and the data the command(s) behind an alias. Or they can be used for the exits of a room. The keys would be the directions where one can go to and the associated data would be the file names of the rooms. But mappings can also be used as a kind of a sparse array. A sparse array is an array where most of the elements aren't used (occupied by 0). I.e. if you want to store values at the position 0, 13 and 37642 of an array you would have to create an array with a size of at least 37643. This costs a lot of memory so a mapping would be more useful because you would then use the numbers 0, 13 and 37642 as a key and not as an index to a position (actually the keys of a mapping are sometimes called indices but this is just because the way data is accessed in a mapping is similar to arrays: by the [] operator). This also allows to query all occupied positions of a sparse array by querying for all the keys of the mapping opposed to an array where you have to iterate over all elements.</p>
<h1>How do I create a mapping?</h1>
<p>There are several ways to do so. The most convenient is the following:</p>
<div class="fragment"><div class="line">mapping map;</div>
<div class="line">map = ([</div>
<div class="line">  key0: value00; ...; value0n,</div>
<div class="line">  ... : ...    ; ...; ...    ,</div>
<div class="line">  keyn: valuen0; ...; valuenn</div>
<div class="line">]);</div>
</div><!-- fragment --><p> As you can see, a key may have more than one value assigned. But the amount of values per key must always be equal. It is even possible to have mappings without any values!</p>
<p>Another method is to use <a class="el" href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1" title="The first form returns a mapping with indices from arr1 and values from arr2... ">efun::mkmapping()</a>. This efun gets two arguments with the first beeing an array of keys and the following beeing arrays of values:</p>
<div class="fragment"><div class="line">mapping map;</div>
<div class="line">map = mkmapping (</div>
<div class="line">  ({ key0   , ..., keyn    }),</div>
<div class="line">  ({ value00, ..., value0n }),</div>
<div class="line">  ({ ...    , ..., ...     }),</div>
<div class="line">  ({ valuen0, ..., valuenn })</div>
<div class="line">);</div>
</div><!-- fragment --><p> If the efun only gets one argument, then this argument will be taken as an array of keys and a mapping without values will be returned.</p>
<p>An empty mapping can be created by using the above described methods by simply ommitting the keys and values:</p>
<div class="fragment"><div class="line">mapping map;</div>
<div class="line">map = ([]);</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line">map = mkmapping(({}), ({}));</div>
</div><!-- fragment --><p> Or by using the <a class="el" href="classefun.html#a9ae4e2d42d75ad4aa7f4e100c60c3d41" title="Reserve memory for a mapping. ">efun::m_allocate()</a>. This efun gets as first argument the amount of keys which will be added soon and an optional second argument specifying the width of the mapping:</p>
<div class="fragment"><div class="line">map = m_allocate(n, width);</div>
</div><!-- fragment --><p> The value <em>n</em> may be a bit confusing since mappings shrink and grow dynamically. This value just tells the driver how 'long' this mapping is going to be so proper memory allocations will be performed to reduce the overhead of memory reallocation. I.e. if you want to read in a file and store the read data in a mapping you probably know the amount of keys. So you allocate a mapping with this efun and tell the driver how much memory should be allocated by specifing a proper <em>n</em> value. Thus causing a speedup when adding the read data to the mapping afterwards. The <em>width</em> just specifies how many values per key this mapping is going to have. If no width is given, 1 will be taken as default.</p>
<p>An empty mapping created with <code>([])</code> will always have a width of 1. To create empty mappings with other widths, write it as:</p>
<div class="fragment"><div class="line">map = ([:width ]);</div>
</div><!-- fragment --><p> <em>width</em> can be any expression returning an integer value (including function calls), and in fact this notation is just a fancy way of writing:</p>
<div class="fragment"><div class="line">map = m_allocate(0, width);</div>
</div><!-- fragment --><h1>How can I modify the data of a mapping?</h1>
<p>Adding a new key is similiar to modifying the associated data of an existing key:</p>
<div class="fragment"><div class="line">map += ([ key: value0; ...; valuen ]);</div>
</div><!-- fragment --><p> Or in case only a single value should be modified:</p>
<div class="fragment"><div class="line">map[key, n] = valuen;</div>
</div><!-- fragment --><p> If <em>n</em> is out of range or if <em>key</em> doesn't exists and <em>n</em> is greater than 0 an "Illegal index" error will be reported. If <em>n</em> is equal to 0 or the mapping only has a single value per key one can abbreviate it with:</p>
<div class="fragment"><div class="line">map[key] = value;</div>
</div><!-- fragment --><p> If there is no <em>key</em> (and <em>n</em> is equal to 0 or not specified at all) a new one will be added automatically.</p>
<p>Deletion of a key is done with the <a class="el" href="driver_syntax_operators.html">-=</a> or <a class="el" href="classefun.html#a7d2bbcf03098048f203304b517a88a29" title="Remove the entry with index &#39;key&#39; from mapping &#39;map&#39;. ">efun::m_delete()</a>. A mapping can only be substracted by one without any values:</p>
<div class="fragment"><div class="line">map -= ([ key ]);</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line">map -= ([ key0, ..., keyn ]);</div>
</div><!-- fragment --><p> The efun takes a mapping as first and a key as second argument:</p>
<div class="fragment"><div class="line">m_delete(map, key);</div>
</div><!-- fragment --><p> <a class="el" href="classefun.html#a7d2bbcf03098048f203304b517a88a29" title="Remove the entry with index &#39;key&#39; from mapping &#39;map&#39;. ">efun::m_delete()</a> returns the mapping but because mappings are handled as references there is no need of an assignment like:</p>
<div class="fragment"><div class="line">map = m_delete(map, key);</div>
</div><!-- fragment --><h1>How can I access the data stored in a mapping?</h1>
<p>This can be done by:</p>
<div class="fragment"><div class="line">valuen = map[key, n];</div>
</div><!-- fragment --><p> Or in case of a mapping with just one value per key:</p>
<div class="fragment"><div class="line">value0 = map[key];</div>
</div><!-- fragment --><p> If there is no <em>key</em> in the mapping and <em>n</em> is 0 or not specified at all (which is the same) a 0 will be returned or if <em>n</em> is greater than 0 an "Illegal index" error will be reported.</p>
<h1>How can I test for the existance of a key?</h1>
<p>A return value of 0 is sufficient for most applications but sometimes the ambiguity between an existing value of 0 and a nonexisting key can lead to a problem. Therefore one can use <a class="el" href="classefun.html#adf2253b4467a0eb544f67ff5777d2fa2" title="For arrays and strings, returns the index of the first occurance of second arg in the first arg...">efun::member()</a> or <a class="el" href="classefun.html#a149395923f6aed5847a664b568d55124" title="If the mapping contains the key map, the corresponding values are assigned to the data arguments...">efun::m_contains()</a> to check if there actually is a key in the mapping:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (member(map, key)) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (mapping_contains(&amp;value0, ..., &amp;valuen, map, key)) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This also shows how one can retrieve all values associated to a key from a mapping in a single step. The '&amp;' is the reference operator which is neccesary to let the efun store the values in the variables.</p>
<p>In case of mappings with no values, the <a class="el" href="classefun.html#adf2253b4467a0eb544f67ff5777d2fa2" title="For arrays and strings, returns the index of the first occurance of second arg in the first arg...">efun::member()</a> and <a class="el" href="classefun.html#a149395923f6aed5847a664b568d55124" title="If the mapping contains the key map, the corresponding values are assigned to the data arguments...">efun::m_contains()</a> are equal in their behaviour and their way of calling because <a class="el" href="classefun.html#a149395923f6aed5847a664b568d55124" title="If the mapping contains the key map, the corresponding values are assigned to the data arguments...">efun::m_contains()</a> won't get any reference variables to store the values in (because there aren't any).</p>
<p>Also normally <a class="el" href="classefun.html#adf2253b4467a0eb544f67ff5777d2fa2" title="For arrays and strings, returns the index of the first occurance of second arg in the first arg...">efun::member()</a> is known to return the postion of an element in a list (i.e. a character in a string or data in an array) and if an element couldn't be found -1 is returned. But in the case of mappings there are no such things as order and postion. So <a class="el" href="classefun.html#adf2253b4467a0eb544f67ff5777d2fa2" title="For arrays and strings, returns the index of the first occurance of second arg in the first arg...">efun::member()</a> only returns 0 or 1.</p>
<h1>How can I copy a mapping?</h1>
<p>A mapping can be copied with the + operator or by <a class="el" href="classefun.html#aaa7f17ec1022dac35a818c575fef969a" title="Create a deep copy of value and return it. ">efun::deep_copy()</a>:</p>
<div class="fragment"><div class="line">newmap = ([]) + map;</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line">newmap = copy_mapping(map);</div>
</div><!-- fragment --><p> A mapping should only be copied when it is neccesary to get an own copy of it that must not be shared by other objects.</p>
<h1>How can I get all keys of a mapping?</h1>
<p><a class="el" href="classefun.html#a706faae97294c390a3cd88cb080d509a" title="Returns an array containing the indices of mapping &#39;map&#39;. ">efun::m_indices()</a> gets a mapping as argument and returns an array holding all keys defined in this mapping:</p>
<div class="fragment"><div class="line">keys = m_indices(map);</div>
</div><!-- fragment --><h1>How can I get all the values of a mapping?</h1>
<p><a class="el" href="classefun.html#a2bed0d3fd8a81f635ddf28b8f539d4c1" title="Returns an array with the values of mapping map. ">efun::m_values()</a> gets a mapping as argument and returns an array holding all the first (second, ...) values of it:</p>
<div class="fragment"><div class="line">values0 = m_values(map);     <span class="comment">//returns the first values</span></div>
<div class="line">values0 = m_values(map, 0);  <span class="comment">//dito</span></div>
<div class="line">values1 = m_values(map, 1);  <span class="comment">//returns the second values</span></div>
<div class="line">  etc</div>
</div><!-- fragment --><h1>How can I determine the size of a mapping?</h1>
<p>Because a mapping is a kind of rectangle it has two sizes: a length and a width. There are three different efuns to query these values. The first two are <a class="el" href="classefun.html#a1b26f2ff266e671649fc060bea19b228" title="Returns the number of elements of an array or struct, the number of characters in a string...">efun::sizeof()</a>, which returns the amount of key-value associations (the length of a mapping), and <a class="el" href="classefun.html#abd02e530c8ad0620b241d0933fdc91da" title="Returns the number of values per key of mapping map. ">efun::widthof()</a>, which returns the number of values per key (the width). The third is the efun <a class="el" href="classefun.html#ac251ce3e185e6ef6e265806ba711e871" title="Returns info about the type of value, as controlled by the flag. ">efun::get_type_info()</a>. <a class="el" href="classefun.html#ac251ce3e185e6ef6e265806ba711e871" title="Returns info about the type of value, as controlled by the flag. ">efun::get_type_info()</a> is meant to be a function to identify a datatype. Its return value is an array of two numerical values. The first specifies the datatype of the argument and the second is a datatype dependend value. In the case of a mapping the first value is <code>T_MAPPING</code> (which is a value defined in &lt;lpctypes.h&gt;) and the second the amount of values per key (a.k.a. columns or the width of the mapping - actually it would be correct to say that the width of a mapping is the amount of columns plus one for the keys but this is uncommon).</p>
<h1>What is the best method to iterate over a mapping?</h1>
<p>First of all the main purpose of a mapping is not meant to be a set of data to iterate over. Afterall the keys in a mapping have no specific but a random order (at least on the LPC side). But still it is possible and sometimes even neccesary to do so.</p>
<p>If all key-value associations should be processed then one should use <a class="el" href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216" title="Calls ob-&gt;func(key, value1, ..., valueN, extra,...) resp. ">efun::walk_mapping()</a>. If all keys of a mapping should be processed to create a new mapping being a subset of the given one, then <a class="el" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8" title="ob-&gt;func() is called resp. ">efun::filter_indices()</a> should be used. If all keys are going to be processed and to create a new mapping with the same set of keys as the given mapping, then one would use <a class="el" href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7" title="ob-&gt;func() is called resp. ">efun::map_indices()</a>. But in the case of an iteration that should/can stop even if not all data is processed it is probably wise to iterate over the mapping by first querying for the keys and then to iterate over them with a <a class="el" href="driver_syntax_for.html">for</a> or a <a class="el" href="driver_syntax_while.html">while</a> loop and querying the values by 'hand'.</p>
<p>The <a class="el" href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216" title="Calls ob-&gt;func(key, value1, ..., valueN, extra,...) resp. ">efun::walk_mapping()</a> gets a mapping as first argument and the name of a function as second one. All the following arguments are treated as extras which will be passed to the function specified with the 2nd argument. Instead of a string for the name of a function a closure can be used, too. Nothing will be returned:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">walk_mapping(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">void func(mixed key, mixed value0, ..., mixed valuen, mixed xarg0,</div>
<div class="line">  ..., mixed xargn) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code>func()</code> will be called for all key-value associations and gets as first argument the key. The next arguments are the values behind the key and are passed as references. The rest of the passed arguments are those specified as extras. Because the values are passed as references (opposed to copies) it is possible to modify them from inside <code>func()</code> by simply assigning new value to the variables <em>value0</em>, ..., <em>valuen</em>.</p>
<p>The <a class="el" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8" title="ob-&gt;func() is called resp. ">efun::filter_indices()</a> calls a function for each key in a mapping and creates a new mapping which only contains key-value associations for which the called function returned true (not equal 0 that is). The first argument is the mapping to iterate over and the second is a function name given as a string or a closure:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">submap = filter_indices(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int func(mixed key, mixed xarg0, ..., mixed xargn) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code>func()</code> gets as first argument the key and the others are those passed as extras to <a class="el" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8" title="ob-&gt;func() is called resp. ">efun::filter_indices()</a>.</p>
<p><a class="el" href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7" title="ob-&gt;func() is called resp. ">efun::map_indices()</a> gets a mapping as first argument and a string as a function name (or again a closure) as second argument. Any additional arguments are again used as extras that will be passed to the iteration function. This efun returns a new mapping with the same keys as the given one. The values returned by the function that is invoked for each key will be used as the associated data behind each key of the new mapping:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">newmap = map_indices(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">mixed func(mixed key, mixed xarg0, ..., mixed xargn) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code>func()</code> gets as first argument the key and the others are those passed as extras to <a class="el" href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7" title="ob-&gt;func() is called resp. ">efun::map_indices()</a>.</p>
<p>Because a function can only return a single value (even when it is an array) it restricts the use of <a class="el" href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7" title="ob-&gt;func() is called resp. ">efun::map_indices()</a> to only allow creation of mappings with a single value per key.</p>
<h1>Is it possible to join/intersect/cut mappings with another?</h1>
<p>Joining mappings is only possible, if they have the same width (amount of values per key). One can use the + and += operator:</p>
<div class="fragment"><div class="line">map = map1 + map2 + ... + mapn;</div>
<div class="line">map += map1 + map2 + ... + mapn;</div>
</div><!-- fragment --><p> Intersection of two mappings is only possible by using <a class="el" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8" title="ob-&gt;func() is called resp. ">efun::filter_indices()</a>. There is no efun or operator which features this. The 'easiest' way may be the following function:</p>
<div class="fragment"><div class="line">mapping intersect_mapping(mapping map1, mapping map2) {</div>
<div class="line">  closure cl;</div>
<div class="line"></div>
<div class="line">  cl = lambda(({ <span class="stringliteral">&#39;key }), ({ #&#39;</span>member, map2, <span class="stringliteral">&#39;key }));</span></div>
<div class="line"><span class="stringliteral">  return filter_indices(map1, cl, map2);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> This function returns a new mapping which consists of all key-value associations of <em>map1</em> for which an equal key could be found in <em>map2</em>. This function uses a closure which returns 0 or 1 depending on wether a key from <em>map1</em> is contained in <em>map2</em> or not.</p>
<p>Cutting out all key-value associations of a mapping for which a key could be found in another mapping can be done by using <a class="el" href="driver_syntax_operators.html">-</a> and <a class="el" href="driver_syntax_operators.html">-=</a>:</p>
<div class="fragment"><div class="line">mapping cut_mapping(mapping map1, mapping map2) {</div>
<div class="line">  <span class="keywordflow">return</span> map1 - mkmapping(m_indices(map2));</div>
<div class="line">}</div>
</div><!-- fragment --><p> Because a maping can only be substracted by one without any values we first have to create such by using <a class="el" href="classefun.html#a706faae97294c390a3cd88cb080d509a" title="Returns an array containing the indices of mapping &#39;map&#39;. ">efun::m_indices()</a> and <a class="el" href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1" title="The first form returns a mapping with indices from arr1 and values from arr2... ">efun::mkmapping()</a>.</p>
<h1>What are those mappings without any values (besides keys) good for?</h1>
<p>Because the way how the driver searches for a key in a mapping is rather fast, those mappings can be used as a set of elements with a fast method for testing if an element is contained in the set. This technique is called hashing (further explanation would lead too far) which is faster than searching for values in array (which is done in a linear fashion).</p>
<p>Another (maybe more pratical) use of these mappings are to create a array of unique values out of an array with several equal values:</p>
<div class="fragment"><div class="line">uniques = m_indices(mkmapping(array));</div>
</div><!-- fragment --><p> <a class="el" href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1" title="The first form returns a mapping with indices from arr1 and values from arr2... ">efun::mkmapping()</a> uses <em>array</em> to create a mapping without any values but just keys. And because a mapping can only have unique keys all multiple values in <em>array</em> are taken as one. The call of <a class="el" href="classefun.html#a706faae97294c390a3cd88cb080d509a" title="Returns an array containing the indices of mapping &#39;map&#39;. ">efun::m_indices()</a> then returns an array of these unique keys. Actually we only make use of those mappings temporarily.</p>
<h1>How can I convert an alist into a mapping and vice versa?</h1>
<p>There are no special efuns which handle such conversions. But it can be done by the following functions:</p>
<div class="fragment"><div class="line">mapping alist_to_mapping(mixed *alist) {</div>
<div class="line">  <span class="keywordflow">return</span> apply(#<span class="stringliteral">&#39;mkmapping, alist);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> <a class="el" href="classefun.html#aaf018e933ee843dfe67f2916aeeb51a1" title="Evaluates the closure cl with the following arguments. ">efun::apply()</a> takes a closure and an array of values and passes each element of the array as an argument to the closure. Because an alist consists of an array of arrays with the first beeing the list of keys and the others the values associated to each key passing them as arguments to the efun closure <code>#'mkmapping</code> via <a class="el" href="classefun.html#aaf018e933ee843dfe67f2916aeeb51a1" title="Evaluates the closure cl with the following arguments. ">efun::apply()</a> causes the creation of a mapping out of an alist.</p>
<div class="fragment"><div class="line">mixed *mapping_to_alist(mapping map) {</div>
<div class="line">  mixed *alist;</div>
<div class="line">  symbol *vars;</div>
<div class="line">  <span class="keywordtype">string</span> var;</div>
<div class="line">  closure cl;</div>
<div class="line">  <span class="keywordtype">int</span> width;</div>
<div class="line"></div>
<div class="line">  width = get_type_info(map)[1];</div>
<div class="line">  alist = allocate(width + 1);</div>
<div class="line">  vars  = allocate(width + 2);</div>
<div class="line">  <span class="keywordflow">for</span> (var = <span class="stringliteral">&quot;a&quot;</span>; width; var[0]++, width--) {</div>
<div class="line">    alist[width] = ({});</div>
<div class="line">    vars[width]  = quote(var);</div>
<div class="line">  }</div>
<div class="line">  alist[0] = ({});</div>
<div class="line">  vars[0]  = <span class="stringliteral">&#39;key;</span></div>
<div class="line"><span class="stringliteral">  vars[&lt;1] = &#39;</span>alist;</div>
<div class="line">  cl = lambda(vars, ({ #<span class="stringliteral">&#39;=, &#39;</span>alist, ({ #<span class="stringliteral">&#39;insert_alist }) + vars }));</span></div>
<div class="line"><span class="stringliteral">  walk_mapping(map, cl, &amp;alist);</span></div>
<div class="line"><span class="stringliteral">  return alist;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> This function is a bit more complicated than the other and detailed description would lead too far of the topic. This function has one restriction: it can only turn a mappings with up to 26 values per key into an alist. But this should be sufficient for probably all applications which use mappings.</p>
<p>And Hyps further comment on this:</p>
<p>The function <code>mapping_to_alist()</code> is also not that clever because <code>insert_alist()</code> allways creates a new alist. A second (optional) argument to <a class="el" href="classefun.html#a2bed0d3fd8a81f635ddf28b8f539d4c1" title="Returns an array with the values of mapping map. ">efun::m_values()</a> to specify the value column would be better. Besides this, the conversion of a mapping into an alist could be done by efun::to_array().</p>
<h1>Dirty Mappings</h1>
<p>'Dirty mappings' are nothing the LPC programmer directly is involved with, however, as it relates to the way mappings are implemented internally by the gamedriver. However, as this term shows up in various driver statistics, it is explained here.</p>
<p>There are two fundamental approaches to implement mappings:</p>
<ol type="1">
<li>Store all data entries in an array-like structure, in sorted order.</li>
<li>Store all data in a hashtable, each entry allocaed separately. Method 1 is very space efficient, as it doesn't need much overhead per entry; however, insertions and deletions of entries are relatively slow as all other entries need to be moved. Method 2 is very fast as nothing needs to be moved in memory, however it has a large overhead.</li>
</ol>
<p>The gamedriver uses a hybrid method: at the basis is a mapping implementation based on arrays. However the driver uses a hash table in addition to handle all the ongoing insertions and deletions. Every once in a while, the contents of the hash table are sorted into the base array, reasoning that any entry surviving for longer time in the hash table is worth keeping in a more space-efficient manner. 'Dirty' mappings are such mappings with both an array and a hash part, 'clean' mappings are those with just an array part.</p>
<ul>
<li>changed (3.2.9/3.3.208) &ndash; added ([:width ]) notation</li>
</ul>
<p>Last Update</p>
<p>Mon, 15 Mar 1999</p>
<p><code>alists</code>, <a class="el" href="driver_syntax_closures.html">closure</a>, <a class="el" href="driver_syntax_structs.html">struct</a>, <a class="el" href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1" title="The first form returns a mapping with indices from arr1 and values from arr2... ">efun::mkmapping()</a>, <a class="el" href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216" title="Calls ob-&gt;func(key, value1, ..., valueN, extra,...) resp. ">efun::walk_mapping()</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="driver_syntax_overview.html">LPC syntax</a></li>
    <li class="footer">Generated on Thu Mar 9 2017 17:45:24 for LDMud by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
