<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Tsunami: concepts/pcre.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tsunami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pcre_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">concepts/pcre.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;pcre {#driver_concepts_pcre}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;============================</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;This document describes the regular expressions supported by the PCRE package. When the <span class="keyword">package </span>is compiled into the driver, the macro __PCRE__ is defined.</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Most of this manpage is lifted directly from the original PCRE manpage (dated January 2003).</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5, with just a few differences (see below). The current implementation corresponds to Perl 5.005, with some additional features from later versions. This includes some experimental, incomplete support for UTF-8 encoded strings. Details of exactly what is and what is not supported are given below.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;## PCRE REGULAR EXPRESSION DETAILS #</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;The syntax and semantics of the regular expressions supported by PCRE are described below. Regular expressions are also described in the Perl documentation and in a number of other books, some of which have copious examples. Jeffrey Friedl&#39;s &quot;Mastering Regular Expressions&quot;, published by O&#39;Reilly, covers them in great detail. The description here is intended as reference documentation.</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;The basic operation of PCRE is on strings of bytes. However, there is also support for UTF-8 character strings. To use this support you must build PCRE to include UTF-8 support, and then call pcre_compile() with the PCRE_UTF8 option. How this affects the pattern matching is mentioned in several places below. There is also a summary of UTF-8 features in the section on UTF-8 support in the main pcre page.</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern @aThe quick brown fox` matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters, which do not stand for themselves but instead are interpreted in some special way.</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the meta-characters are as follows:</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;`\\`</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;general escape character with several uses</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;`^`</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;assert start of string (or line, in multiline mode)</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;`$`</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;assert end of string (or line, in multiline mode)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;`.`</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;match any character except newline (by default)</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;`[`</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;start character class definition</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;`|`</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;start of alternative branch</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;`(`</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;start subpattern</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;`)`</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;end subpattern</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;`?`</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;extends the meaning of `(`</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;also 0 or 1 quantifier</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;also quantifier minimizer</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;`*`</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;0 or more quantifier</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;`+`</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;1 or more quantifier</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;also &quot;possessive quantifier&quot;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;`{`</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;start min/max quantifier</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;Part of a pattern that is in square brackets is called a &quot;character class&quot;. In a character class the only meta-characters are:</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;`\`</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;general escape character</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;`^`</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;negate the class, but only if the first character</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;`-`</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;indicates character range</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;`[`</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;POSIX character class (only if followed by POSIX</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;syntax)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;`]`</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;terminates the character class</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;The following sections describe the use of each of the meta-characters.</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;## BACKSLASH #</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;The backslash character has several uses. Firstly, if it is followed by a non-alphameric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;For example, if you want to match a * character, you write * in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a meta-character, so it is always safe to precede a non-alphameric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write \.</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;If a pattern is compiled with the PCRE_EXTENDED option, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline character are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;If you want to remove the special meaning from a sequence of characters, you can do so by putting them between Q and E. This is different from Perl in that $ and @ are handled as literals in Q...E sequences in PCRE, whereas in Perl, $ and @ cause variable interpolation. Note the following examples:</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;Pattern            PCRE matches   Perl matches</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;\Qabc$xyz\E        abc$xyz        abc followed by the</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                                   contents of $xyz</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;\Qabc\$xyz\E       abc\$xyz       abc\$xyz</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;\Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;~~~</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;The Q...E sequence is recognized both inside and outside character classes.</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;\a        alarm, that is, the BEL character (hex 07)</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;\cx       &quot;control-x&quot;, where x is any character</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;\e        escape (hex 1B)</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;\f        formfeed (hex 0C)</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;\n        newline (hex 0A)</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;\r        carriage return (hex 0D)</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;\t        tab (hex 09)</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;\ddd      character with octal code ddd, or backreference</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;\xhh      character with hex code hh</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;\x{hhh..} character with hex code hhh... (UTF-8 mode only)</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;~~~</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;The precise effect of cx is as follows: if x is a lower case letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus cz becomes hex 1A, but c{ becomes hex 3B, while c; becomes hex 7B.</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;After x, from zero to two hexadecimal digits are read (letters can be in upper or lower <span class="keywordflow">case</span>). In UTF-8 mode, any number of hexadecimal dig-its may appear between x{ and }, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between x{ and }, or <span class="keywordflow">if</span> there is no terminating }, <span class="keyword">this</span> form of escape is not recognized. Instead, the initial x will be interpreted as a basic hexadecimal escape, with no following digits, giving a byte whose value is zero.</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;Characters whose value is less than 256 can be defined by either of the two syntaxes <span class="keywordflow">for</span> x when PCRE is in UTF-8 mode. There is no difference in the way they are handled. For example, xdc is exactly the same as x{dc}.</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;After 0 up to two further octal digits are read. In both cases, <span class="keywordflow">if</span> there are fewer than two digits, just those that are present are used. Thus the sequence 0x07 specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero <span class="keywordflow">if</span> the character that follows is itself an octal digit.</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;The handling of a backslash followed by a digit other than 0 is complicated. Outside a character <span class="keyword">class</span>, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or <span class="keywordflow">if</span> there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how <span class="keyword">this</span> works is given later, following the discussion of parenthesized subpatterns.</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;Inside a character <span class="keyword">class</span>, or <span class="keywordflow">if</span> the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand <span class="keywordflow">for</span> themselves. For example:</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;\040   is another way of writing a space</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;\40    is the same, provided there are fewer than 40</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;         previous capturing subpatterns</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;\7     is always a back reference</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;\11    might be a back reference, or another way of</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;         writing a tab</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;\011   is always a tab</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;\0113  is a tab followed by the character <span class="stringliteral">&quot;3&quot;</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;\113   might be a back reference, otherwise the</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;         character with octal code 113</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;\377   might be a back reference, otherwise</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;         the byte consisting entirely of 1 bits</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;\81    is either a back reference, or a binary zero</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;         followed by the two characters <span class="stringliteral">&quot;8&quot;</span> and <span class="stringliteral">&quot;1&quot;</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;~~~</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence b is interpreted as the backspace character (hex 08). Outside a character class it has a different meaning (see below).</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;The third use of backslash is for specifying generic character types:</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;\d     any decimal digit</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;\D     any character that is not a decimal digit</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;\s     any whitespace character</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;\S     any character that is not a whitespace character</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;\w     any <span class="stringliteral">&quot;word&quot;</span> character</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;\W     any <span class="stringliteral">&quot;non-word&quot;</span> character</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;~~~</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair.</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;In UTF-8 mode, characters with values greater than 255 never match d, s, or w, and always match D, S, and W.</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;For compatibility with Perl, s does not match the VT character (code 11). This makes it different from the the POSIX <span class="stringliteral">&quot;space&quot;</span> <span class="keyword">class</span>. The s characters are HT (9), LF (10), FF (12), CR (13), and space (32).</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;A <span class="stringliteral">&quot;word&quot;</span> character is any letter or digit or the underscore character, that is, any character which can be part of a Perl <span class="stringliteral">&quot;word&quot;</span>. The definition of letters and digits is controlled by PCRE<span class="stringliteral">&#39;s character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; in the pcreapi page). For example, in the &quot;fr&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by w.</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="stringliteral">These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="stringliteral">The fourth use of backslash is for certain simple assertions. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are:</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="stringliteral">\b     matches at a word boundary</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="stringliteral">\B     matches when not at a word boundary</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="stringliteral">\A     matches at start of subject</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="stringliteral">\Z     matches at end of subject or before newline at end</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="stringliteral">\z     matches at end of subject</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="stringliteral">\G     matches at first matching position in subject</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="stringliteral">These assertions may not appear in character classes (but note that b has a different meaning, namely the backspace character, inside a character class).</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="stringliteral">A word boundary is a position in the subject string where the current character and the previous character do not both match w or W (i.e. one matches w and the other matches W), or the start or end of the string if the first or last character matches w, respectively.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="stringliteral">The A, Z, and z assertions differ from the traditional circumflex and dollar (described below) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode.</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="stringliteral">They are not affected by the PCRE_NOTBOL or PCRE_NOTEOL options. If the startoffset argument of pcre_exec() is non-zero, indicating that matching is to start at a point other than the beginning of the subject, A can never match. The difference between Z and z is that Z matches before a newline that is the last character of the string as well as at the end of the string, whereas z matches only at the end.</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="stringliteral">The G assertion is true only when the current matching position is at the start point of the match, as specified by the startoffset argument of pcre_exec(). It differs from A when the value of startoffset is non-zero. By calling pcre_exec() multiple times with appropriate arguments, you can mimic Perl&#39;</span>s /g option, and it is in <span class="keyword">this</span> kind of implementation where G can be useful.</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;Note, however, that PCRE<span class="stringliteral">&#39;s interpretation of G, as the start of the current match, is subtly different from Perl&#39;</span>s, which defines it as the end of the previous match. In Perl, these can be different when the previously matched <span class="keywordtype">string</span> was empty. Because PCRE does just one match at a time, it cannot reproduce <span class="keyword">this</span> behaviour.</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;If all the alternatives of a pattern begin with G, the expression is anchored to the starting match position, and the <span class="stringliteral">&quot;anchored&quot;</span> flag is set in the compiled regular expression.</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;## CIRCUMFLEX AND DOLLAR #</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;Outside a character <span class="keyword">class</span>, in the <span class="keywordflow">default</span> matching mode, the circumflex character is an assertion which is <span class="keyword">true</span> only <span class="keywordflow">if</span> the current matching point is at the start of the subject <span class="keywordtype">string</span>. If the startoffset argument of pcre_exec() is non-zero, circumflex can never match if the PCRE_MULTILINE option is unset. Inside a character class, circumflex has an entirely different meaning (see below).</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;Circumflex need not be the first character of the pattern if a number of alternatives are involved, but it should be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an &quot;anchored&quot; pattern. (There are also other constructs that can cause a pattern to be anchored.)</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;A dollar character is an assertion which is true only if the current matching point is at the end of the subject <span class="keywordtype">string</span>, or immediately before a newline character that is the last character in the <span class="keywordtype">string</span> (by default). Dollar need not be the last character of the pattern if a number of alternatives are involved, but it should be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;The meaning of dollar can be changed so that it matches only at the very end of the <span class="keywordtype">string</span>, by setting the PCRE_DOLLAR_ENDONLY option at compile time. This does not affect the Z assertion.</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;The meanings of the circumflex and dollar characters are changed if the PCRE_MULTILINE option is set. When this is the case, they match immediately after and immediately before an internal newline character, respectively, in addition to matching at the start and end of the subject <span class="keywordtype">string</span>. For example, the pattern /^abc$/ matches the subject <span class="keywordtype">string</span> &quot;defnabc&quot; in multiline mode, but not otherwise. Consequently, patterns that are anchored in single line mode because all branches start with ^ are not anchored in multiline mode, and a match for circumflex is possible when the startoffset argument of pcre_exec() is non-zero. The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is set.</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;Note that the sequences A, Z, and z can be used to match the start and end of the subject in both modes, and if all branches of a pattern start with A it is always anchored, whether PCRE_MULTILINE is set or not.</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="preprocessor">## FULL STOP (PERIOD, DOT) #</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;Outside a character <span class="keyword">class</span>, a dot in the pattern matches any one character in the subject, including a non-printing character, but not (by <span class="keywordflow">default</span>) newline. In UTF-8 mode, a dot matches any UTF-8 character, which might be more than one byte long, except (by <span class="keywordflow">default</span>) <span class="keywordflow">for</span> newline. If the PCRE_DOTALL option is set, dots match newlines as well. The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship being that they both involve newline characters. Dot has no special meaning in a character <span class="keyword">class</span>.</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;## MATCHING A SINGLE BYTE #</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;Outside a character <span class="keyword">class</span>, the escape sequence C matches any one byte, both in and out of UTF-8 mode. Unlike a dot, it always matches a newline. The feature is provided in Perl in order to match individual bytes in UTF-8 mode. Because it breaks up UTF-8 characters into individual bytes, what remains in the <span class="keywordtype">string</span> may be a malformed UTF-8 <span class="keywordtype">string</span>. For <span class="keyword">this</span> reason it is best avoided.</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;PCRE does not allow C to appear in lookbehind assertions (see below), because in UTF-8 mode it makes it impossible to calculate the length of the lookbehind.</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;## SQUARE BRACKETS #</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;An opening square bracket introduces a character <span class="keyword">class</span>, terminated by a closing square bracket. A closing square bracket on its own is not special. If a closing square bracket is required as a member of the <span class="keyword">class</span>, it should be the first data character in the <span class="keyword">class</span> (after an initial circumflex, <span class="keywordflow">if</span> present) or escaped with a backslash.</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;A character <span class="keyword">class</span> matches a single character in the subject. In UTF-8 mode, the character may occupy more than one byte. A matched character must be in the set of characters defined by the <span class="keyword">class</span>, unless the first character in the <span class="keyword">class</span> definition is a circumflex, in which <span class="keywordflow">case</span> the subject character must not be in the set defined by the <span class="keyword">class</span>. If a circumflex is actually required as a member of the <span class="keyword">class</span>, ensure it is not the first character, or escape it with a backslash.</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;For example, the character <span class="keyword">class</span> [aeiou] matches any lower <span class="keywordflow">case</span> vowel, <span class="keywordflow">while</span> [^aeiou] matches any character that is not a lower <span class="keywordflow">case</span> vowel. Note that a circumflex is just a convenient notation <span class="keywordflow">for</span> specifying the characters which are in the <span class="keyword">class</span> by enumerating those that are not. It is not an assertion: it still consumes a character from the subject <span class="keywordtype">string</span>, and fails <span class="keywordflow">if</span> the current pointer is at the end of the <span class="keywordtype">string</span>.</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;In UTF-8 mode, characters with values greater than 255 can be included in a <span class="keyword">class</span> as a literal <span class="keywordtype">string</span> of bytes, or by <span class="keyword">using</span> the x{ escaping mechanism.</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;When caseless matching is set, any letters in a <span class="keyword">class</span> represent both their upper <span class="keywordflow">case</span> and lower <span class="keywordflow">case</span> versions, so <span class="keywordflow">for</span> example, a caseless [aeiou] matches <span class="stringliteral">&quot;A&quot;</span> as well as <span class="stringliteral">&quot;a&quot;</span>, and a caseless [^aeiou] does not match <span class="stringliteral">&quot;A&quot;</span>, whereas a caseful version would. PCRE does not support the concept of <span class="keywordflow">case</span> <span class="keywordflow">for</span> characters with values greater than 255.</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;The newline character is never treated in any special way in character classes, whatever the setting of the PCRE_DOTALL or PCRE_MULTILINE options is. A <span class="keyword">class</span> such as [^a] will always match a newline.</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;The minus (hyphen) character can be used to specify a range of characters in a character <span class="keyword">class</span>. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a <span class="keyword">class</span>, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the <span class="keyword">class</span>.</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;It is not possible to have the literal character <span class="stringliteral">&quot;]&quot;</span> as the end character of a range. A pattern such as [W-]46] is interpreted as a <span class="keyword">class </span>of two characters (&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if the &quot;]&quot; is escaped with a backslash it is interpreted as the end of range, so [W-]46] is interpreted as a single class containing a range followed by two separate characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to end a range.</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;Ranges operate in the collating sequence of character values. They can also be used for characters specified numerically, for example [000-037]. In UTF-8 mode, ranges can include characters whose values are greater than 255, for example [x{100}-x{2ff}].</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;If a range that includes letters is used when caseless matching is set, it matches the letters in either <span class="keywordflow">case</span>. For example, [W-c] is equivalent to [][^_`wxyzabc], matched caselessly, and <span class="keywordflow">if</span> character tables <span class="keywordflow">for</span> the <span class="stringliteral">&quot;fr&quot;</span> locale are in use, [xc8-xcb] matches accented E characters in both cases.</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;The character types d, D, s, S, w, and W may also appear in a character <span class="keyword">class</span>, and add the characters that they match to the <span class="keyword">class</span>. For example, [dABCDEF] matches any hexadecimal digit. A circumflex can conveniently be used with the upper <span class="keywordflow">case</span> character types to specify a more restricted set of characters than the matching lower <span class="keywordflow">case</span> type. For example, the <span class="keyword">class </span>[^W_] matches any letter or digit, but not underscore.</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;All non-alphameric characters other than , -, ^ (at the start) and the terminating ] are non-special in character classes, but it does no harm <span class="keywordflow">if</span> they are escaped.</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;## POSIX CHARACTER CLASSES #</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;Perl supports the POSIX notation <span class="keywordflow">for</span> character classes, which uses names enclosed by [: and :] within the enclosing square brackets. PCRE also supports <span class="keyword">this</span> notation. For example,:</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;[01[:alpha:]%]</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;~~~</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;matches <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, any alphabetic character, or <span class="stringliteral">&quot;%&quot;</span>. The supported <span class="keyword">class </span>names are:</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;alnum    letters and digits</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;alpha    letters</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;ascii    character codes 0 - 127</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;blank    space or tab only</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;cntrl    control characters</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;digit    decimal digits (same as \d)</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;graph    printing characters, excluding space</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;lower    lower <span class="keywordflow">case</span> letters</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;print    printing characters, including space</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;punct    printing characters, excluding letters and digits</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;space    white space (not quite the same as \s)</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;upper    upper <span class="keywordflow">case</span> letters</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;word     <span class="stringliteral">&quot;word&quot;</span> characters (same as \w)</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;xdigit   hexadecimal digits</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;~~~</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;The <span class="stringliteral">&quot;space&quot;</span> characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). Notice that <span class="keyword">this</span> list includes the VT character (code 11). This makes <span class="stringliteral">&quot;space&quot;</span> different to s, which does not include VT (<span class="keywordflow">for</span> Perl compatibility).</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;The name <span class="stringliteral">&quot;word&quot;</span> is a Perl extension, and <span class="stringliteral">&quot;blank&quot;</span> is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example,:</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;[12[:^digit:]]</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;~~~</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;matches <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, or any non-digit. PCRE (and Perl) also recognize the POSIX syntax [.ch.] and [=ch=] where <span class="stringliteral">&quot;ch&quot;</span> is a <span class="stringliteral">&quot;collating element&quot;</span>, but these are not supported, and an error is given <span class="keywordflow">if</span> they are encountered.</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;In UTF-8 mode, characters with values greater than 255 <span class="keywordflow">do</span> not match any of the POSIX character classes.</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;## VERTICAL BAR #</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;Vertical bar characters are used to separate alternative patterns. For example, the pattern:</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;gilbert|sullivan</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;~~~</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;matches either <span class="stringliteral">&quot;gilbert&quot;</span> or <span class="stringliteral">&quot;sullivan&quot;</span>. Any number of alternatives may appear, and an empty alternative is permitted (matching the empty <span class="keywordtype">string</span>). The matching process tries each alternative in turn, from left to right, and the first one that succeeds is used. If the alternatives are within a subpattern (defined below), <span class="stringliteral">&quot;succeeds&quot;</span> means matching the rest of the main pattern as well as the alternative in the subpattern.</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;## INTERNAL OPTION SETTING #</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;The settings of the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and PCRE_EXTENDED options can be changed from within the pattern by a sequence of Perl option letters enclosed between <span class="stringliteral">&quot;(?&quot;</span> and <span class="stringliteral">&quot;)&quot;</span>. The option letters are:</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;i  <span class="keywordflow">for</span> PCRE_CASELESS</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;m  <span class="keywordflow">for</span> PCRE_MULTILINE</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;s  <span class="keywordflow">for</span> PCRE_DOTALL</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;x  <span class="keywordflow">for</span> PCRE_EXTENDED</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;~~~</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;For example, (?im) sets caseless, multiline matching. It is also possible to unset these options by preceding the letter with a hyphen, and a combined setting and unsetting such as (?im-sx), which sets PCRE_CASELESS and PCRE_MULTILINE <span class="keywordflow">while</span> unsetting PCRE_DOTALL and PCRE_EXTENDED, is also permitted. If a letter appears both before and after the hyphen, the option is unset.</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;When an option change occurs at top level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows. If the change is placed right at the start of a pattern, PCRE extracts it into the global options (and it will therefore show up in data extracted by the pcre_fullinfo() <span class="keyword">function</span>).</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;An option change within a subpattern affects only that part of the current pattern that follows it, so:</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;(a(?i)b)c</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;~~~</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;matches abc and aBc and no other strings (assuming PCRE_CASELESS is not used). By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example,:</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;(a(?i)b|c)</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;~~~</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;matches &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and &quot;C&quot;, even though when matching &quot;C&quot; the first branch is abandoned before the option setting. This is because the effects of option settings happen at compile time. There would be some very weird behaviour otherwise.</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;The PCRE-specific options PCRE_UNGREEDY and PCRE_EXTRA can be changed in the same way as the Perl-compatible options by using the characters U and X respectively. The (?X) flag setting is special in that it must always occur earlier in the pattern than any of the additional features it turns on, even when it is at top level. It is best put at the start.</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="preprocessor">## SUBPATTERNS #</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;Subpatterns are delimited by parentheses (round brackets), which can be nested. Marking part of a pattern as a subpattern does two things:</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;1. It localizes a set of alternatives. For example, the pattern:~~~{.c}</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;cat(aract|erpillar|)</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;~~~</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;matches one of the words <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;cataract&quot;</span>, or <span class="stringliteral">&quot;caterpillar&quot;</span>. Without the parentheses, it would match <span class="stringliteral">&quot;cataract&quot;</span>, <span class="stringliteral">&quot;erpillar&quot;</span> or the empty <span class="keywordtype">string</span>.</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;2. It sets up the subpattern as a capturing subpattern (as defined above). When the whole pattern matches, that portion of the subject <span class="keywordtype">string</span> that matched the subpattern is passed back to the caller via the ovector argument of pcre_exec(). Opening parentheses are counted from left to right (starting from 1) to obtain the numbers of the capturing subpatterns.</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;For example, <span class="keywordflow">if</span> the <span class="keywordtype">string</span> <span class="stringliteral">&quot;the red king&quot;</span> is matched against the pattern:</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;the ((red|white) (king|queen))</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;~~~</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;the captured substrings are <span class="stringliteral">&quot;red king&quot;</span>, <span class="stringliteral">&quot;red&quot;</span>, and <span class="stringliteral">&quot;king&quot;</span>, and are numbered 1, 2, and 3, respectively.</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;The fact that plain parentheses fulfil two functions is not always helpful. There are often times when a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not <span class="keywordflow">do</span> any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, <span class="keywordflow">if</span> the <span class="keywordtype">string</span> <span class="stringliteral">&quot;the white queen&quot;</span> is matched against the pattern:</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;((?:red|white) (king|queen))</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;~~~</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;the captured substrings are <span class="stringliteral">&quot;white queen&quot;</span> and <span class="stringliteral">&quot;queen&quot;</span>, and are numbered 1 and 2. The maximum number of capturing subpatterns is 65535, and the maximum depth of nesting of all subpatterns, both capturing and noncapturing, is 200.</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;As a convenient shorthand, <span class="keywordflow">if</span> any option settings are required at the start of a non-capturing subpattern, the option letters may appear between the <span class="stringliteral">&quot;?&quot;</span> and the <span class="stringliteral">&quot;:&quot;</span>. Thus the two patterns:</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;(?i:saturday|sunday)</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;(?:(?i)saturday|sunday)</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;~~~</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;match exactly the same set of strings. Because alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match <span class="stringliteral">&quot;SUNDAY&quot;</span> as well as <span class="stringliteral">&quot;Saturday&quot;</span>.</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;## NAMED SUBPATTERNS #</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;Identifying capturing parentheses by number is simple, but it can be very hard to keep track of the numbers in complicated regular expressions. Furthermore, <span class="keywordflow">if</span> an expression is modified, the numbers may change. To help with the difficulty, PCRE supports the naming of subpatterns, something that Perl does not provide. The Python syntax (?P&lt;name&gt;...) is used. Names consist of alphanumeric characters and underscores, and must be unique within a pattern.</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;Named capturing parentheses are still allocated numbers as well as names. The PCRE API provides <span class="keyword">function</span> calls <span class="keywordflow">for</span> extracting the name-to- number translation table from a compiled pattern. For further details see the pcreapi documentation.</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;## REPETITION #</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;Repetition is specified by quantifiers, which can follow any of the following items:</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;a literal data character</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;the . metacharacter</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;the \C escape sequence</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;escapes such as \d that match single characters</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;a character <span class="keyword">class</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;a back reference (see next section)</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;a parenthesized subpattern (unless it is an assertion)</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;~~~</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be less than 65536, and the first must be less than or equal to the second. For example:</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;z{2,4}</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;matches <span class="stringliteral">&quot;zz&quot;</span>, <span class="stringliteral">&quot;zzz&quot;</span>, or <span class="stringliteral">&quot;zzzz&quot;</span>. A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit; <span class="keywordflow">if</span> the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;[aeiou]{3,}</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;matches at least 3 successive vowels, but may match many more, <span class="keywordflow">while</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;d{8}</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;matches exactly 8 digits. An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal <span class="keywordtype">string</span> of four characters.</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;In UTF-8 mode, quantifiers apply to UTF-8 characters rather than to individual bytes. Thus, <span class="keywordflow">for</span> example, x{100}{2} matches two UTF-8 characters, each of which is represented by a two-byte sequence.</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;The quantifier {0} is permitted, causing the expression to behave as <span class="keywordflow">if</span> the previous item and the quantifier were not present.</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;For convenience (and historical compatibility) the three most common quantifiers have single-character abbreviations:</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;*    is equivalent to {0,}</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;+    is equivalent to {1,}</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;?    is equivalent to {0,1}</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;~~~</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;It is possible to construct infinite loops by following a subpattern that can match no characters with a quantifier that has no upper limit, <span class="keywordflow">for</span> example:</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;(a?)*</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;~~~</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;Earlier versions of Perl and PCRE used to give an error at compile time <span class="keywordflow">for</span> such patterns. However, because there are cases where <span class="keyword">this</span> can be useful, such patterns are now accepted, but <span class="keywordflow">if</span> any repetition of the subpattern does in fact match no characters, the loop is forcibly broken.</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;By <span class="keywordflow">default</span>, the quantifiers are <span class="stringliteral">&quot;greedy&quot;</span>, that is, they match as much as possible (up to the maximum number of permitted times), without causing the rest of the pattern to fail. The classic example of where <span class="keyword">this</span> gives problems is in trying to match comments in C programs. These appear between the sequences `<span class="comment">/*` and `*/</span>` and within the sequence, individual `*` and `/` characters may appear. An attempt to match C comments by applying the pattern:</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;/\*.*\*/</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;~~~</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;to the <span class="keywordtype">string</span>:</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment">/* first comment */</span> not comment <span class="comment">/* second comment */</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;~~~</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;fails, because it matches the entire <span class="keywordtype">string</span> owing to the greediness of the `.*` item.</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;However, <span class="keywordflow">if</span> a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the pattern:</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;/\*.*?\*/</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;~~~</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;does the right thing with the C comments. The meaning of the various quantifiers is not otherwise changed, just the preferred number of matches. Do not confuse <span class="keyword">this</span> use of question mark with its use as a quantifier in its own right. Because it has two uses, it can sometimes appear doubled, as in:</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;\d??\d</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;~~~</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;which matches one digit by preference, but can match two <span class="keywordflow">if</span> that is the only way the rest of the pattern matches.</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;If the PCRE_UNGREEDY option is set (an option which is not available in Perl), the quantifiers are not greedy by <span class="keywordflow">default</span>, but individual ones can be made greedy by following them with a question mark. In other words, it inverts the <span class="keywordflow">default</span> behaviour.</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;When a parenthesized subpattern is quantified with a minimum repeat count that is greater than 1 or with a limited maximum, more store is required <span class="keywordflow">for</span> the compiled pattern, in proportion to the size of the minimum or maximum.</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;If a pattern starts with `.*` or `.{0,}` and the PCRE_DOTALL option (equivalent to Perl<span class="stringliteral">&#39;s `/s`) is set, thus allowing the `.` to match newlines, the pattern is implicitly anchored, because whatever follows will be tried against every character position in the subject string, so there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as though it were preceded by `\A`.</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="stringliteral">In cases where it is known that the subject string contains no newlines, it is worth setting PCRE_DOTALL in order to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="stringliteral">However, there is one situation where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a backreference elsewhere in the pattern, a match at the start may fail, and a later one succeed. Consider, for example:</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="stringliteral">(.*)abc\1</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="stringliteral">If the subject is &quot;xyz123abc123&quot; the match point is the fourth character. For this reason, such a pattern is not implicitly anchored.</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="stringliteral">When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after:</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral">(tweedle[dume]{3}\s*)+</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="stringliteral">has matched &quot;tweedledum tweedledee&quot; the value of the captured substring is &quot;tweedledee&quot;. However, if there are nested capturing subpatterns, the corresponding captured values may have been set in previous iterations. For example, after:</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="stringliteral">/(a|(b))+/</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="stringliteral">matches &quot;aba&quot; the value of the second captured substring is &quot;b&quot;.</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral">## ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS #</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="stringliteral">With both maximizing and minimizing repetition, failure of what follows normally causes the repeated item to be re-evaluated to see if a different number of repeats allows the rest of the pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it fail earlier than it otherwise might, when the author of the pattern knows there is no point in carrying on.</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="stringliteral">Consider, for example, the pattern d+foo when applied to the subject line:</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="stringliteral">123456bar</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="stringliteral">After matching all 6 digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only 5 digits matching the d+ item, and then with 4, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl&#39;</span>s book) provides the means <span class="keywordflow">for</span> specifying that once a subpattern has matched, it is not to be re-evaluated in <span class="keyword">this</span> way.</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;If we use atomic grouping <span class="keywordflow">for</span> the previous example, the matcher would give up immediately on failing to match <span class="stringliteral">&quot;foo&quot;</span> the first time. The notation is a kind of special parenthesis, starting with (?&gt; as in <span class="keyword">this</span> example:</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;(?&gt;\d+)foo</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;~~~</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;This kind of parenthesis <span class="stringliteral">&quot;locks up&quot;</span> the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;An alternative description is that a subpattern of <span class="keyword">this</span> type matches the <span class="keywordtype">string</span> of characters that an identical standalone pattern would match, <span class="keywordflow">if</span> anchored at the current point in the subject <span class="keywordtype">string</span>.</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, <span class="keywordflow">while</span> both d+ and d+? are prepared to adjust the number of digits they match in order to make the rest of the pattern match, (?&gt;d+) can only match an entire sequence of digits.</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;Atomic groups in general can of course contain arbitrarily complicated subpatterns, and can be nested. However, when the subpattern <span class="keywordflow">for</span> an atomic group is just a single repeated item, as in the example above, a simpler notation, called a <span class="stringliteral">&quot;possessive quantifier&quot;</span> can be used. This consists of an additional + character following a quantifier. Using <span class="keyword">this</span> notation, the previous example can be rewritten as:</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;\d++bar</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;~~~</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;Possessive quantifiers are always greedy; the setting of the PCRE_UNGREEDY option is ignored. They are a convenient notation <span class="keywordflow">for</span> the simpler forms of atomic group. However, there is no difference in the meaning or processing of a possessive quantifier and the equivalent atomic group.</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;The possessive quantifier syntax is an extension to the Perl syntax. It originates in Sun<span class="stringliteral">&#39;s Java package.</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="stringliteral">When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a very long time indeed. The pattern:</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="stringliteral">(\D+|&lt;\d+&gt;)*[!?]</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="stringliteral">matches an unlimited number of substrings that either consist of non- digits, or digits enclosed in &lt;&gt;, followed by either ! or ?. When it matches, it runs quickly. However, if it is applied to:</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="stringliteral">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="stringliteral">it takes a long time before reporting failure. This is because the string can be divided between the two repeats in a large number of ways, and all have to be tried. (The example used [!?] rather than a single character at the end, because both PCRE and Perl have an optimization that allows for fast failure when a single character is used. They remember the last single character that is required for a match, and fail early if it is not present in the string.) If the pattern is changed to:</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="stringliteral">((?&gt;\D+)|&lt;\d+&gt;)*[!?]</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="stringliteral">sequences of non-digits cannot be broken, and failure happens quickly.</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="stringliteral">## BACK REFERENCES #</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="stringliteral">Outside a character class, a backslash followed by a digit greater than 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses.</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="stringliteral">However, if the decimal number following the backslash is less than 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. In other words, the parentheses that are referenced need not be to the left of the reference for numbers less than 10. See the section entitled &quot;Backslash&quot; above for further details of the handling of digits following a backslash.</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="stringliteral">A back reference matches whatever actually matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself (see &quot;Subpatterns as subroutines&quot; below for a way of doing that). So the pattern:</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="stringliteral">(sens|respons)e and \1ibility</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="stringliteral">matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;. If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example,:</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="stringliteral">((?i)rah)\s+\1</span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="stringliteral">matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, even though the original capturing subpattern is matched caselessly.</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="stringliteral">Back references to named subpatterns use the Python syntax (?P=name). We could rewrite the above example as follows:</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="stringliteral">(?&lt;p1&gt;(?i)rah)\s+(?P=p1)</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="stringliteral">There may be more than one back reference to the same subpattern. If a subpattern has not actually been used in a particular match, any back references to it always fail. For example, the pattern:</span></div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="stringliteral">(a|(bc))\2</span></div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="stringliteral">always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;. Because there may be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If the PCRE_EXTENDED option is set, this can be whitespace. Otherwise an empty comment can be used.</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="stringliteral">A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a1) never matches. However, such references can be useful inside repeated subpatterns. For example, the pattern:</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="stringliteral">(a|b\1)+</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="stringliteral">matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot; etc. At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="stringliteral">## ASSERTIONS #</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="stringliteral">An assertion is a test on the characters following or preceding the current matching point that does not actually consume any characters. The simple assertions coded as b, B, A, G, Z, z, ^ and $ are described above. More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it.</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral">An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed. Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example,:</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral">\w+(?=;)</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral">matches a word followed by a semicolon, but does not include the semicolon in the match, and:</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="stringliteral">foo(?!bar)</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral">matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;. Note that the apparently similar pattern:</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral">(?!foo)bar</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral">does not find an occurrence of &quot;bar&quot; that is preceded by something other than &quot;foo&quot;; it finds any occurrence of &quot;bar&quot; whatsoever, because the assertion (?!foo) is always true when the next three characters are &quot;bar&quot;. A lookbehind assertion is needed to achieve this effect.</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="stringliteral">If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!) because an empty string always matches, so an assertion that requires there not to be an empty string must always fail.</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="stringliteral">Lookbehind assertions start with (?&lt;= for positive assertions and (?&lt;! for negative assertions. For example,:</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="stringliteral">(?&lt;!foo)bar</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="stringliteral">does find an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;. The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are several alternatives, they do not all have to have the same fixed length. Thus:</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral">(?&lt;=bullock|donkey)</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="stringliteral">is permitted, but:</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral">(?&lt;!dogs?|cats?)</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral">causes an error at compile time. Branches that match different length strings are permitted only at the top level of a lookbehind assertion. This is an extension compared with Perl (at least for 5.8), which requires all branches to match the same length of string. An assertion such as:</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral">(?&lt;=ab(c|de))</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral">is not permitted, because its single top-level branch can match two different lengths, but it is acceptable if rewritten to use two top- level branches:</span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="stringliteral">(?&lt;=abc|abde)</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="stringliteral">The implementation of lookbehind assertions is, for each alternative, to temporarily move the current position back by the fixed width and then try to match. If there are insufficient characters before the current position, the match is deemed to fail.</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="stringliteral">PCRE does not allow the C escape (which matches a single byte in UTF-8 mode) to appear in lookbehind assertions, because it makes it impossible to calculate the length of the lookbehind.</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="stringliteral">Atomic groups can be used in conjunction with lookbehind assertions to specify efficient matching at the end of the subject string. Consider a simple pattern such as:</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="stringliteral">abcd$</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="stringliteral">when applied to a long string that does not match. Because matching proceeds from left to right, PCRE will look for each &quot;a&quot; in the subject and then see if what follows matches the rest of the pattern. If the pattern is specified as:</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="stringliteral">^.*abcd$</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="stringliteral">the initial .* matches the entire string at first, but when this fails (because there is no following &quot;a&quot;), it backtracks to match all but the last character, then all but the last two characters, and so on. Once again the search for &quot;a&quot; covers the entire string, from right to left, so we are no better off. However, if the pattern is written as:</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="stringliteral">^(?&gt;.*)(?&lt;=abcd)</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="stringliteral">or, equivalently,:</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="stringliteral">^.*+(?&lt;=abcd)</span></div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="stringliteral">there can be no backtracking for the .* item; it can match only the entire string. The subsequent lookbehind assertion does a single test on the last four characters. If it fails, the match fails immediately. For long strings, this approach makes a significant difference to the processing time.</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="stringliteral">Several assertions (of any sort) may occur in succession. For example,:</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="stringliteral">(?&lt;=\d{3})(?&lt;!999)foo</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="stringliteral">matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;. Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does not match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it doesn&#39;</span>t match <span class="stringliteral">&quot;123abcfoo&quot;</span>. A pattern to <span class="keywordflow">do</span> that is:</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;(?&lt;=\d{3}...)(?&lt;!999)foo</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;~~~</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;This time the first assertion looks at the preceding six characters, checking that the first three are digits, and then the second assertion checks that the preceding three characters are not <span class="stringliteral">&quot;999&quot;</span>.</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;Assertions can be nested in any combination. For example,:</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;(?&lt;=(?&lt;!foo)bar)baz</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;~~~</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;matches an occurrence of <span class="stringliteral">&quot;baz&quot;</span> that is preceded by <span class="stringliteral">&quot;bar&quot;</span> which in turn is not preceded by <span class="stringliteral">&quot;foo&quot;</span>, <span class="keywordflow">while</span>:</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;(?&lt;=\d{3}(?!999)...)foo</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;~~~</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;is another pattern which matches <span class="stringliteral">&quot;foo&quot;</span> preceded by three digits and any three characters that are not <span class="stringliteral">&quot;999&quot;</span>.</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;Assertion subpatterns are not capturing subpatterns, and may not be repeated, because it makes no sense to assert the same thing several times. If any kind of assertion contains capturing subpatterns within it, these are counted <span class="keywordflow">for</span> the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is carried out only <span class="keywordflow">for</span> positive assertions, because it does not make sense <span class="keywordflow">for</span> negative assertions.</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;## CONDITIONAL SUBPATTERNS #</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a previous capturing subpattern matched or not. The two possible forms of conditional subpattern are:</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;(?(condition)yes-pattern)</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;(?(condition)yes-pattern|no-pattern)</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;~~~</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;If the condition is satisfied, the yes-pattern is used; otherwise the no-pattern (<span class="keywordflow">if</span> present) is used. If there are more than two alternatives in the subpattern, a compile-time error occurs.</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;There are three kinds of condition. If the text between the parentheses consists of a sequence of digits, the condition is satisfied <span class="keywordflow">if</span> the capturing subpattern of that number has previously matched. The number must be greater than zero. Consider the following pattern, which contains non-significant white space to make it more readable (assume the PCRE_EXTENDED option) and to divide it into three parts <span class="keywordflow">for</span> ease of discussion:</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;( \( )?    [^()]+   (?(1) \) )</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;~~~</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;The first part matches an optional opening parenthesis, and <span class="keywordflow">if</span> that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, <span class="keywordflow">if</span> subject started with an opening parenthesis, the condition is <span class="keyword">true</span>, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, since no-pattern is not present, the subpattern matches nothing. In other words, <span class="keyword">this</span> pattern matches a sequence of non-parentheses, optionally enclosed in parentheses.</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;If the condition is the string (R), it is satisfied <span class="keywordflow">if</span> a recursive call to the pattern or subpattern has been made. At <span class="stringliteral">&quot;top level&quot;</span>, the condition is <span class="keyword">false</span>. This is a PCRE extension. Recursive patterns are described in the next section.</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;If the condition is not a sequence of digits or (R), it must be an assertion. This may be a positive or negative lookahead or lookbehind assertion. Consider <span class="keyword">this</span> pattern, again containing non-significant white space, and with the two alternatives on the second line:</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;(?(?=[^a-z]*[a-z])</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;~~~</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. In other words, it tests <span class="keywordflow">for</span> the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative; otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;## COMMENTS #</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;The sequence (?# marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part in the pattern matching at all.</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;If the PCRE_EXTENDED option is set, an unescaped # character outside a character <span class="keyword">class</span> introduces a comment that continues up to the next newline character in the pattern.</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;## RECURSIVE PATTERNS #</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;Consider the problem of matching a <span class="keywordtype">string</span> in parentheses, allowing <span class="keywordflow">for</span> unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth. Perl has provided an experimental facility that allows regular expressions to recurse (amongst other things). It does <span class="keyword">this</span> by interpolating Perl code in the expression at run time, and the code can refer to the expression itself. A Perl pattern to solve the parentheses problem can be created like <span class="keyword">this</span>:</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;$re = qr{\( (?: (?&gt;[^()]+) | (?p{$re}) )* \)}x;</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;~~~</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;The (?p{...}) item interpolates Perl code at run time, and in <span class="keyword">this</span> <span class="keywordflow">case</span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;refers recursively to the pattern in which it appears. Obviously, PCRE</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;cannot support the interpolation of Perl code. Instead, it supports</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;some special syntax <span class="keywordflow">for</span> recursion of the entire pattern, and also <span class="keywordflow">for</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;individual subpattern recursion.</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;The special item that consists of (? followed by a number greater than zero and a closing parenthesis is a recursive call of the subpattern of the given number, provided that it occurs inside that subpattern. (If not, it is a <span class="stringliteral">&quot;subroutine&quot;</span> call, which is described in the next section.) The special item (?R) is a recursive call of the entire regular expression.</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;For example, <span class="keyword">this</span> PCRE pattern solves the nested parentheses problem (assume the PCRE_EXTENDED option is set so that white space is ignored):</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;\( ( (?&gt;[^()]+) | (?R) )* \)</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;~~~</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;First it matches an opening parenthesis. Then it matches any number of substrings which can either be a sequence of non-parentheses, or a recursive match of the pattern itself (that is a correctly parenthesized substring). Finally there is a closing parenthesis.</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;If <span class="keyword">this</span> were part of a larger pattern, you would not want to recurse the entire pattern, so instead you could use <span class="keyword">this</span>:</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;( \( ( (?&gt;[^()]+) | (?1) )* \) )</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;~~~</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;We have put the pattern into parentheses, and caused the recursion to refer to them instead of the whole pattern. In a larger pattern, keeping track of parenthesis numbers can be tricky. It may be more convenient to use named parentheses instead. For <span class="keyword">this</span>, PCRE uses (?P&gt;name), which is an extension to the Python syntax that PCRE uses <span class="keywordflow">for</span> named parentheses (Perl does not provide named parentheses). We could rewrite the above example as follows:</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;(?P&lt;pn&gt; \( ( (?&gt;[^()]+) | (?P&gt;pn) )* \) )</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;~~~</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;This particular example pattern contains nested unlimited repeats, and so the use of atomic grouping <span class="keywordflow">for</span> matching strings of non-parentheses is important when applying the pattern to strings that <span class="keywordflow">do</span> not match. For example, when <span class="keyword">this</span> pattern is <a class="code" href="classapplied.html">applied</a> to:</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;~~~</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;it yields <span class="stringliteral">&quot;no match&quot;</span> quickly. However, <span class="keywordflow">if</span> atomic grouping is not used, the match runs <span class="keywordflow">for</span> a very <span class="keywordtype">long</span> time indeed because there are so many different ways the + and * repeats can carve up the subject, and all have to be tested before failure can be reported.</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;At the end of a match, the values set <span class="keywordflow">for</span> any capturing subpatterns are those from the outermost level of the recursion at which the subpattern value is set. If you want to obtain intermediate values, a callout <span class="keyword">function</span> can be used (see below and the pcrecallout documentation). If the pattern above is matched against:</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;(ab(cd)ef)</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;~~~</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;the value for the capturing parentheses is &quot;ef&quot;, which is the last value taken on at the top level. If additional parentheses are added, giving:</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;   ^                        ^</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;   ^                        ^</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;~~~</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;the <span class="keywordtype">string</span> they capture is <span class="stringliteral">&quot;ab(cd)ef&quot;</span>, the contents of the top level parentheses. If there are more than 15 capturing parentheses in a pattern, PCRE has to obtain extra memory to store data during a recursion, which it does by <span class="keyword">using</span> pcre_malloc, freeing it via pcre_free afterwards. If no memory can be obtained, the match fails with the PCRE_ERROR_NOMEMORY error.</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;Do not confuse the (?R) item with the condition (R), which tests for recursion. Consider this pattern, which matches text in angle brackets, allowing for arbitrary nesting. Only digits are allowed in nested brackets (that is, when recursing), whereas any characters are permitted at the outer level.:</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;&lt; (?: (?(R) \d++  | [^&lt;&gt;]*+) | (?R)) * &gt;</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;~~~</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;In <span class="keyword">this</span> pattern, (?(R) is the start of a conditional subpattern, with two different alternatives <span class="keywordflow">for</span> the recursive and non-recursive cases. The (?R) item is the actual recursive call.</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;## SUBPATTERNS AS SUBROUTINES #</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;If the syntax <span class="keywordflow">for</span> a recursive subpattern reference (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. An earlier example pointed out that the pattern:</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;(sens|respons)e and \1ibility</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;~~~</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;matches <span class="stringliteral">&quot;sense and sensibility&quot;</span> and <span class="stringliteral">&quot;response and responsibility&quot;</span>, but not <span class="stringliteral">&quot;sense and responsibility&quot;</span>. If instead the pattern:</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;(sens|respons)e and (?1)ibility</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;~~~</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;is used, it does match <span class="stringliteral">&quot;sense and responsibility&quot;</span> as well as the other two strings. Such references must, however, follow the subpattern to which they refer.</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;## CALLOUTS #</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;Perl has a feature whereby <span class="keyword">using</span> the sequence (?{...}) causes arbitrary Perl code to be obeyed in the middle of matching a regular expression. This makes it possible, amongst other things, to extract different substrings that match the same pair of parentheses when there is a repetition.</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;PCRE provides a similar feature, but of course it cannot obey arbitrary Perl code. The feature is called <span class="stringliteral">&quot;callout&quot;</span>. The caller of PCRE provides an external <span class="keyword">function</span> by putting its entry point in the global variable pcre_callout. By <span class="keywordflow">default</span>, <span class="keyword">this</span> variable contains NULL, which disables all calling out.</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;Within a regular expression, (?C) indicates the points at which the external <span class="keyword">function</span> is to be called. If you want to identify different callout points, you can put a number less than 256 after the letter C. The <span class="keywordflow">default</span> value is zero. For example, <span class="keyword">this</span> pattern has two callout points:</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;(?C1)abc(?C2)def</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;~~~</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;During matching, when PCRE reaches a callout point (and pcre_callout is set), the external <span class="keyword">function</span> is called. It is provided with the number of the callout, and, optionally, one item of data originally supplied by the caller of pcre_exec(). The callout <span class="keyword">function</span> may cause matching to backtrack, or to fail altogether. A complete description of the <span class="keyword">interface </span>to the callout function is given in the pcrecallout documentation.</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;## DIFFERENCES FROM PERL #</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;This section escribes the differences in the ways that PCRE and Perl handle regular expressions. The differences described here are with respect to Perl 5.8.</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;1. PCRE does not have full UTF-8 support. Details of what it does have are given in the section on UTF-8 support in the main pcre page.</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;2. PCRE does not allow repeat quantifiers on lookahead assertions. Perl permits them, but they do not mean what you might think. For example, (?!a){3} does not assert that the next three characters are not <span class="stringliteral">&quot;a&quot;</span>. It just asserts that the next character is not <span class="stringliteral">&quot;a&quot;</span> three times.</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;3. Capturing subpatterns that occur inside negative lookahead assertions are counted, but their entries in the offsets vector are never set. Perl sets its numerical variables from any such patterns that are matched before the assertion fails to match something (thereby succeeding), but only <span class="keywordflow">if</span> the negative lookahead assertion contains just one branch.</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;4. Though binary zero characters are supported in the subject string, they are not allowed in a pattern <span class="keywordtype">string</span> because it is passed as a normal C string, terminated by zero. The escape sequence <span class="stringliteral">&quot;0&quot;</span> can be used in the pattern to represent a binary zero.</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;5. The following Perl escape sequences are not supported: l, u, L, U, P, p, N, and X. In fact these are implemented by Perl<span class="stringliteral">&#39;s general string-handling and are not part of its pattern matching engine. If any of these are encountered by PCRE, an error is generated.</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="stringliteral">6. PCRE does support the Q...E escape for quoting substrings. Characters in between are treated as literals. This is slightly different from Perl in that $ and @ are also handled as literals inside the quotes. In Perl, they cause variable interpolation (but of course PCRE does not have variables). Note the following examples:~~~{.c}</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="stringliteral">Pattern            PCRE matches      Perl matches</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="stringliteral">\Qabc$xyz\E        abc$xyz           abc followed by the</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="stringliteral">                                      contents of $xyz</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="stringliteral">\Qabc\$xyz\E       abc\$xyz          abc\$xyz</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="stringliteral">\Qabc\E\$\Qxyz\E   abc$xyz           abc$xyz</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="stringliteral">The Q...E sequence is recognized both inside and outside character classes.</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="stringliteral">7. Fairly obviously, PCRE does not support the (?{code}) and (?p{code}) constructions. However, there is some experimental support for recursive patterns using the non-Perl items (?R), (?number) and (?P&gt;name). Also, the PCRE &quot;callout&quot; feature allows an external function to be called during pattern matching.</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="stringliteral">8. There are some differences that are concerned with the settings of captured strings when part of a pattern is repeated. For example, matching &quot;aba&quot; against the pattern /^(a(b)?)+$/ in Perl leaves $2 unset, but in PCRE it is set to &quot;b&quot;.</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="stringliteral">9. PCRE provides some extensions to the Perl regular expression facilities:</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="stringliteral">1. Although lookbehind assertions must match fixed length strings, each alternative branch of a lookbehind assertion can match a different length of string. Perl requires them all to have the same length.</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="stringliteral">2. If PCRE_DOLLAR_ENDONLY is set and PCRE_MULTILINE is not set, the $ meta-character matches only at the very end of the string.</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="stringliteral">3. If PCRE_EXTRA is set, a backslash followed by a letter with no special meaning is faulted.</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="stringliteral">4. If PCRE_UNGREEDY is set, the greediness of the repetition quantifiers is inverted, that is, by default they are not greedy, but if followed by a question mark they are.</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="stringliteral">5. PCRE_ANCHORED can be used to force a pattern to be tried only at the first matching position in the subject string.</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="stringliteral">6. The PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, and PCRE_NO_AUTO_CAPTURE options for pcre_exec() have no Perl equivalents.</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="stringliteral">7. The (?R), (?number), and (?P&gt;name) constructs allows for recursive pattern matching (Perl can do this using the (?p{code}) construct, which PCRE cannot support.)</span></div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="stringliteral">8. PCRE supports named capturing substrings, using the Python syntax.</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="stringliteral">9. PCRE supports the possessive quantifier &quot;++&quot; syntax, taken from Sun&#39;</span>s Java package.</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;10. The (R) condition, for testing recursion, is a PCRE extension.</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;11. The callout facility is PCRE-specific.</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    </div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="preprocessor">## NOTES #</span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;The &lt; and &gt; metacharacters from Henry Spencers <span class="keyword">package </span>are not available in PCRE, but can be emulated with b, as required, also in conjunction with W or w.</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;In LDMud, backtracks are limited by the EVAL_COST runtime limit, to avoid freezing the driver with a match like regexp(({&quot;=XX===================&quot;}), &quot;X(.+)+X&quot;).</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;LDMud doesn&#39;t support PCRE callouts.</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;## LIMITATIONS #</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;There are some size limitations in PCRE but it is hoped that they will never in practice be relevant. The maximum length of a compiled pattern is 65539 (sic) bytes. All values in repeating quantifiers must be less than 65536. There maximum number of capturing subpatterns is 65535. There is no limit to the number of non-capturing subpatterns, but the maximum depth of nesting of all kinds of parenthesized subpattern, including capturing subpatterns, assertions, and other types of subpattern, is 200.</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;The maximum length of a subject string is the largest positive number that an integer variable can hold. However, PCRE uses recursion to handle subpatterns and indefinite repetition. This means that the available stack space may limit the size of a subject string that can be processed by certain patterns.</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;Author:</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;Philip Hazel &lt;ph10@cam.ac.uk&gt;</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;University Computing Service,</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;New Museums Site,</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;Cambridge CB2 3QG, England.</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;Phone: +44 1223 334714</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;~~~</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;@see @ref driver_concepts_regexp &quot;regexp&quot;, @ref driver_concepts_hsregexp &quot;hsregexp&quot;</div>
<div class="ttc" id="classapplied_html"><div class="ttname"><a href="classapplied.html">applied</a></div><div class="ttdef"><b>Definition:</b> <a href="____INIT_8c_source.html#l00001">__INIT.c:1</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>pcre.md</b></li>
    <li class="footer">Generated on Sat Jun 11 2016 14:24:07 for Tsunami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
