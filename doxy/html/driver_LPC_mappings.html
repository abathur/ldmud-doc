<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Tsunami: mappings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tsunami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('driver_LPC_mappings.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">mappings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>flerp</p>
<h1><a class="anchor" id="driver_LPC_mappings"></a>
mappings</h1>
<p>A mapping is a datatype which allows to store data associated to a key. In other languages they are also known as 'dictionaries' or 'alists'. There are also alists in LPC but they are not a separate datatype but are implemented on top of arrays. Alists are the predecessors of mappings. The keys and the values can be of any type. But most common datatypes for keys are strings, integers and objects. Others like arrays, mappings or closures aren't a good choice because comparision between i.e. arrays often returns false even if they equal in content. This is because the driver compares i.e. two arrays by their internal pointers and not by their content. The reason for this is simple: speed.</p>
<p>Mappings are allways treated as references when passing them to functions. This means when you pass a mapping to another object and this object modifies the mapping the modification will take place in a global scope - visible to all objects holding this mapping in a variable.</p>
<h2>WHAT ARE MAPPINGS GOOD FOR?</h2>
<p>The term 'dictionary' probably describes the use of a mapping best. Opposed to arrays mappings don't have a specific order. They provide a mechanism to create a set of associations between values. Such an association consists of a unique key and data that is identified by the key. Think of a dictionary where you have a word and a definition of it. You use the word to lookup its definition.</p>
<p>Mappings can be used i.e. to hold aliases for commands. The key would then be the name of the alias and the data the command(s) behind an alias. Or they can be used for the exits of a room. The keys would be the directions where one can go to and the associated data would be the file names of the rooms. But mappings can also be used as a kind of a sparse array. A sparse array is an array where most of the elements aren't used (occupied by 0). I.e. if you want to store values at the position 0, 13 and 37642 of an array you would have to create an array with a size of at least 37643. This costs a lot of memory so a mapping would be more useful because you would then use the numbers 0, 13 and 37642 as a key and not as an index to a position (actually the keys of a mapping are sometimes called indices but this is just because the way data is accessed in a mapping is similar to arrays: by the [] operator). This also allows to query all occupied positions of a sparse array by querying for all the keys of the mapping opposed to an array where you have to iterate over all elements.</p>
<h2>HOW DO I CREATE A MAPPING?</h2>
<p>There are several ways to do so. The most convenient is the following:</p>
<div class="fragment"><div class="line">mapping map;</div>
<div class="line">map = ([</div>
<div class="line">  key0: value00; ...; value0n,</div>
<div class="line">  ... : ...    ; ...; ...    ,</div>
<div class="line">  keyn: valuen0; ...; valuenn</div>
<div class="line">]);</div>
</div><!-- fragment --><p> As you can see, a key may have more than one value assigned. But the amount of values per key must always be equal. It is even possible to have mappings without any values!</p>
<p>Another method is to use the efun mkmapping(). This efun gets two arguments with the first beeing an array of keys and the following beeing arrays of values:</p>
<div class="fragment"><div class="line">mapping map;</div>
<div class="line">map = mkmapping (</div>
<div class="line">  ({ key0   , ..., keyn    }),</div>
<div class="line">  ({ value00, ..., value0n }),</div>
<div class="line">  ({ ...    , ..., ...     }),</div>
<div class="line">  ({ valuen0, ..., valuenn })</div>
<div class="line">);</div>
</div><!-- fragment --><p> If the efun only gets one argument, then this argument will be taken as an array of keys and a mapping without values will be returned.</p>
<p>An empty mapping can be created by using the above described methods by simply ommitting the keys and values:</p>
<div class="fragment"><div class="line">mapping map;</div>
<div class="line">map = ([]);</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line">map = mkmapping(({}), ({}));</div>
</div><!-- fragment --><p> Or by using the efun m_allocate(). This efun gets as first argument the amount of keys which will be added soon and an optional second argument specifying the width of the mapping:</p>
<div class="fragment"><div class="line">map = m_allocate(n, width);</div>
</div><!-- fragment --><p> The value &lt;n&gt; may be a bit confusing since mappings shrink and grow dynamically. This value just tells the driver how 'long' this mapping is going to be so proper memory allocations will be performed to reduce the overhead of memory reallocation. I.e. if you want to read in a file and store the read data in a mapping you probably know the amount of keys. So you allocate a mapping with this efun and tell the driver how much memory should be allocated by specifing a proper &lt;n&gt; value. Thus causing a speedup when adding the read data to the mapping afterwards. The &lt;width&gt; just specifies how many values per key this mapping is going to have. If no width is given, 1 will be taken as default.</p>
<p>An empty mapping created with '([])' will always have a width of 1. To create empty mappings with other widths, write it as:</p>
<div class="fragment"><div class="line">map = ([:width ]);</div>
</div><!-- fragment --><p> &lt;width&gt; can be any expression returning an integer value (including function calls), and in fact this notation is just a fancy way of writing:</p>
<div class="fragment"><div class="line">map = m_allocate(0, width);</div>
</div><!-- fragment --><h2>HOW CAN I MODIFY THE DATA OF A MAPPING?</h2>
<p>Adding a new key is similiar to modifying the associated data of an existing key:</p>
<div class="fragment"><div class="line">map += ([ key: value0; ...; valuen ]);</div>
</div><!-- fragment --><p> Or in case only a single value should be modified:</p>
<div class="fragment"><div class="line">map[key, n] = valuen;</div>
</div><!-- fragment --><p> If &lt;n&gt; is out of range or if &lt;key&gt; doesn't exists and &lt;n&gt; is greater than 0 an "Illegal index" error will be reported. If &lt;n&gt; is equal to 0 or the mapping only has a single value per key one can abbreviate it with:</p>
<div class="fragment"><div class="line">map[key] = value;</div>
</div><!-- fragment --><p> If there is no &lt;key&gt; (and &lt;n&gt; is equal to 0 or not specified at all) a new one will be added automatically.</p>
<p>Deletion of a key is done with the -= operator or the efun m_delete(). A mapping can only be substracted by one without any values:</p>
<div class="fragment"><div class="line">map -= ([ key ]);</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line">map -= ([ key0, ..., keyn ]);</div>
</div><!-- fragment --><p> The efun takes a mapping as first and a key as second argument:</p>
<div class="fragment"><div class="line">m_delete(map, key);</div>
</div><!-- fragment --><p> The efun m_delete() returns the mapping but because mappings are handled as references there is no need of an assignment like:</p>
<div class="fragment"><div class="line">map = m_delete(map, key);</div>
</div><!-- fragment --><h2>HOW CAN I ACCESS THE DATA STORED IN A MAPPING?</h2>
<p>This can be done by:</p>
<div class="fragment"><div class="line">valuen = map[key, n];</div>
</div><!-- fragment --><p> Or in case of a mapping with just one value per key:</p>
<div class="fragment"><div class="line">value0 = map[key];</div>
</div><!-- fragment --><p> If there is no &lt;key&gt; in the mapping and &lt;n&gt; is 0 or not specified at all (which is the same) a 0 will be returned or if &lt;n&gt; is greater than 0 an "Illegal index" error will be reported.</p>
<h2>HOW CAN I TEST FOR THE EXISTANCE OF A KEY?</h2>
<p>A return value of 0 is sufficient for most applications but sometimes the ambiguity between an existing value of 0 and a nonexisting key can lead to a problem. Therefore one can use the efun member() or mapping_contains() to check if there actually is a key in the mapping:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (member(map, key)) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> or:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (mapping_contains(&amp;value0, ..., &amp;valuen, map, key)) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> This also shows how one can retrieve all values associated to a key from a mapping in a single step. The '&amp;' is the reference operator which is neccesary to let the efun store the values in the variables.</p>
<p>In case of mappings with no values, the efun member() and mapping_contains() are equal in their behaviour and their way of calling because mapping_contains() won't get any reference variables to store the values in (obviously, because there aren't any).</p>
<p>Also normally member() is known to return the postion of an element in a list (i.e. a character in a string or data in an array) and if an element couldn't be found -1 is returned. But in the case of mappings there are no such things as order and postion. So member() only returns 0 or 1.</p>
<h2>HOW CAN I COPY A MAPPING?</h2>
<p>A mapping can be copied with the + operator or by the efun copy_mapping():</p>
<p>newmap = ([]) + map;</p>
<p>or:</p>
<div class="fragment"><div class="line">newmap = copy_mapping(map);</div>
</div><!-- fragment --><p> A mapping should only be copied when it is neccesary to get an own copy of it that must not be shared by other objects.</p>
<h2>HOW CAN I GET ALL KEYS OF A MAPPING?</h2>
<p>The efun m_indices() gets a mapping as argument and returns an array holding all keys defined in this mapping:</p>
<div class="fragment"><div class="line">keys = m_indices(map);</div>
</div><!-- fragment --><h2>HOW CAN I GET ALL THE VALUES OF A MAPPING?</h2>
<p>The efun m_values() gets a mapping as argument and returns an array holding all the first (second, ...) values of it.</p>
<div class="fragment"><div class="line">values0 = m_values(map);     <span class="comment">//returns the first values</span></div>
<div class="line">values0 = m_values(map, 0);  <span class="comment">//dito</span></div>
<div class="line">values1 = m_values(map, 1);  <span class="comment">//returns the second values</span></div>
<div class="line">  etc</div>
</div><!-- fragment --><h2>HOW CAN I DETERMINE THE SIZE OF A MAPPING?</h2>
<p>Because a mapping is a kind of rectangle it has two sizes: a length and a width. There are three different efuns to query these values. The first two are the efuns sizeof(), which returns the amount of key-value associations (the length of a mapping), and widthof(), which returns the number of values per key (the width). The third is the efun get_type_info(). get_type_info() is meant to be a function to identify a datatype. Its return value is an array of two numerical values. The first specifies the datatype of the argument and the second is a datatype dependend value. In the case of a mapping the first value is T_MAPPING (which is a value defined in &lt;lpctypes.h&gt;) and the second the amount of values per key (a.k.a. columns or the width of the mapping - actually it would be correct to say that the width of a mapping is the amount of columns plus one for the keys but this is uncommon).</p>
<h2>WHAT IS THE BEST METHOD TO ITERATE OVER A MAPPING?</h2>
<p>First of all the main purpose of a mapping is not meant to be a set of data to iterate over. Afterall the keys in a mapping have no specific but a random order (at least on the LPC side). But still it is possible and sometimes even neccesary to do so.</p>
<p>If all key-value associations should be processed then one should use walk_mapping(). If all keys of a mapping should be processed to create a new mapping being a subset of the given one, then filter_mapping() should be used. If all keys are going to be processed and to create a new mapping with the same set of keys as the given mapping, then one would use map_mapping(). But in the case of an iteration that should/can stop even if not all data is processed it is probably wise to iterate over the mapping by first querying for the keys and then to iterate over them with a for() or a while() loop and querying the values by 'hand'.</p>
<p>The efun walk_mapping() gets a mapping as first argument and the name of a function as second one. All the following arguments are treated as extras which will be passed to the function specified with the 2nd argument. Instead of a string for the name of a function a closure can be used, too. Nothing will be returned:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">walk_mapping(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">void func(mixed key, mixed value0, ..., mixed valuen, mixed xarg0,</div>
<div class="line">  ..., mixed xargn) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> func() will be called for all key-value associations and gets as first argument the key. The next arguments are the values behind the key and are passed as references. The rest of the passed arguments are those specified as extras. Because the values are passed as references (opposed to copies) it is possible to modify them from inside func() by simply assigning new value to the variables &lt;value0&gt;, ..., &lt;valuen&gt;.</p>
<p>The efun filter_mapping() calls a function for each key in a mapping and creates a new mapping which only contains key-value associations for which the called function returned true (not equal 0 that is). The first argument is the mapping to iterate over and the second is a function name given as a string or a closure:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">submap = filter_mapping(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int func(mixed key, mixed xarg0, ..., mixed xargn) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> func() gets as first argument the key and the others are those passed as extras to filter_mapping().</p>
<p>The efun map_mapping() gets a mapping as first argument and a string as a function name (or again a closure) as second argument. Any additional arguments are again used as extras that will be passed to the iteration function. This efun returns a new mapping with the same keys as the given one. The values returned by the function that is invoked for each key will be used as the associated data behind each key of the new mapping:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">newmap = map_mapping(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">mixed func(mixed key, mixed xarg0, ..., mixed xargn) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> func() gets as first argument the key and the others are those passed as extras to map_mapping().</p>
<p>Because a function can only return a single value (even when it is an array) it restricts the use of map_mapping() to only allow creation of mappings with a single value per key.</p>
<h2>IS IT POSSIBLE TO JOIN/INTERSECT/CUT MAPPINGS WITH ANOTHER?</h2>
<p>Joining mappings is only possible, if they have the same width (amount of values per key). One can use the + and += operator:</p>
<div class="fragment"><div class="line">map = map1 + map2 + ... + mapn;</div>
<div class="line">map += map1 + map2 + ... + mapn;</div>
</div><!-- fragment --><p> Intersection of two mappings is only possible by using filter_mapping(). There is no efun or operator which features this. The 'easiest' way may be the following function:</p>
<div class="fragment"><div class="line">mapping intersect_mapping(mapping map1, mapping map2) {</div>
<div class="line">  closure cl;</div>
<div class="line"></div>
<div class="line">  cl = lambda(({ <span class="stringliteral">&#39;key }), ({ #&#39;</span>member, map2, <span class="stringliteral">&#39;key }));</span></div>
<div class="line"><span class="stringliteral">  return filter_mapping(map1, cl, map2);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> This function returns a new mapping which consists of all key-value associations of &lt;map1&gt; for which an equal key could be found in &lt;map2&gt;. This function uses a closure which returns 0 or 1 depending on wether a key from &lt;map1&gt; is contained in &lt;map2&gt; or not.</p>
<p>Cutting out all key-value associations of a mapping for which a key could be found in another mapping can be done by using the - and -= operator:</p>
<div class="fragment"><div class="line">mapping cut_mapping(mapping map1, mapping map2) {</div>
<div class="line">  <span class="keywordflow">return</span> map1 - mkmapping(m_indices(map2));</div>
<div class="line">}</div>
</div><!-- fragment --><p> Because a maping can only be substracted by one without any values we first have to create such by using m_indices() and mkmapping().</p>
<h2>WHAT ARE THOSE MAPPINGS WITHOUT ANY VALUES (BESIDES KEYS) GOOD FOR?</h2>
<p>Because the way how the driver searches for a key in a mapping is rather fast, those mappings can be used as a set of elements with a fast method for testing if an element is contained in the set. This technique is called hashing (further explanation would lead too far) which is faster than searching for values in array (which is done in a linear fashion).</p>
<p>Another (maybe more pratical) use of these mappings are to create a array of unique values out of an array with several equal values:</p>
<div class="fragment"><div class="line">uniques = m_indices(mkmapping(array));</div>
</div><!-- fragment --><p> mkmapping() uses &lt;array&gt; to create a mapping without any values but just keys. And because a mapping can only have unique keys all multiple values in &lt;array&gt; are taken as one. The call of m_indices() then returns an array of these unique keys. Actually we only make use of those mappings temporarily.</p>
<h2>HOW CAN I CONVERT AN ALIST INTO A MAPPING AND VICE VERSA?</h2>
<p>There are no special efuns which handle such conversions. But it can be done by the following functions:</p>
<div class="fragment"><div class="line">mapping alist_to_mapping(mixed *alist) {</div>
<div class="line">  <span class="keywordflow">return</span> apply(#<span class="stringliteral">&#39;mkmapping, alist);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> The efun apply() takes a closure and an array of values and passes each element of the array as an argument to the closure. Because an alist consists of an array of arrays with the first beeing the list of keys and the others the values associated to each key passing them as arguments to the efun closure #'mkmapping via apply() causes the creation of a mapping out of an alist.</p>
<div class="fragment"><div class="line">mixed *mapping_to_alist(mapping map) {</div>
<div class="line">  mixed *alist;</div>
<div class="line">  symbol *vars;</div>
<div class="line">  <span class="keywordtype">string</span> var;</div>
<div class="line">  closure cl;</div>
<div class="line">  <span class="keywordtype">int</span> width;</div>
<div class="line"></div>
<div class="line">  width = get_type_info(map)[1];</div>
<div class="line">  alist = allocate(width + 1);</div>
<div class="line">  vars  = allocate(width + 2);</div>
<div class="line">  <span class="keywordflow">for</span> (var = <span class="stringliteral">&quot;a&quot;</span>; width; var[0]++, width--) {</div>
<div class="line">    alist[width] = ({});</div>
<div class="line">    vars[width]  = quote(var);</div>
<div class="line">  }</div>
<div class="line">  alist[0] = ({});</div>
<div class="line">  vars[0]  = <span class="stringliteral">&#39;key;</span></div>
<div class="line"><span class="stringliteral">  vars[&lt;1] = &#39;</span>alist;</div>
<div class="line">  cl = lambda(vars, ({ #<span class="stringliteral">&#39;=, &#39;</span>alist, ({ #<span class="stringliteral">&#39;insert_alist }) + vars }));</span></div>
<div class="line"><span class="stringliteral">  walk_mapping(map, cl, &amp;alist);</span></div>
<div class="line"><span class="stringliteral">  return alist;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> This function is a bit more complicated than the other and detailed description would lead too far of the topic. This function has one restriction: it can only turn a mappings with up to 26 values per key into an alist. But this should be sufficient for probably all applications which use mappings.</p>
<p>And Hyps further comment on this:</p>
<p>The function mapping_to_alist() is also not that clever because insert_alist() allways creates a new alist. A second (optional) argument to m_values() to specify the value column would be better. Besides this, the conversion of a mapping into an alist could be done by to_array().</p>
<h2>DIRTY MAPPINGS</h2>
<p>'Dirty mappings' are nothing the LPC programmer directly is involved with, however, as it relates to the way mappings are implemented internally by the gamedriver. However, as this term shows up in various driver statistics, it is explained here.</p>
<p>There are two fundamental approaches to implement mappings:</p>
<ol type="1">
<li>Store all data entries in an array-like structure, in sorted order.</li>
<li>Store all data in a hashtable, each entry allocaed separately. Method 1 is very space efficient, as it doesn't need much overhead per entry; however, insertions and deletions of entries are relatively slow as all other entries need to be moved. Method 2 is very fast as nothing needs to be moved in memory, however it has a large overhead.</li>
</ol>
<p>The gamedriver uses a hybrid method: at the basis is a mapping implementation based on arrays. However the driver uses a hash table in addition to handle all the ongoing insertions and deletions. Every once in a while, the contents of the hash table are sorted into the base array, reasoning that any entry surviving for longer time in the hash table is worth keeping in a more space-efficient manner. 'Dirty' mappings are such mappings with both an array and a hash part, 'clean' mappings are those with just an array part.</p>
<h2>LAST UPDATE</h2>
<p>Mon, 15 Mar 1999</p>
<dl class="section user"><dt>History:</dt><dd><div class="fragment"><div class="line">changed (3.2.9/3.3.208) -- added ([:width ]) notation</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="driver_LPC_closures.html">closures</a>, <a class="el" href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1" title="The first form returns a mapping with indices from &#39;arr1&#39; and values from &#39;arr2&#39;... ">efun::mkmapping()</a>, <a class="el" href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216">efun::walk_mapping()</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="driver_todo.html">todo</a></li><li class="navelem"><a class="el" href="driver_LPC_lpc.html">lpc</a></li>
    <li class="footer">Generated on Sat Jun 11 2016 14:24:11 for Tsunami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
