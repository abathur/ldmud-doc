<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LDMud: syntax/mappings.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LDMud
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mappings_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">syntax/mappings.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mappings {#driver_syntax_mappings}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;==================================</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;mappings {#driver_syntax_mappings}</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;==================================</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; Guide to A step-by-step introduction to mappings #</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;A mapping is a datatype which allows to store data associated to a key. In other languages they are also known as <span class="stringliteral">&#39;dictionaries&#39;</span> or <span class="stringliteral">&#39;alists&#39;</span>. There are also alists in LPC but they are not a separate datatype but are implemented on top of arrays. Alists are the predecessors of mappings. The keys and the values can be of any type. But most common datatypes <span class="keywordflow">for</span> keys are strings, integers and objects. Others like arrays, mappings or closures aren<span class="stringliteral">&#39;t a good choice because comparision between i.e. arrays often returns false even if they equal in content. This is because the driver compares i.e. two arrays by their internal pointers and not by their content. The reason for this is simple: speed.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="stringliteral">Mappings are allways treated as references when passing them to functions. This means when you pass a mapping to another object and this object modifies the mapping the modification will take place in a global scope - visible to all objects holding this mapping in a variable.</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="stringliteral"># What are mappings good for? #</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="stringliteral">The term &#39;</span>dictionary<span class="stringliteral">&#39; probably describes the use of a mapping best. Opposed to arrays mappings don&#39;</span>t have a specific order. They provide a mechanism to create a set of associations between values. Such an association consists of a unique key and data that is identified by the key. Think of a dictionary where you have a word and a definition of it. You use the word to lookup its definition.</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Mappings can be used i.e. to hold aliases <span class="keywordflow">for</span> commands. The key would then be the name of the alias and the data the command(s) behind an alias. Or they can be used for the exits of a room. The keys would be the directions where one can go to and the associated data would be the file names of the rooms. But mappings can also be used as a kind of a sparse array. A sparse array is an array where most of the elements aren&#39;t used (occupied by 0). I.e. if you want to store values at the position 0, 13 and 37642 of an array you would have to create an array with a size of at least 37643. This costs a lot of memory so a mapping would be more useful because you would then use the numbers 0, 13 and 37642 as a key and not as an index to a position (actually the keys of a mapping are sometimes called indices but this is just because the way data is accessed in a mapping is similar to arrays: by the [] operator). This also allows to query all occupied positions of a sparse array by querying for all the keys of the mapping opposed to an array where you have to iterate over all elements.</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor"># How do I create a mapping? #</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;There are several ways to <span class="keywordflow">do</span> so. The most convenient is the following:</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;mapping map;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;map = ([</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  key0: value00; ...; value0n,</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  ... : ...    ; ...; ...    ,</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  keyn: valuen0; ...; valuenn</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;]);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;~~~</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;As you can see, a key may have more than one value assigned. But the amount of values per key must always be equal. It is even possible to have mappings without any values!</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;Another method is to use <a class="code" href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1">efun::mkmapping</a>(). This <a class="code" href="classefun.html">efun</a> gets two arguments with the first beeing an array of keys and the following beeing arrays of values:</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;mapping map;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;map = mkmapping (</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  ({ key0   , ..., keyn    }),</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  ({ value00, ..., value0n }),</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  ({ ...    , ..., ...     }),</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  ({ valuen0, ..., valuenn })</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;~~~</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;If the <a class="code" href="classefun.html">efun</a> only gets one argument, then <span class="keyword">this</span> argument will be taken as an array of keys and a mapping without values will be returned.</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;An empty mapping can be created by <span class="keyword">using</span> the above described methods by simply ommitting the keys and values:</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;mapping map;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;map = ([]);</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;~~~</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;or:</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;map = mkmapping(({}), ({}));</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;~~~</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;Or by <span class="keyword">using</span> the <a class="code" href="classefun.html#a9ae4e2d42d75ad4aa7f4e100c60c3d41">efun::m_allocate</a>(). This <a class="code" href="classefun.html">efun</a> gets as first argument the amount of keys which will be added soon and an optional second argument specifying the width of the mapping:</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;map = m_allocate(n, width);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;~~~</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;The value &lt;em&gt;n&lt;/em&gt; may be a bit confusing since mappings shrink and grow dynamically. This value just tells the driver how <span class="stringliteral">&#39;long&#39;</span> <span class="keyword">this</span> mapping is going to be so proper memory allocations will be performed to reduce the overhead of memory reallocation. I.e. <span class="keywordflow">if</span> you want to read in a file and store the read data in a mapping you probably know the amount of keys. So you allocate a mapping with <span class="keyword">this</span> <a class="code" href="classefun.html">efun</a> and tell the driver how much memory should be allocated by specifing a proper &lt;em&gt;n&lt;/em&gt; value. Thus causing a speedup when adding the read data to the mapping afterwards. The &lt;em&gt;width&lt;/em&gt; just specifies how many values per key <span class="keyword">this</span> mapping is going to have. If no width is given, 1 will be taken as <span class="keywordflow">default</span>.</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;An empty mapping created with `([])` will always have a width of 1. To create empty mappings with other widths, write it as:</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;map = ([:width ]);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;~~~</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;&lt;em&gt;width&lt;/em&gt; can be any expression returning an integer value (including <span class="keyword">function</span> calls), and in fact <span class="keyword">this</span> notation is just a fancy way of writing:</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;map = m_allocate(0, width);</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;~~~</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="preprocessor"># How can I modify the data of a mapping? #</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;Adding a <span class="keyword">new</span> key is similiar to modifying the associated data of an existing key:</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;map += ([ key: value0; ...; valuen ]);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;~~~</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;Or in <span class="keywordflow">case</span> only a single value should be modified:</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;map[key, n] = valuen;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;~~~</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;If &lt;em&gt;n&lt;/em&gt; is out of range or if &lt;em&gt;key&lt;/em&gt; doesn<span class="stringliteral">&#39;t exists and &lt;em&gt;n&lt;/em&gt; is greater than 0 an &quot;Illegal index&quot; error will be reported. If &lt;em&gt;n&lt;/em&gt; is equal to 0 or the mapping only has a single value per key one can abbreviate it with:</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="stringliteral">map[key] = value;</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="stringliteral">If there is no &lt;em&gt;key&lt;/em&gt; (and &lt;em&gt;n&lt;/em&gt; is equal to 0 or not specified at all) a new one will be added automatically.</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="stringliteral">Deletion of a key is done with the @ref driver_syntax_operators &quot;-=&quot; or efun::m_delete(). A mapping can only be substracted by one without any values:</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="stringliteral">map -= ([ key ]);</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="stringliteral">or:</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="stringliteral">map -= ([ key0, ..., keyn ]);</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="stringliteral">The efun takes a mapping as first and a key as second argument:</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="stringliteral">m_delete(map, key);</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="stringliteral">efun::m_delete() returns the mapping but because mappings are handled as references there is no need of an assignment like:</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="stringliteral">map = m_delete(map, key);</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral"># How can I access the data stored in a mapping? #</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral">This can be done by:</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral">valuen = map[key, n];</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral">Or in case of a mapping with just one value per key:</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral">value0 = map[key];</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral">If there is no &lt;em&gt;key&lt;/em&gt; in the mapping and &lt;em&gt;n&lt;/em&gt; is 0 or not specified at all (which is the same) a 0 will be returned or if &lt;em&gt;n&lt;/em&gt; is greater than 0 an &quot;Illegal index&quot; error will be reported.</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="stringliteral"># How can I test for the existance of a key? #</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="stringliteral">A return value of 0 is sufficient for most applications but sometimes the ambiguity between an existing value of 0 and a nonexisting key can lead to a problem. Therefore one can use efun::member() or efun::m_contains() to check if there actually is a key in the mapping:</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral">if (member(map, key)) {</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral">  ...</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="stringliteral">or:</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="stringliteral">if (mapping_contains(&amp;value0, ..., &amp;valuen, map, key)) {</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="stringliteral">  ...</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="stringliteral">This also shows how one can retrieve all values associated to a key from a mapping in a single step. The &#39;</span>&amp;<span class="stringliteral">&#39; is the reference operator which is neccesary to let the efun store the values in the variables.</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="stringliteral">In case of mappings with no values, the efun::member() and efun::m_contains() are equal in their behaviour and their way of calling because efun::m_contains() won&#39;</span>t <span class="keyword">get</span> any reference variables to store the values in (because there aren<span class="stringliteral">&#39;t any).</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="stringliteral">Also normally efun::member() is known to return the postion of an element in a list (i.e. a character in a string or data in an array) and if an element couldn&#39;</span>t be found -1 is returned. But in the <span class="keywordflow">case</span> of mappings there are no such things as order and postion. So <a class="code" href="classefun.html#adf2253b4467a0eb544f67ff5777d2fa2">efun::member</a>() only returns 0 or 1.</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;# How can I copy a mapping? #</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;A mapping can be copied with the + <span class="keyword">operator</span> or by <a class="code" href="classefun.html#aaa7f17ec1022dac35a818c575fef969a">efun::deep_copy</a>():</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;newmap = ([]) + map;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;~~~</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;or:</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;newmap = copy_mapping(map);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;~~~</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;A mapping should only be copied when it is neccesary to <span class="keyword">get</span> an own copy of it that must not be shared by other objects.</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;# How can I <span class="keyword">get</span> all keys of a mapping? #</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<a class="code" href="classefun.html#a706faae97294c390a3cd88cb080d509a">efun::m_indices</a>() gets a mapping as argument and returns an array holding all keys defined in this mapping:</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;keys = m_indices(map);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;~~~</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="preprocessor"># How can I get all the values of a mapping? #</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<a class="code" href="classefun.html#a2bed0d3fd8a81f635ddf28b8f539d4c1">efun::m_values</a>() gets a mapping as argument and returns an array holding all the first (second, ...) values of it:</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;values0 = m_values(map);     <span class="comment">//returns the first values</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;values0 = m_values(map, 0);  <span class="comment">//dito</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;values1 = m_values(map, 1);  <span class="comment">//returns the second values</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  etc</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;~~~</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="preprocessor"># How can I determine the size of a mapping? #</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;Because a mapping is a kind of rectangle it has two sizes: a length and a width. There are three different efuns to query these values. The first two are <a class="code" href="classefun.html#a1b26f2ff266e671649fc060bea19b228">efun::sizeof</a>(), which returns the amount of key-value associations (the length of a mapping), and <a class="code" href="classefun.html#abd02e530c8ad0620b241d0933fdc91da">efun::widthof</a>(), which returns the number of values per key (the width). The third is the <a class="code" href="classefun.html">efun</a> <a class="code" href="classefun.html#ac251ce3e185e6ef6e265806ba711e871">efun::get_type_info</a>(). <a class="code" href="classefun.html#ac251ce3e185e6ef6e265806ba711e871">efun::get_type_info</a>() is meant to be a function to identify a datatype. Its return value is an array of two numerical values. The first specifies the datatype of the argument and the second is a datatype dependend value. In the case of a mapping the first value is `T_MAPPING` (which is a value defined in &lt;lpctypes.h&gt;) and the second the amount of values per key (a.k.a. columns or the width of the mapping - actually it would be correct to say that the width of a mapping is the amount of columns plus one for the keys but this is uncommon).</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="preprocessor"># What is the best method to iterate over a mapping? #</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;First of all the main purpose of a mapping is not meant to be a set of data to iterate over. Afterall the keys in a mapping have no specific but a random order (at least on the LPC side). But still it is possible and sometimes even neccesary to <span class="keywordflow">do</span> so.</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;If all key-value associations should be processed then one should use <a class="code" href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216">efun::walk_mapping</a>(). If all keys of a mapping should be processed to create a <span class="keyword">new</span> mapping being a subset of the given one, then <a class="code" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8">efun::filter_indices</a>() should be used. If all keys are going to be processed and to create a new mapping with the same set of keys as the given mapping, then one would use <a class="code" href="classefun.html">efun</a>::map_indices(). But in the case of an iteration that should/can stop even if not all data is processed it is probably wise to iterate over the mapping by first querying for the keys and then to iterate over them with a @ref driver_syntax_for &quot;for&quot; or a @ref driver_syntax_while &quot;while&quot; loop and querying the values by &#39;hand&#39;.</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;The <a class="code" href="classefun.html">efun</a>::walk_mapping() gets a mapping as first argument and the name of a function as second one. All the following arguments are treated as extras which will be passed to the function specified with the 2nd argument. Instead of a <span class="keywordtype">string</span> for the name of a function a closure can be used, too. Nothing will be returned:</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;...</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<a class="code" href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216">walk_mapping</a>(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;...</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;void func(mixed key, mixed value0, ..., mixed valuen, mixed xarg0,</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  ..., mixed xargn) {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  ...</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;~~~</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;`func()` will be called <span class="keywordflow">for</span> all key-value associations and gets as first argument the key. The next arguments are the values behind the key and are passed as references. The rest of the passed arguments are those specified as extras. Because the values are passed as references (opposed to copies) it is possible to modify them from inside `func()` by simply assigning <span class="keyword">new</span> value to the variables &lt;em&gt;value0&lt;/em&gt;, ..., &lt;em&gt;valuen&lt;/em&gt;.</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;The <a class="code" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8">efun::filter_indices</a>() calls a function for each key in a mapping and creates a new mapping which only contains key-value associations for which the called function returned true (not equal 0 that is). The first argument is the mapping to iterate over and the second is a function name given as a <span class="keywordtype">string</span> or a closure:</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;...</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;submap = filter_indices(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;...</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;int func(mixed key, mixed xarg0, ..., mixed xargn) {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  ...</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;}</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;~~~</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;`func()` gets as first argument the key and the others are those passed as extras to <a class="code" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8">efun::filter_indices</a>().</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;efun::map_indices() gets a mapping as first argument and a <span class="keywordtype">string</span> as a <span class="keyword">function</span> name (or again a closure) as second argument. Any additional arguments are again used as extras that will be passed to the iteration <span class="keyword">function</span>. This <a class="code" href="classefun.html">efun</a> returns a <span class="keyword">new</span> mapping with the same keys as the given one. The values returned by the <span class="keyword">function</span> that is invoked <span class="keywordflow">for each</span> key will be used as the associated data behind each key of the <span class="keyword">new</span> mapping:</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;...</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;newmap = map_indices(map, <span class="stringliteral">&quot;func&quot;</span>, xarg0, ..., xargn);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;...</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;mixed func(mixed key, mixed xarg0, ..., mixed xargn) {</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  ...</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;}</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;~~~</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;`func()` gets as first argument the key and the others are those passed as extras to <a class="code" href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7">efun::map_indices</a>().</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;Because a <span class="keyword">function</span> can only <span class="keywordflow">return</span> a single value (even when it is an array) it restricts the use of <a class="code" href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7">efun::map_indices</a>() to only allow creation of mappings with a single value per key.</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="preprocessor"># Is it possible to join/intersect/cut mappings with another? #</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;Joining mappings is only possible, <span class="keywordflow">if</span> they have the same width (amount of values per key). One can use the + and += <span class="keyword">operator</span>:</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;map = map1 + map2 + ... + mapn;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;map += map1 + map2 + ... + mapn;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;~~~</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;Intersection of two mappings is only possible by <span class="keyword">using</span> <a class="code" href="classefun.html#a499fe72696a3dc34028138aa8f465ac8">efun::filter_indices</a>(). There is no <a class="code" href="classefun.html">efun</a> or <span class="keyword">operator</span> which features this. The <span class="stringliteral">&#39;easiest&#39;</span> way may be the following <span class="keyword">function</span>:</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;mapping intersect_mapping(mapping map1, mapping map2) {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  closure cl;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  cl = lambda(({ <span class="stringliteral">&#39;key }), ({ #&#39;</span>member, map2, <span class="stringliteral">&#39;key }));</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="stringliteral">  return filter_indices(map1, cl, map2);</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="stringliteral">This function returns a new mapping which consists of all key-value associations of &lt;em&gt;map1&lt;/em&gt; for which an equal key could be found in &lt;em&gt;map2&lt;/em&gt;. This function uses a closure which returns 0 or 1 depending on wether a key from &lt;em&gt;map1&lt;/em&gt; is contained in &lt;em&gt;map2&lt;/em&gt; or not.</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="stringliteral">Cutting out all key-value associations of a mapping for which a key could be found in another mapping can be done by using @ref driver_syntax_operators &quot;-&quot; and @ref driver_syntax_operators &quot;-=&quot;:</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="stringliteral">mapping cut_mapping(mapping map1, mapping map2) {</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="stringliteral">  return map1 - mkmapping(m_indices(map2));</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="stringliteral">Because a maping can only be substracted by one without any values we first have to create such by using efun::m_indices() and efun::mkmapping().</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="stringliteral"># What are those mappings without any values (besides keys) good for? #</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="stringliteral">Because the way how the driver searches for a key in a mapping is rather fast, those mappings can be used as a set of elements with a fast method for testing if an element is contained in the set. This technique is called hashing (further explanation would lead too far) which is faster than searching for values in array (which is done in a linear fashion).</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="stringliteral">Another (maybe more pratical) use of these mappings are to create a array of unique values out of an array with several equal values:</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="stringliteral">uniques = m_indices(mkmapping(array));</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="stringliteral">efun::mkmapping() uses &lt;em&gt;array&lt;/em&gt; to create a mapping without any values but just keys. And because a mapping can only have unique keys all multiple values in &lt;em&gt;array&lt;/em&gt; are taken as one. The call of efun::m_indices() then returns an array of these unique keys. Actually we only make use of those mappings temporarily.</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="stringliteral"># How can I convert an alist into a mapping and vice versa? #</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="stringliteral">There are no special efuns which handle such conversions. But it can be done by the following functions:</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="stringliteral">~~~{.c}</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral">mapping alist_to_mapping(mixed *alist) {</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="stringliteral">  return apply(#&#39;</span>mkmapping, alist);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;}</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;~~~<a class="code" href="classefun.html"></a></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<a class="code" href="classefun.html">efun</a>::apply() takes a closure and an array of values and passes each element of the array as an argument to the closure. Because an alist consists of an array of arrays with the first beeing the list of keys and the others the values associated to each key passing them as arguments to the <a class="code" href="classefun.html">efun</a> closure `<span class="preprocessor">#&#39;mkmapping` via efun::apply() causes the creation of a mapping out of an alist.</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;~~~{.c}</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;mixed *mapping_to_alist(mapping map) {</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  mixed *alist;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  symbol *vars;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  <span class="keywordtype">string</span> var;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  closure cl;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;  <span class="keywordtype">int</span> width;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  width = get_type_info(map)[1];</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  alist = allocate(width + 1);</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  vars  = allocate(width + 2);</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="keywordflow">for</span> (var = <span class="stringliteral">&quot;a&quot;</span>; width; var[0]++, width--) {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    alist[width] = ({});</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    vars[width]  = quote(var);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  }</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  alist[0] = ({});</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  vars[0]  = <span class="stringliteral">&#39;key;</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="stringliteral">  vars[&lt;1] = &#39;</span>alist;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  cl = lambda(vars, ({ #<span class="stringliteral">&#39;=, &#39;</span>alist, ({ #<span class="stringliteral">&#39;insert_alist }) + vars }));</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral">  walk_mapping(map, cl, &amp;alist);</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral">  return alist;</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="stringliteral">This function is a bit more complicated than the other and detailed description would lead too far of the topic. This function has one restriction: it can only turn a mappings with up to 26 values per key into an alist. But this should be sufficient for probably all applications which use mappings.</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="stringliteral">And Hyps further comment on this:</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral">The function `mapping_to_alist()` is also not that clever because `insert_alist()` allways creates a new alist. A second (optional) argument to efun::m_values() to specify the value column would be better. Besides this, the conversion of a mapping into an alist could be done by efun::to_array().</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="stringliteral"># Dirty Mappings #</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="stringliteral">&#39;</span>Dirty mappings<span class="stringliteral">&#39; are nothing the LPC programmer directly is involved with, however, as it relates to the way mappings are implemented internally by the gamedriver. However, as this term shows up in various driver statistics, it is explained here.</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="stringliteral">There are two fundamental approaches to implement mappings:</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="stringliteral">1. Store all data entries in an array-like structure, in sorted order.</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="stringliteral">2. Store all data in a hashtable, each entry allocaed separately.</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="stringliteral">Method 1 is very space efficient, as it doesn&#39;</span>t need much overhead per entry; however, insertions and deletions of entries are relatively slow as all other entries need to be moved. Method 2 is very fast as nothing needs to be moved in memory, however it has a large overhead.</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;The gamedriver uses a hybrid method: at the basis is a mapping implementation based on arrays. However the driver uses a hash table in addition to handle all the ongoing insertions and deletions. Every once in a <span class="keywordflow">while</span>, the contents of the hash table are sorted into the base array, reasoning that any entry surviving <span class="keywordflow">for</span> longer time in the hash table is worth keeping in a more space-efficient manner. <span class="stringliteral">&#39;Dirty&#39;</span> mappings are such mappings with both an array and a hash part, <span class="stringliteral">&#39;clean&#39;</span> mappings are those with just an array part.</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;- changed (3.2.9/3.3.208) -- added ([:width ]) notation</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;Last Update</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;Mon, 15 Mar 1999</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;`alists`, @ref driver_syntax_closures &quot;closure&quot;, @ref driver_syntax_structs &quot;struct&quot;, <a class="code" href="classefun.html">efun</a>::mkmapping(), <a class="code" href="classefun.html">efun</a>::walk_mapping()</div>
<div class="ttc" id="classefun_html_a6cd46ef2f89a1b7f5a4ec5f4cb7beee1"><div class="ttname"><a href="classefun.html#a6cd46ef2f89a1b7f5a4ec5f4cb7beee1">efun.mkmapping</a></div><div class="ttdeci">mapping mkmapping(struct st)</div><div class="ttdoc">The first form returns a mapping with indices from arr1 and values from arr2... </div></div>
<div class="ttc" id="classefun_html_a1b26f2ff266e671649fc060bea19b228"><div class="ttname"><a href="classefun.html#a1b26f2ff266e671649fc060bea19b228">efun.sizeof</a></div><div class="ttdeci">int sizeof(struct xxx val)</div><div class="ttdoc">Returns the number of elements of an array or struct, the number of characters in a string...</div></div>
<div class="ttc" id="classefun_html_a499fe72696a3dc34028138aa8f465ac8"><div class="ttname"><a href="classefun.html#a499fe72696a3dc34028138aa8f465ac8">efun.filter_indices</a></div><div class="ttdeci">mapping filter_indices(mapping, closure cl,...)</div><div class="ttdoc">ob-&gt;func() is called resp. </div></div>
<div class="ttc" id="classefun_html_adf2253b4467a0eb544f67ff5777d2fa2"><div class="ttname"><a href="classefun.html#adf2253b4467a0eb544f67ff5777d2fa2">efun.member</a></div><div class="ttdeci">int member(mapping m, mixed key)</div><div class="ttdoc">For arrays and strings, returns the index of the first occurance of second arg in the first arg...</div></div>
<div class="ttc" id="classefun_html_a706faae97294c390a3cd88cb080d509a"><div class="ttname"><a href="classefun.html#a706faae97294c390a3cd88cb080d509a">efun.m_indices</a></div><div class="ttdeci">mixed * m_indices(mapping map)</div><div class="ttdoc">Returns an array containing the indices of mapping &#39;map&#39;. </div></div>
<div class="ttc" id="classefun_html_a82aceeaafc69a2ea441ad52f4657e216"><div class="ttname"><a href="classefun.html#a82aceeaafc69a2ea441ad52f4657e216">efun.walk_mapping</a></div><div class="ttdeci">void walk_mapping(mapping m, closure cl, mixed extra,...)</div><div class="ttdoc">Calls ob-&gt;func(key, value1, ..., valueN, extra,...) resp. </div></div>
<div class="ttc" id="classefun_html_abd02e530c8ad0620b241d0933fdc91da"><div class="ttname"><a href="classefun.html#abd02e530c8ad0620b241d0933fdc91da">efun.widthof</a></div><div class="ttdeci">int widthof(mapping map)</div><div class="ttdoc">Returns the number of values per key of mapping map. </div></div>
<div class="ttc" id="classefun_html_a2bed0d3fd8a81f635ddf28b8f539d4c1"><div class="ttname"><a href="classefun.html#a2bed0d3fd8a81f635ddf28b8f539d4c1">efun.m_values</a></div><div class="ttdeci">mixed * m_values(mapping map, int index)</div><div class="ttdoc">Returns an array with the values of mapping map. </div></div>
<div class="ttc" id="classefun_html_a9ae4e2d42d75ad4aa7f4e100c60c3d41"><div class="ttname"><a href="classefun.html#a9ae4e2d42d75ad4aa7f4e100c60c3d41">efun.m_allocate</a></div><div class="ttdeci">mapping m_allocate(int size, int width)</div><div class="ttdoc">Reserve memory for a mapping. </div></div>
<div class="ttc" id="classefun_html_ae2e945661de01cfb0e12608d8851e8e7"><div class="ttname"><a href="classefun.html#ae2e945661de01cfb0e12608d8851e8e7">efun.map_indices</a></div><div class="ttdeci">mapping map_indices(mapping m, closure cl,...)</div><div class="ttdoc">ob-&gt;func() is called resp. </div></div>
<div class="ttc" id="classefun_html"><div class="ttname"><a href="classefun.html">efun</a></div><div class="ttdef"><b>Definition:</b> <a href="abs_8c_source.html#l00001">abs.c:1</a></div></div>
<div class="ttc" id="classefun_html_aaa7f17ec1022dac35a818c575fef969a"><div class="ttname"><a href="classefun.html#aaa7f17ec1022dac35a818c575fef969a">efun.deep_copy</a></div><div class="ttdeci">mixed deep_copy(mixed value)</div><div class="ttdoc">Create a deep copy of value and return it. </div></div>
<div class="ttc" id="classefun_html_ac251ce3e185e6ef6e265806ba711e871"><div class="ttname"><a href="classefun.html#ac251ce3e185e6ef6e265806ba711e871">efun.get_type_info</a></div><div class="ttdeci">mixed get_type_info(mixed value, int flag)</div><div class="ttdoc">Returns info about the type of value, as controlled by the flag. </div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mappings.md</b></li>
    <li class="footer">Generated on Thu Mar 9 2017 17:45:23 for LDMud by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
