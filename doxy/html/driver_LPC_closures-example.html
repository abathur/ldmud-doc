<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Tsunami: closures-example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tsunami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('driver_LPC_closures-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">closures-example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document contains small examples of the usage of (lambda-)closures. For technical details see the <a class="el" href="driver_LPC_closures.html">closures</a> doc. For hints when to use which type of closure, see the end of this doc.</p>
<p>Many Muds use 'details' to add more flavour. 'Details' are items which can be looked at, but are not implemented as own objects, but instead simulated by the environment. Lets assume that the function</p>
<div class="fragment"><div class="line">AddDetail(<span class="keywordtype">string</span> keyword, <span class="keywordtype">string</span>|closure desc)</div>
</div><!-- fragment --><p> adds the detail 'keyword' to the room, which, when look at, returns the string 'desc' resp. the result of the execution of closure 'desc' as the detail description to the player.</p>
<p>Now imagine that one wants to equip a room with magic runes, which read as 'Hello &lt;playername&gt;!n" when looked at. Obviously</p>
<div class="fragment"><div class="line">AddDetail(<span class="stringliteral">&quot;runes&quot;</span>, sprintf(<span class="stringliteral">&quot;Hello %s!\n&quot;</span>, this_player()-&gt;QueryName()));</div>
</div><!-- fragment --><p> is not sufficient, as the 'this_player()' is executed to early and just once: for the player loading the room.</p>
<p>The solution is to use closures. First, the solution using lfun-closures:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span> <span class="keywordtype">string</span> _detail_runes () {</div>
<div class="line">  <span class="keywordflow">return</span> sprintf(<span class="stringliteral">&quot;Hello %s!\n&quot;</span>, this_player()-&gt;QueryName());</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">AddDetail(<span class="stringliteral">&quot;runes&quot;</span>, #<span class="stringliteral">&#39;_detail_runes);</span></div>
</div><!-- fragment --><p> or with an inline closure:</p>
<div class="fragment"><div class="line">AddDetail(</div>
<div class="line">  <span class="stringliteral">&quot;runes&quot;</span>,</div>
<div class="line">  (: sprintf(<span class="stringliteral">&quot;Hello %s!\n&quot;</span>, this_player()-&gt;QueryName()) :)</div>
<div class="line">);</div>
</div><!-- fragment --><p> Simple? Here is the same code, this time as lambda-closure:</p>
<div class="fragment"><div class="line">AddDetail(</div>
<div class="line">  <span class="stringliteral">&quot;runes&quot;</span>,</div>
<div class="line">  lambda(</div>
<div class="line">    0,</div>
<div class="line">    ({</div>
<div class="line"><span class="preprocessor">      #&#39;sprintf,</span></div>
<div class="line"><span class="preprocessor"></span>      <span class="stringliteral">&quot;Hello %s!\n&quot;</span>,</div>
<div class="line">      ({#<span class="stringliteral">&#39;call_other, ({#&#39;</span>this_player}), <span class="stringliteral">&quot;QueryName&quot;</span> })</div>
<div class="line">    })</div>
<div class="line">  )</div>
<div class="line">);</div>
</div><!-- fragment --><p> Why the extra ({ }) around '#'this_player'? #'this_player alone is just a symbol, symbolizing the efun this_player(), but call_other() needs an object as first argument. Therefore, the #'this_player has to be interpreted as function to evaluate, which is enforced by enclosing it in ({ }). The same reason also dictates the enclosing of the whole #'call_other expression into ({ }). Note also the missing #'return: it is not needed. The result of a lambda-closure is the last value computed.</p>
<p>Another example: Task is to reduce the HP of every living in a room by 10, unless the result would be negative. Selecting all livings in a room is simply:</p>
<div class="fragment"><div class="line">filter(all_inventory(room), #<span class="stringliteral">&#39;living)</span></div>
</div><!-- fragment --><p> The tricky part is to reduce the HP. Again, first the lfun-closure solution:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span> _reduce_hp (<span class="keywordtype">object</span> liv) {</div>
<div class="line">  <span class="keywordtype">int</span> hp;</div>
<div class="line">  hp = liv-&gt;QueryHP();</div>
<div class="line">  <span class="keywordflow">if</span> (hp &gt; 10){</div>
<div class="line">    liv-&gt;SetHP(hp-10);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">map( filter(all_inventory(room), #<span class="stringliteral">&#39;living), #&#39;</span>_reduce_hp)</div>
</div><!-- fragment --><p> or as an inline closure:</p>
<div class="fragment"><div class="line">map(</div>
<div class="line">  filter(all_inventory(room), #<span class="stringliteral">&#39;living),</span></div>
<div class="line"><span class="stringliteral">  (:</span></div>
<div class="line"><span class="stringliteral">    int hp;</span></div>
<div class="line"><span class="stringliteral">    hp = liv-&gt;QueryHP();</span></div>
<div class="line"><span class="stringliteral">    if (hp &gt; 10){</span></div>
<div class="line"><span class="stringliteral">      liv-&gt;SetHP(hp - 10);</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  :)</span></div>
<div class="line"><span class="stringliteral">);</span></div>
</div><!-- fragment --><p> Both filter() and map() pass the actual array item being filtered/mapped as first argument to the closure.</p>
<p>Now, the lambda-closure solution:</p>
<div class="fragment"><div class="line">map(</div>
<div class="line">  filter(all_inventory(room), #<span class="stringliteral">&#39;living),</span></div>
<div class="line"><span class="stringliteral">  lambda(</span></div>
<div class="line"><span class="stringliteral">    ({ &#39;</span>liv }),</div>
<div class="line">    ({</div>
<div class="line"><span class="preprocessor">      #&#39;, , // not obvious if this is one arg or two?</span></div>
<div class="line"><span class="preprocessor"></span>      ({ #<span class="stringliteral">&#39;=, &#39;</span>hp, ({#<span class="stringliteral">&#39;call_other, &#39;</span>liv, <span class="stringliteral">&quot;QueryHP&quot;</span> }) }),</div>
<div class="line">      ({</div>
<div class="line"><span class="preprocessor">        #&#39;?,</span></div>
<div class="line"><span class="preprocessor"></span>        ({#<span class="stringliteral">&#39;&gt;, &#39;</span>hp, 10 }),</div>
<div class="line">        ({ #<span class="stringliteral">&#39;call_other, &#39;</span>liv, <span class="stringliteral">&quot;SetHP&quot;</span>, ({#<span class="stringliteral">&#39;-, &#39;</span>hp, 10 }) })</div>
<div class="line">      })</div>
<div class="line">    })</div>
<div class="line">  ) <span class="comment">// of lambda()</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> It is worthy to point out how local variables like 'hp' are declared in a lambda-closure: not at all. They are just used by writing their symbol 'hp . Same applies to the closures parameter 'liv .</p>
<p>The lambda-closure solution is not recommended for three reasons: it is complicated, does not use the powers of lambda(), and the lambda() is recompiled every time this statement is executed!</p>
<p>So far, lambda-closures seem to be just complicated, and in fact: they are. Their powers lie elsewhere.</p>
<p>Imagine a computation, like for skill resolution, which involves two object properties multiplied with factors and then added.</p>
<p>The straightforward solution would be a function like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> Compute (<span class="keywordtype">object</span> obj, <span class="keywordtype">string</span> stat1, <span class="keywordtype">int</span> factor1, <span class="keywordtype">string</span> stat2,</div>
<div class="line">  <span class="keywordtype">int</span> factor2)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (</div>
<div class="line">    call_other(obj, <span class="stringliteral">&quot;Query&quot;</span>+stat1) * factor1 +</div>
<div class="line">    call_other(obj, <span class="stringliteral">&quot;Query&quot;</span>+stat2) * factor2</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><p> Each call to Compute() involves several operations (computing the function names and resolving the call_other()s) which in fact need to be done just once. Using lambda-closures, one can construct and compile a piece of code which behaves like a Compute() tailored for a specific stat/factor combination:</p>
<div class="fragment"><div class="line">closure ConstructCompute (<span class="keywordtype">object</span> obj, <span class="keywordtype">string</span> stat1, <span class="keywordtype">int</span> factor1,</div>
<div class="line">  <span class="keywordtype">string</span> stat2, <span class="keywordtype">int</span> factor2)</div>
<div class="line">{</div>
<div class="line">  mixed code;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Construct the first multiplication.</span></div>
<div class="line">  <span class="comment">// The symbol_function() creates a symbol for the</span></div>
<div class="line">  <span class="comment">// lfun &#39;Query&lt;stat1&gt;&#39;, speeding up later calls.</span></div>
<div class="line">  <span class="comment">// Note again the extra ({ }) around the created symbol.</span></div>
<div class="line"></div>
<div class="line">  code = ({#<span class="stringliteral">&#39;*, ({ symbol_function(&quot;Query&quot;+stat1, obj) }), factor1 });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  // Construct the second multiplication, and the addition</span></div>
<div class="line"><span class="stringliteral">  // of both terms.</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  code = ({</span></div>
<div class="line"><span class="stringliteral">    #&#39;</span>+,</div>
<div class="line">    code,</div>
<div class="line">    ({#<span class="stringliteral">&#39;*, ({ symbol_function(&quot;Query&quot;+stat2, obj) }), factor2 })</span></div>
<div class="line"><span class="stringliteral">  });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  // Compile the code and return the generated closure.</span></div>
<div class="line"><span class="stringliteral">  return lambda(0, code);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p> Once the closure is compiled,</p>
<div class="fragment"><div class="line">str_dex_fun = ConstructCompute(obj, <span class="stringliteral">&quot;Str&quot;</span>, 10, <span class="stringliteral">&quot;Dex&quot;</span>, 90);</div>
</div><!-- fragment --><p> it can be used with a simple 'funcall(str_dex_fun)'.</p>
<h2>WHEN TO USE WHICH CLOSURE?</h2>
<p>First, a closure is only then useful if it needn't to live any longer than the object defining it. Reason: when the defining object gets destructed, the closure will vanish, too.</p>
<p>Efun-, lfun- and inline closures should be used where useful, as they mostly do the job and are easy to read. The disadvantage of lfun- and inline closures is that they make a replace_program() impossible - but since such objects tend to not being replaceable at all, this is no real loss.</p>
<p>Lambda closures are needed if the actions of the closure are heavily depending on some data available only at runtime, like the actual inventory of a certain player.</p>
<p>If you use lfun-closures and find yourself shoving around runtime data in arguments or (gasp!) global variables, it is time to think about using a lambda-closure, compiling the value hard into it.</p>
<p>The disadvantages of lambda closures are clear: they are damn hard to read, and each lambda() statement requires extra time to compile the closure.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="driver_LPC_closures.html">closures</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="driver_todo.html">todo</a></li><li class="navelem"><a class="el" href="driver_LPC_lpc.html">lpc</a></li>
    <li class="footer">Generated on Tue Jun 7 2016 19:15:59 for Tsunami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
