<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LDMud: Telnet Negotiations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LDMud
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('driver_topics_negotiation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Telnet Negotiations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The telnet protocol is used to control textbased connections between a client (the 'telnet' program or a mud client) and a server (the game driver). Most of the options offered by the protocol are optional and need to be negotiated between the client and the server. Consequently, and due to their specialized nature, mud clients don't have to support the full telnet option feature set.</p>
<p>For the server to find out if a client supports the telnet protocol at all, one good approach is to issue a simple, commonly used telnet command to the client. If the client reaction conforms to the protocol (or sends telnet commands itself), the mud can continue to negotiate further options. If the client does not react, the mud can safely refrain from further negotiations.</p>
<p>The following list is a more or less comprehensive overview of the telnet related RFCs (available for example on driver_http:__www.faqs.org_rfcs "http://www.faqs.org/rfcs"):</p>
<div class="fragment"><div class="line">RFC Title                                              rel. Code</div>
<div class="line"></div>
<div class="line">495 TELNET Protocol Specification</div>
<div class="line">513 Comments on the <span class="keyword">new</span> TELNET specifications</div>
<div class="line">559 Comments on the <span class="keyword">new</span> TELNET Protocol and its Implem</div>
<div class="line">595 Some Thoughts in Defense of the TELNET Go-Ahead</div>
<div class="line">596 Second Thoughts on Telnet Go-Ahead</div>
<div class="line">652 Telnet Output Carriage-Return Disposition Option   NAOCRD     10</div>
<div class="line">653 Telnet Output Horizontal Tabstops Option           NAOHTS     11</div>
<div class="line">654 Telnet Output Horizontal Tab Disposition Option    NAOHTD     12</div>
<div class="line">655 Telnet Output Formfeed Disposition Option          NAOFFD     13</div>
<div class="line">656 Telnet Output Vertical Tabstops Option             NAOVTS     14</div>
<div class="line">657 Telnet Output Vertical Tab Disposition Option      NAOVTD     15</div>
<div class="line">658 Telnet Output Linefeed Disposition                 NAOLFD     16</div>
<div class="line">698 Telnet Extended Ascii Option                       X-ASCII    17</div>
<div class="line">727 Telnet Logout Option                               LOGOUT     18</div>
<div class="line">728 A Minor Pitfall in the Telnet Protocol</div>
<div class="line">735 Revised TELNET Byte Macro Option                   BM         19</div>
<div class="line">749 Telnet SUPDUP-OUTPUT Option                        SUPDUP     22</div>
<div class="line">764 Telnet Protocol Specification</div>
<div class="line">779 Telnet SEND-LOCATION Option                        SENDLOC    23</div>
<div class="line">818 The Remote User Telnet Service</div>
<div class="line">854 Telnet Protocol Specification</div>
<div class="line">855 Telnet Option Specifications</div>
<div class="line">856 Telnet Binary Transmission                         BINARY      0</div>
<div class="line">857 Telnet Echo Option                                 ECHO        1</div>
<div class="line">858 Telnet Suppress Go Ahead Option                    SGA         3</div>
<div class="line">859 Telnet Status Option                               STATUS      5</div>
<div class="line">860 Telnet Timing Mark Option                          TM          6</div>
<div class="line">861 Telnet Extended Options - List Option              EXOPL     255</div>
<div class="line">884 Telnet Terminal Type Option                        TTYPE      24</div>
<div class="line">885 Telnet End of Record Option                        EOR        25</div>
<div class="line">930 Telnet Terminal Type Option                        TTYPE      24</div>
<div class="line">933 Output Marking Telnet Option                       OUTMRK     27</div>
<div class="line">946 Telnet Terminal Location Number Option             TTYLOC     28</div>
<div class="line">1043 Telnet Data Entry Terminal Option DODIIS Implement DET        20</div>
<div class="line">1053 Telnet X.3 PAD Option                              X.3-PAD    30</div>
<div class="line">1073 Telnet Window Size Option                          NAWS       31</div>
<div class="line">1079 Telnet Terminal Speed Option                       TSPEED     32</div>
<div class="line">1080 Telnet Remote Flow Control Option                  FLOWCTRL   33</div>
<div class="line">1091 Telnet Terminal-Type Option                        TTYPE      24</div>
<div class="line">1096 Telnet X Display Location Option                   XDISPLOC   35</div>
<div class="line">1116 Telnet Linemode Option                             LINEMODE   34</div>
<div class="line">1143 The Q Method of Implementing TELNET Option Negotia</div>
<div class="line">1184 Telnet Linemode Option                             LINEMODE   34</div>
<div class="line">1372 Telnet Remote Flow Control Option                  FLOWCTRL   33</div>
<div class="line">1408 Telnet Environment Option                          ENVIRON    36</div>
<div class="line">1571 Telnet Environment Option Interoperability Issues</div>
<div class="line">1572 Telnet Environment Option                          NEWENV     39</div>
<div class="line">2066 Telnet Charset Option                              CHARSET    42</div>
<div class="line">2217 Telnet Com Port Control Option                     COMPORT    44</div>
<div class="line">2877 5250 Telnet Enhancements</div>
</div><!-- fragment --><p> All negotiations start with the special character IAC which is defined in /usr/include/arpa/telnet.h (or in src/driver/telnet.h for 3.2(.1)) and has the decimal value of 255. Negotiations are based on different telnetoptions (their values are defined in telnet.h too). Before a negotiation can start the client and the server have to agree that they support the option. This works in the following way:</p>
<p>If a client wants to send something to the server it has to send 'IAC WILL option' (For terminaltype negotation this would be the 3 bytes 255,251,24; again, check telnet.h) to confirm that it is able to do that. If the server is supporting that option and wants to receive something it sends 'IAC DO option' (255,253,option)</p>
<p>If one side is receiving an 'IAC WILL option' and has not yet sent with DO or DONT it has to respond with either 'IAC DO option' if it will support this negotiation or 'IAC DONT option' if it won't.</p>
<p>If one side is receiving an 'IAC DO option' and has not yet sent a WILL or WONT it has to reply with either 'IAC WILL option' if it supports the option or 'IAC WONT option' if not.</p>
<p>A small example: Lets assume we want to negotiate terminaltype. (TELOPT_TTYPE with value 24). client is the telnet executable on the playerside, the server is the gamedriver.</p>
<p>client server</p>
<p>IAC WILL TTYPE IAC DO TTYPE</p>
<p>Or: IAC DO TTYPE</p>
<p>IAC WILL TTYPE</p>
<p>After this we are ready to transfer the terminaltype from the client to the server as explained below. 3 options I have currently implemented. the client and the server have exchanged WILL/DO. terminaltypes from the beginning.</p>
<p>Example: (we have exchanged WILL/DO already) client server IAC SB TTYPE SEND IAC SE</p>
<p>IAC SB TTYPE IS VT200 IAC SE IAC SB TTYPE SEND IAC SE</p>
<p>IAC SB TTYPE IS VT100 IAC SE IAC SB TTYPE SEND IAC SE</p>
<p>IAC SB TTYPE IS VT52 IAC SE IAC SB TTYPE SEND IAC SE</p>
<p>IAC SB TTYPE IS VT52 IAC SE /* this marks that we have all terminaltypes. We decide to use the</p>
<ul>
<li>vt200 mode so we have to skip to VT200</li>
</ul>
<p>&gt;&gt;*&lt;&lt;/ IAC SB TTYPE SEND IAC SE</p>
<p>IAC SB TTYPE IS VT200 IAC SE</p>
<p>Next important option is NAWS (31) or WindowSizeNegotiation.</p>
<p>This one is a bit easier than terminaltype. After having received a IAC DO NAWS from the server, the client will reply with IAC WILL NAWS and immediately after that send IAC SB NAWS columns_high columns_low lines_high lines_low IAC SE where xx_low refers to the lowbyte of xx and xx_high refers to the highbyte of xx. This will be automagically resent at every windowresize (when the client gets a SIGWINCH for example) or at your request with 'IAC SB NAWS SEND IAC SE'.</p>
<p>Example: (WILL/DO exchanged) client server</p>
<p>IAC SB NAWS 0 80 0 24 IAC SE /* the standard vt100 windowsize &gt;&gt;*&lt;&lt;/ /* no reply &gt;&gt;*&lt;&lt;/</p>
<p>And, a bit less important but most complex, the LINEMODE (34) option. It was implemented it due to the fact, that some weird DOS telnets would not work otherwise. Implemented are only the absolute basic feature, which is the actual switching the telnet to linemode. After exchanging WILL/DO the server sends a modechange request to the client using IAC SB LINEMODE LM_MODE MODE_EDIT IAC SE, which should turn on local commandline-editing for the client. If a client supports LINEMODE it HAS to support this modechange. The client will reply with IAC SB LINEMODE LM_MODE MODE_EDIT|MODE_ACK IAC SE (x|y is bitwise or). That's it for linemode. (You will perhaps receive other IAC SB LINEMODEs with other LM_xxx ... you may ignore them. (At least IRIX 5.x sends IAC SB LINEMODE LM_SLC .... IAC SE which declares the local characterset.)).</p>
<p>Example: (WILL/DO negotiated)</p>
<p>client server IAC SB LINEMODE LM_MODE MODE_EDIT IAC SE</p>
<p>IAC SB LINEMODE LM_MODE MODE_EDIT|MODE_ACK IAC SE</p>
<dl class="section user"><dt>note: The option is more interesting than it looks here. For example it supports a mixed mode between linemode and charactermode, flushing the input at certain characters (at ESC or TAB for shell-like commandline completition). We suggest reading RFC 1184.</dt><dd></dd></dl>
<p>You might be interested in TELOPT_XDISPLAYLOC and TELOPT_ENVIRON too.</p>
<p>Now, how to implement this using LDMud?</p>
<ul>
<li>Patch src/driver/comm1.c, function init_telopts() to include telopts_do[TELOPT_XXX] = reply_h_telnet_neg; telopts_dont[TELOPT_XXX] = reply_h_telnet_neg; telopts_will[TELOPT_XXX] = reply_h_telnet_neg; telopts_wont[TELOPT_XXX] = reply_h_telnet_neg;</li>
</ul>
<p>for every telnet negotiation you want to use. Do not overwrite the TELOPT_ECHO and TELOPT_SGA hooks.Alternatively, set the driver hook H_NOECHO in <a class="el" href="master_8c_source.html">master.c</a>: this diverts <em>all</em> telnet data into the mudlib.</p>
<ul>
<li>Add a new driver hook to <a class="el" href="master_8c_source.html">master.c</a> just below the others. set_driver_hook(H_TELNET_NEG,"telnet_neg"),</li>
<li>Make a telnet.h for your mudlib... just change the arrays in src/driver/telnet.h.</li>
<li>define a function void telnet_neg(int cmd, int option, int * optargs)</li>
</ul>
<p>in your interactive objects (login.c, shells, player.c or whereever). And note, in ALL objects, through which a player is handed through (in TAPPMud these are login.c and player.c). [Ok, <a class="el" href="master_8c_source.html">master.c</a> is interactive for a very short time too, but it won't accept input, will it?] 'cmd' will be TELCMD_xxxx (see telnet.h), 'option' one of TELOPT_xxxx and 'optargs' will be an array of ints (bytes in fact) when 'cmd' is SB. Parse 'cmd'/'option' and reply with appropiate answers using binary_message() (appropiate meaning sending the right DO/DONT/WILL/WONT if not sent before and using the SB return values).</p>
<p>3.1. Send IAC DO TTYPE IAC DO NAWS IAC DO LINEMODE at the first time you can do it (before cat()ing /WELCOME perhaps).</p>
<p>3.2. Note all sent and received WILL/WONT/DO/DONT options for conforming to the standard, avoiding endless loops and for easy debugging :)</p>
<p>3.3. Pass those recevied/sent data and other data when the interactive object is changed (from login.c to player.c or at other bodychanges). Clear the data when the player goes linkdead or quits. You won't need to save this data.</p>
<p>3.4. Lower_case() terminaltypes... ;) 3.5. Use reasonable defaultvalues if the client does not</p>
<p>support one of the options. (columns 80, lines 24 if not NAWS, unknown or vt100 for no terminaltype)</p>
<p>The WILL/WONT/DO/DONT data is best saved in a mapping looking like this:</p>
<div class="fragment"><div class="line">([</div>
<div class="line">  <span class="stringliteral">&quot;received&quot;</span>: ([ option1: DO_DONT_OR_0;WILL_WONT_OR_0, ... ]),</div>
<div class="line">  <span class="stringliteral">&quot;sent&quot;</span>    : ([ option1: DO_DONT_OR_0;WILL_WONT_OR_0, ... ])</div>
<div class="line">])</div>
</div><!-- fragment --><p> (Ok, it can be done better. But not without confusing <em>me</em> more.)</p>
<p>Before sending anything check TN["sent"][option,0_if_do_dont_or_1_if_will_wont]</p>
<p>so you don't enter endless loops, save network traffic and the like.</p>
<p>The windowsize is best saved in the players environment variables so that he can modify them later on. (Or in two integers in the player object...). Use for these values is clear I think.</p>
<p>The terminaltypes received using above mentioned method are best stored in an array. The actual set terminaltype is best stored in an environment variable where the player can modify it. Upon modifying it the IAC SB TTYPE SEND IAC SE cycle should be started to match the emulation to the entered new terminaltype. You then may use data retrieved from /etc/termcap (man 5 termcap) or /usr/lib/terminfo/<em>/</em> (SysVID, man 5 terminfo) to implement terminalcontrol codes dependend on the terminaltype. /etc/termcap may prove to be the easiest way tough /usr/lib/terminfo/<em>/</em> is the newer (and better) SysV way of doing it.</p>
<p>LINEMODE replies may be left alone if only using the mode change to MODE_EDIT</p>
<p>Some statistics about what clients support telnet negotiations:</p>
<p>Tinyfugue and some other mudclients usually do not support negotiations.</p>
<p>Except for TF, which supports the Telnet End-Of-Record option as marker for the end of the prompt. So if you send IAC EOR after every prompt, it will print the prompt always in the input window. (Do not forget to negotiate that. First IAC WILL TELOPT_EOR/wait for IAC DO TELOPT_EOR). Newer versions of TF will support NAWS and there will be a patch for TTYPE negotiation available soon.</p>
<p>All telnets able to do negotiations I've encountered support the TTYPE option. HP9.x,Irix5.x,Linux,EP/IX,CUTELNET/NCSATELNET (Novell) and perhaps more support NAWS. At least Irix5.x,Linux,CU/NCSATELNET support LINEMODE. SUN does not support NAWS and LINEMODE neither in SunOS 4.1.3 nor in Solaris 2.3.</p>
<p>For getting RFCs you can for example use driver_ftp:__ftp.uni-erlangen.de_pub_doc_rfc_ "ftp://ftp.uni-erlangen.de/pub/doc/rfc/"</p>
<dl class="section user"><dt>misleading: Not all aspects of the options are mentioned to keep this doc at a reasonable size. Refer to the RFCs to get more confused.</dt><dd></dd></dl>
<p>Credits</p>
<p>Provided by driver_mailto:Marcus "Marcus@TAPPMud" (Marcus Meissner, &lt;driver_mailto:msmeissn.informatik.uni-erlangen.de "msmeissn@cip.informatik.uni-erlangen.de"&gt;). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="driver_topics_overview.html">Other topics</a></li>
    <li class="footer">Generated on Thu Mar 9 2017 17:45:24 for LDMud by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
