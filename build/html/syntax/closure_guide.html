
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Guide to closures &#8212; LDMud UNRELEASED documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'UNRELEASED',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="closures" href="closures.html" />
    <link rel="prev" title="{[&lt;statement&gt;...]}" href="block.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="closures">
<h1>Guide to closures<a class="headerlink" href="#closures" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<span id="lpc.guide.closures"></span><ul class="simple">
<li><a class="reference internal" href="#l" id="id3">Overview and efun-closures</a></li>
<li><a class="reference internal" href="#l" id="id4">Lfun- and Lambda-Closures</a><ul>
<li><a class="reference internal" href="#l" id="id5">Lfun-Closures</a></li>
<li><a class="reference internal" href="#l" id="id6">Inline Closures</a></li>
<li><a class="reference internal" href="#l" id="id7">Lambda-Closures</a><ul>
<li><a class="reference internal" href="#l" id="id8">Advantages of Lambda Closures</a></li>
<li><a class="reference internal" href="#l" id="id9">Free Variables in Lambda-Closure Constructs</a></li>
<li><a class="reference internal" href="#l" id="id10">Special Efun-Closures and Operator-Closures for Lambdas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#Closures with Strange Names" id="id11">Closures with Strange Names</a></li>
<li><a class="reference internal" href="#l" id="id12">Operator-Closures</a></li>
<li><a class="reference internal" href="#l" id="id13">Variable-Closures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#l" id="id14">Examples</a><ul>
<li><a class="reference internal" href="#l" id="id15">Lfun-Closure</a></li>
<li><a class="reference internal" href="#l" id="id16">Lambda-Closure</a></li>
</ul>
</li>
</ul>
</div>
<p>A closure is a pointer to a function. That means that it is data like an int or a string are. It may be assigned to a variable or given to anoth- er function as argument.</p>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h2><a class="toc-backref" href="#id3">Overview and efun-closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h2>
<p>To create a closure that points to an efun (like <a class="reference internal" href="../efun/write.html#lpc.efun.write" title="write"><code class="xref lpc lpc-efun docutils literal"><span class="pre">write</span></code>(E)</a>) you can write the name of the efun prepended with &#8220;hash-tick&#8221;: <code class="docutils literal"><span class="pre">#'</span></code>. <code class="docutils literal"><span class="pre">#'write</span></code> is a closure that points to <a class="reference internal" href="../efun/write.html#lpc.efun.write" title="write"><code class="xref lpc lpc-efun docutils literal"><span class="pre">write</span></code>(E)</a>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">If your editor gets confused by the hashmark, try putting parentheses around such a closure-notation because otherwise my : (<code class="docutils literal"><span class="pre">#'write</span></code>). This is especially of interest within lambda-closures (see below).</p>
</div>
<p>A closure can be evaluated (which means that the function it points to is called) using <a class="reference internal" href="../efun/funcall.html#lpc.efun.funcall" title="funcall"><code class="xref lpc lpc-efun docutils literal"><span class="pre">funcall</span></code>(E)</a> or <a class="reference internal" href="../efun/apply.html#lpc.efun.apply" title="apply"><code class="xref lpc lpc-efun docutils literal"><span class="pre">apply</span></code>(E)</a>, which also allow to give arguments to the function. Example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>funcall(#&#39;write,&quot;hello&quot;);
</pre></div>
</div>
<p>This will result in the same as <code class="docutils literal"><span class="pre">write(&quot;hello&quot;);</span></code> alone. The string &#8220;hello&#8221; is given as first (and only) argument to the function the closure <code class="docutils literal"><span class="pre">#'write</span></code> points to.</p>
<p>The return value of the function the closure points to is returned by <a class="reference internal" href="../efun/funcall.html#lpc.efun.funcall" title="funcall"><code class="xref lpc lpc-efun docutils literal"><span class="pre">funcall</span></code>(E)</a> or <a class="reference internal" href="../efun/apply.html#lpc.efun.apply" title="apply"><code class="xref lpc lpc-efun docutils literal"><span class="pre">apply</span></code>(E)</a>. (Since <a class="reference internal" href="../efun/write.html#lpc.efun.write" title="write"><code class="xref lpc lpc-efun docutils literal"><span class="pre">write</span></code>(E)</a> always returns 0 the return value of the example above will be 0.)</p>
<p>What are closures good for? With closures you can make much more universally usable functions. A good example is the function <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a>. It gets an array and a closure as arguments. Then it calls the function the closure points to for each element of the array:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>filter(({ &quot;bla&quot;,&quot;foo&quot;,&quot;bar&quot; }),#&#39;write);
</pre></div>
</div>
<p>This will call <code class="docutils literal"><span class="pre">write(&quot;bla&quot;)</span></code>, <code class="docutils literal"><span class="pre">write(&quot;foo&quot;)</span></code> and <code class="docutils literal"><span class="pre">write(&quot;bar&quot;)</span></code> in any order; the order is undefined. (In the current implementation the given closure is evaluated for all elements from the first to the last, so the output will be &#8220;blafoobar&#8221;.)</p>
<p>Furthermore <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a> examines the return value of each call of the function the closure points to (the return value of <a class="reference internal" href="../efun/write.html#lpc.efun.write" title="write"><code class="xref lpc lpc-efun docutils literal"><span class="pre">write</span></code>(E)</a>). If the value is true (not 0) then this element is put into another array which <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a> builds up. If the return value is false (== 0) then this element is _not_ put into this array. When all calls are done the slowly built up array is returned. Thus, <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a> filters from the given array all elements that the given closure evaluates &#8220;true&#8221; for and returns an array of those. (The array given to <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a> itself is _not_ changed!)</p>
<p>A more sensical example for filter would be this:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>x = filter(users(),#&#39;query_is_wizard);
</pre></div>
</div>
<p><a class="reference internal" href="../efun/users.html#lpc.efun.users" title="users"><code class="xref lpc lpc-efun docutils literal"><span class="pre">users</span></code>(E)</a> is an efun that gets no arguments and returns an array of all logged in players (wizards and players). <code class="docutils literal"><span class="pre">query_is_wizard</span></code> is a simul_efun that gets an object as first (and only) argument and returns true (1) if this object is a wizard and 0 otherwise.</p>
<p>So, for each element of the array returned by <a class="reference internal" href="../efun/users.html#lpc.efun.users" title="users"><code class="xref lpc lpc-efun docutils literal"><span class="pre">users</span></code>(E)</a> the function <code class="docutils literal"><span class="pre">query_is_wizard</span></code> is called and only those for which 1 was returned are collected into the result and then put into the variable x.</p>
<p>We now have all logged in wizards stored as array in the variable x.</p>
<p>Another example: We want to filter out all numbers that are greater than 42 from the array a of integers:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>x = filter(({ 10,50,30,70 }),#&#39;&gt;,42); // x is now ({ 50,70 })
</pre></div>
</div>
<p>Here two things are new: first: we create a closure that points to an operator; second: we use the possibility to give extra arguments to <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a>.</p>
<p>Like all efuns the usual operators can be pointed to with a closure by prepending <code class="docutils literal"><span class="pre">#'</span></code> to them. <code class="docutils literal"><span class="pre">funcall(#'&gt;,4,5)</span></code> is exactly the same as <code class="docutils literal"><span class="pre">(4&gt;5)</span></code>.</p>
<p>The extra arguments given as third to last argument (as many as you like) to <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a> are given as second to last argument to the function pointed to by the closure each time it is called.</p>
<p>Thus we now call <code class="docutils literal"><span class="pre">``(({</span> <span class="pre">10,50,30,70</span> <span class="pre">})[0]&gt;42)``</span></code>, <code class="docutils literal"><span class="pre">``(({</span> <span class="pre">10,50,30,70</span> <span class="pre">})[1]&gt;42)``</span></code> ... (which is <code class="docutils literal"><span class="pre">(``10&gt;42)</span></code>, <code class="docutils literal"><span class="pre">(50&gt;42)</span></code> ...) and return an array of all elements this returns true for and store it into x.</p>
<p>If you want to create a closure to an efun of which you have the name stored in a string you can create such an efun-closure with <a class="reference internal" href="../efun/symbol_function.html#lpc.efun.symbol_function" title="symbol_function"><code class="xref lpc lpc-efun docutils literal"><span class="pre">symbol_function</span></code>(E)</a>:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">symbol_function</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span> <span class="c1">// this will return #&#39;write</span>

<span class="n">funcall</span><span class="p">(</span><span class="n">symbol_function</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">),</span><span class="s">&quot;foobar&quot;</span><span class="p">);</span>  <span class="c1">// == write(&quot;foobar&quot;);</span>
</pre></div>
</div>
<p>This function does not very often occur in normal code but it is very useful for tool-programming (eg the robe uses <a class="reference internal" href="../efun/symbol_function.html#lpc.efun.symbol_function" title="symbol_function"><code class="xref lpc lpc-efun docutils literal"><span class="pre">symbol_function</span></code>(E)</a> to allow you call any efun you give).</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h2><a class="toc-backref" href="#id4">Lfun- and Lambda-Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h2>
<p>Very often the possibilities closures to efuns offer are not sufficient for the purpose one has. In nearly all cases three possibilities exist in such cases: use an lfun- or inline-closure, or a lambda-closure.</p>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id5">Lfun-Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The first possibility is rather easy: like with the efun-closures you can create a pointer to a function in the same object you are by using the <code class="docutils literal"><span class="pre">#'</span></code> to prepend it to a function name of a function declared above. Example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>status foo(int x) {
  return ((x*2) &gt; 42);
}

int *bar() {
  return filter(({ 10,50,30,70 }),#&#39;foo);
}
</pre></div>
</div>
<p>Thus, <code class="docutils literal"><span class="pre">#'foo</span></code> is used like there was an efun of this name and doing the job that is done in <code class="docutils literal"><span class="pre">foo()</span></code>.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id6">Inline Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Inline closures are a variant of lfun closures, the difference being that the function text is written right where the closure is used, enclosed in a pair of <code class="docutils literal"><span class="pre">(:</span></code> and <code class="docutils literal"><span class="pre">:)</span></code>. The compiler will then take care of creating a proper lfun and lfun-closure. The arguments passed to such an inline closure are accessible by position: <code class="docutils literal"><span class="pre">$1</span></code> would be the first argument, <code class="docutils literal"><span class="pre">$2</span></code> the second, and so on. With this, the above example would read:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>int * bar() {
  return filter(({ 10,50,30,70 }), (: ($1 * 2) &gt; 42 :));
}
</pre></div>
</div>
<p>or alternatively:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>int * bar() {
  return filter(({ 10,50,30,70 }), (: return ($1 * 2) &gt; 42; :));
}
</pre></div>
</div>
<p>The difference between the two versions is that in the first form the text of the inline closure must be an expression only, whereas in the second form any legal statement is allowed. The compiler distinguishes the two forms by the last character before the <code class="docutils literal"><span class="pre">:)</span></code>: if it&#8217;s a <code class="docutils literal"><span class="pre">;</span></code> or <code class="docutils literal"><span class="pre">}</span></code>, the compiler treats the closure as statement(s), otherwise as expression.</p>
<p>Inline closures may also nested, so that the following (not very useful) example is legal, too:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>return filter(
  ({ 10, 50, 30, 70 }),
  (: string *s;
    s = map(users(), (: $1-&gt;query_name() :));
    return s[random(sizeof(s))] + ($1 * 2);
  :)
);
</pre></div>
</div>
<p>The notation of inline closures is modelled after the MudOS functionals, but there are a few important differences in behaviour.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id7">Lambda-Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Lambda-Closures take the idea of &#8216;define it where you use it&#8217; one step further. On first glance they may look like inline closures with an uglier notation, but they offer a few increased possibilities. But first things first.</p>
<p>The efun <a class="reference internal" href="../efun/lambda.html#lpc.efun.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a> creates a function temporarily and returns a closure pointing to this function. <a class="reference internal" href="../efun/lambda.html#lpc.efun.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a> therefor gets two arrays as arguments, the first is a list of all arguments the function shall expect and the second array is the code of the function (in a more or less complicated form; at least not in C- or LPC-syntax). The closure <code class="docutils literal"><span class="pre">#'foo</span></code> from the example above could be notated as lambda-closure:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(
  ({ &#39;x }),
  ({
    (#&#39;&gt;),
    ({ (#&#39;*),&#39;x,2 }),
    42
  })
)
</pre></div>
</div>
<p>Now, the first argument is <code class="docutils literal"><span class="pre">({</span> <span class="pre">'x</span> <span class="pre">})</span></code>, an array of all arguments the function shall expect: 1 argument (called &#8216;x) is expected. Notice the strange notation for this argument with one single leading tick. Like The hash-tick to denote closures the leading tick is used to denote things called &#8220;symbols&#8221;. They do not differ much from strings and if you do not want to have a deeper look into closures you can leave it this way.</p>
<p>The second argument is an array. The first element of such an array must be an efun- or an lfun-closure, the further elements are the arguments for the function this closure points to. If such an argument is an array, it is treated alike; the first element must be a closure and the remaining elements are arguments (which of course also might be arrays ...).</p>
<p>This leads to a problem: sometimes you want to give an array as an argument to a function. But arrays in an array given to <a class="reference internal" href="../efun/lambda.html#lpc.efun.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a> are interpreted as code-arrays. To allow you to give an array as an argument within an array given to <a class="reference internal" href="../efun/lambda.html#lpc.efun.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a>, you can use the function <a class="reference internal" href="../efun/quote.html#lpc.efun.quote" title="quote"><code class="xref lpc lpc-efun docutils literal"><span class="pre">quote</span></code>(E)</a> to make your array to a quoted array (a quoted array is for an array what a symbol is for a string):</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(0,
  ({
    (#&#39;sizeof),
    quote(({ 10,50,30,70 }))
  })
)
</pre></div>
</div>
<p>For array constants, you can also use a single quote to the same effect:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(0,
  ({
    (#&#39;sizeof),
    &#39;({ 10,50,30,70 })
  })
)
</pre></div>
</div>
<p>This lambda-closure points to a function that will return 4 (it will call <a class="reference internal" href="../efun/sizeof.html#lpc.efun.sizeof" title="sizeof"><code class="xref lpc lpc-efun docutils literal"><span class="pre">sizeof</span></code>(E)</a> for the array <code class="docutils literal"><span class="pre">({</span> <span class="pre">10,50,30,70</span> <span class="pre">})</span></code>). Another thing: if we want to create a function that expects no arguments, we can give an empty array as first argument to <a class="reference internal" href="../efun/lambda.html#lpc.efun.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a> but we can give 0 as well to attain this. This is just an abbreviation.</p>
<p>Lambda-closure constructs can become quite large and hard to read. The larger they become the harder the code is to read and you should avoid extreme cases. Very often the possibility to use an lfun or an inline instead of a large lambda shortens the code dramatically. Example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>status foo(object o) {
  return environment(o)-&gt;query_level()&gt;WL_APPRENTICE;
}

x=filter(a,#&#39;foo);
</pre></div>
</div>
<p>does the same as:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>x=filter(
  a,
  lambda(
    ({ &#39;o }),
    ({
      (#&#39;&gt;),
      ({
        (#&#39;call_other),
        ({ (#&#39;environment),&#39;o }),
        &quot;query_level&quot;
      }),
      WL_APPRENTICE
    })
  )
);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the syntax with the arrow <code class="docutils literal"><span class="pre">-&gt;</span></code> for <a class="reference internal" href="../efun/call_other.html#lpc.efun.call_other" title="call_other"><code class="xref lpc lpc-efun docutils literal"><span class="pre">call_other</span></code>(E)</a> cannot be used, <code class="docutils literal"><span class="pre">#'-&gt;</span></code> does not exist. You have to use <code class="docutils literal"><span class="pre">#'call_other</span></code> for this and give the name of the lfun to be called as a string.)</p>
</div>
<p>This example also demonstrates the two disadvantages of lambda closures. First, they are very difficult to read, even for a simple example like this. Second, the lambda closure is re-created everytime the <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a> is executed, even though the created code is always the same.</p>
<p>&#8216;Why use lambdas at all then?&#8217; you may ask now. Well, read on.</p>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h4><a class="toc-backref" href="#id8">Advantages of Lambda Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h4>
<p>The advantages of lambdas stem from the fact that they are created at runtime from normal arrays.</p>
<p>This means that the behaviour of a lambda can be made dependant on data available only at runtime. For example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>closure c;
c = lambda(0, ({#&#39;-, ({ #&#39;time }), time() }) );
</pre></div>
</div>
<p>Whenever you now call this closure (<code class="docutils literal"><span class="pre">funcall(c)</span></code>) it will return the elapsed time since the closure was created.</p>
<p>The second advantage of lambdas is that the arrays from which they are compiled can be constructed at runtime. Imagine a customizable prompt which can be configured to display the time, the environment, or both:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>mixed code;

code = ({ &quot;&gt; &quot; });
if (user_wants_time)
{
  code = ({ #&#39;+, ({ #&#39;ctime }), code });
}

if (user_wants_environment)
{
  code = ({
    #&#39;+,
    ({
      #&#39;to_string,
      ({#&#39;environment, ({#&#39;this_player }) })
    }),
    code
  });
}
set_prompt(lambda(0, code));
</pre></div>
</div>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h4><a class="toc-backref" href="#id9">Free Variables in Lambda-Closure Constructs</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h4>
<p>You can use local variables in lambda constructs without declaring them, just use them. The only limitation is that you at first have to assign something to them. Give them as symbols like you do with the arguments. This feature does not make much sense without the use of complexer flow controlling features described below.</p>
<p>The closure <code class="docutils literal"><span class="pre">#'=</span></code> is used to assign a value to something (like <a class="reference internal" href="operators.html#lpc.operator.=" title="="><code class="xref lpc lpc-operator docutils literal"><span class="pre">=</span></code></a>).</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h4><a class="toc-backref" href="#id10">Special Efun-Closures and Operator-Closures for Lambdas</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h4>
<p>There are some special closures that are supposed to be used only within a lambda construct. With them you can create nearly all code you can with regular LPC-code like loops and conditions.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">#'?</span></code></dt>
<dd><p class="first">acts like the &#8220;if&#8221; statement in LPC. The first argument is the condition, the second is the code to be executed if the condition returns true. The following arguments can also be such couples of code-arrays that state a condition and a possible result. If at the end there is a single argument, it is used as the else-case if no condition returned true:</p>
<div class="last highlight-pike"><div class="highlight"><pre><span></span>lambda(
  ({ &#39;x }),
  ({
    (#&#39;?),             // if
    ({ (#&#39;&gt;),&#39;x,5 }),  //    (x &gt; 5)
    ({ (#&#39;*),&#39;x,2 }),  //       result is x * 2;
    ({ (#&#39;&lt;),&#39;x,-5 }), // else if (x &lt; -5)
    ({ (#&#39;/),&#39;x,2 }),  //    result is x/2;
    &#39;x                 // else result is x;
  })
)
</pre></div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">#'?!</span></code></dt>
<dd>is like the <code class="docutils literal"><span class="pre">#'?</span></code> but it negates all conditions after evaluation and thus is like an ifnot in LPC (if there were one).</dd>
<dt><code class="docutils literal"><span class="pre">#',</span></code></dt>
<dd><p class="first">(which looks a bit strange) is the equivalent of the comma-operator in LPC and says: evaluate all arguments and return the value of the last. It is used to do several things inside a lambda-closure:</p>
<div class="last highlight-pike"><div class="highlight"><pre><span></span>lambda(
  ({ &#39;x }),
  ({
    (#&#39;,),  // two commas necessary! one for the closure and one as delimiter in the array
    ({ (#&#39;write),&quot;hello world!&quot; }),
    ({ (#&#39;say),&quot;Foobar.&quot; })
  })
)
</pre></div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">#'while</span></code></dt>
<dd><p class="first">acts like the LPC statement &#8220;while&#8221; and repeats executing one code-array while another returns true. <code class="docutils literal"><span class="pre">#'while</span></code> expects two or more arguments: the condition as first argument, then the result the whole expression shall have after the condition turns false (this is in many cases of no interest) and as third to last argument the body of the loop:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(
  0,
  ({
    (#&#39;,),                 // several things to do ...
    ({ (#&#39;=),&#39;i,0 }),      // i is a local variable of this lambda-closure and is initialized with 0 now.
    ({
      (#&#39;while),
      ({ (#&#39;&lt;),&#39;i,10 }),   // condition: i &lt; 10
      42,                  // result is not interesting, but we must give one
      ({ (#&#39;write),&#39;i }),  // give out i
      ({ (#&#39;+=),&#39;i,1 })    // increase i
    })
  })
)
</pre></div>
</div>
<p class="last">The function this closure points to will give out the numbers from 0 to 9 and then return 42.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">#'do</span></code></dt>
<dd><p class="first">is like the do-while statement in LPC and is very much like the <code class="docutils literal"><span class="pre">#'while</span></code>. The difference is that <code class="docutils literal"><span class="pre">#'while</span></code> tests the condition already before the body is evaluated for the first time, this means that the body might not be evaluated even once. <code class="docutils literal"><span class="pre">#'do</span></code> evaluates the body first and then the condition, thus the body is evaluated at least one time.</p>
<p>Furthermore, the arguments for <code class="docutils literal"><span class="pre">#'do</span></code> are changed in order. <code class="docutils literal"><span class="pre">#'do</span></code> expects as first to last but two the body of the loop, then the condition (as last-but-one&#8217;th argument) and the result value as last argument. So <code class="docutils literal"><span class="pre">#'do</span></code> must have at least two arguments: the condition and the result:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(
  0,
  ({
    (#&#39;,),                 // several things to do ...
    ({ (#&#39;=),&#39;i,0 }),      // i is a local variable of this lambda-closure and is initialized with 0 now.
    ({
      (#&#39;do),
      ({ (#&#39;write),&#39;i }),  // give out i
      ({ (#&#39;+=),&#39;i,1 }),   // increase i
      ({ (#&#39;&lt;),&#39;i,10 }),   // condition: i &lt; 10
      42                   // result is not interesting
    })
  })
)
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is no <code class="docutils literal"><span class="pre">#'for</span></code> in LPC, you should use <code class="docutils literal"><span class="pre">#'while</span></code> for this.</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">#'foreach</span></code></dt>
<dd><p class="first">is like the <a class="reference internal" href="foreach.html#lpc.keyword.foreach" title="foreach"><code class="xref lpc lpc-keyword docutils literal"><span class="pre">foreach</span></code></a> statement in LPC. It evaluates one or more bodies repeatedly for every value in a giving string, array or mapping. The result of the closure is 0.</p>
<p><code class="docutils literal"><span class="pre">#'foreach</span></code> expects two or more arguments:</p>
<ul class="simple">
<li>a single variable symbol, or an array with several variable symbols</li>
<li>the value to iterate over</li>
<li>zero or more bodes to evaluate in each iteration.</li>
</ul>
<p>The single values retrieved from the given value are assigned one after another to the variable(s), then the bodies are executed for each assignment:</p>
<div class="last highlight-pike"><div class="highlight"><pre><span></span>lambda(
  0,
  ({
    #&#39;foreach,
    &#39;o,
    ({#&#39;users}),
    ({#&#39;call_other, &#39;o, &quot;die&quot; })
  })
);

lambda(
  0,
  ({
    #&#39;foreach,
    ({&#39;k, &#39;v}),
    ({ ...mapping...}),
    ({#&#39;printf, &quot;%O:%O\n&quot;, &#39;k, &#39;v })
  })
);
</pre></div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">#'return</span></code></dt>
<dd><p class="first">gets one argument and acts like the &#8220;return&#8221; statement in LPC in the function that is created by <a class="reference internal" href="../efun/lambda.html#lpc.efun.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a>. It aborts the execution of this function and returns the argument:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(
  0,
  ({
    (#&#39;while),// loop
    1,        // condition is 1 ==&gt; endles loop
    42,       // return value (which will never be used)
    ({ (#&#39;write), &quot;grin&quot; }),
    ({
      (#&#39;?!),                // ifnot
      ({ (#&#39;random), 10 }),  //       (random(10))
      ({ (#&#39;return), 100 })  //   return 100;
    })
  })
)
</pre></div>
</div>
<p class="last">This function will enter an endless loop that will in each turn give out &#8220;grin&#8221; and if <code class="docutils literal"><span class="pre">random(10)</span></code> returns 0 (which will of course happen very soon) it will leave the function with &#8220;return 100&#8221;. The value 42 that is given as result of the loop would be returned if the condition would evaluate to 0 which cannot be. (1 is never 0 ;-)</p>
</dd>
<dt><code class="docutils literal"><span class="pre">#'break</span></code></dt>
<dd><p class="first">is used like the &#8220;break&#8221; statement in LPC and aborts the execution of loops and switches. It must not appear outside a loop or switch of the lambda closure itself, it cannot abort the execution of the function the closure points to!:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(
  0,
  ({
    (#&#39;?),
    ({ (#&#39;random),2 }),
    ({ (#&#39;break) }), // this will cause the error &quot;Unimplemented operator break for lambda()&quot;
    &quot;random was false!&quot;
  })
);
</pre></div>
</div>
<p class="last">You can use <code class="docutils literal"><span class="pre">({</span> <span class="pre">#'return,0</span> <span class="pre">})</span></code> instead of <code class="docutils literal"><span class="pre">({</span> <span class="pre">#'break</span> <span class="pre">})</span></code> in such cases.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">#'continue</span></code></dt>
<dd>is used like the &#8220;continue&#8221; statement in LPC and jumps to the end of the current loop and continues with the loop condition.</dd>
<dt><code class="docutils literal"><span class="pre">#'default</span></code></dt>
<dd><p class="first">may be used within a <code class="docutils literal"><span class="pre">#'switch-construct</span></code> but be careful! To call <code class="docutils literal"><span class="pre">symbol_function(&quot;default&quot;)</span></code> (which is done usually by tools that allow closure-creation) might crash the driver! So please do only use it within your LPC-files.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This driver bug is fixed somewhere below <a class="reference external" href="mailto:3&#46;2&#46;1&#37;&#52;&#48;131">3<span>&#46;</span>2<span>&#46;</span>1<span>&#64;</span>131</a>.</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">#'..</span></code></dt>
<dd>may be used within a <code class="docutils literal"><span class="pre">#'switch-construct</span></code> but is not implemented yet (<a class="reference external" href="mailto:3&#46;2&#46;1&#37;&#52;&#48;131">3<span>&#46;</span>2<span>&#46;</span>1<span>&#64;</span>131</a>). But <code class="docutils literal"><span class="pre">#'[..]</span></code> works well instead of it.</dd>
<dt><code class="docutils literal"><span class="pre">#'switch</span></code></dt>
<dd><p class="first">is used to create closures which behave very much like the switch-construct in LPC. To understand the following you should already know the syntax and possibilities of the latter one (which is mightier than the C-version of switch).</p>
<p>I will confront some LPC versions and the corresponding closure versions below.</p>
<div class="last highlight-pike"><div class="highlight"><pre><span></span>LPC:                  Closure::

switch (x) {                    lambda(0,({ (#&#39;switch), x,
case 5:                           ({ 5 }),
 return &quot;five&quot;;                  ({ (#&#39;return),&quot;five&quot; }),
                                 (#&#39;,),
case 6..9:                        ({ 6, (#&#39;[..]), 9 }),
 return &quot;six to nine&quot;;           ({ (#&#39;return),
                                    &quot;six to nine&quot; }),
                                 (#&#39;,),
case 1:                           ({ 1 }),
 write(&quot;one&quot;);                   ({ (#&#39;write),&quot;one&quot; }),
 // fall through                 (#&#39;,),
case 2:                           ({ 2,
case 10:                             10 }),
 return &quot;two or ten&quot;;            ({ (#&#39;return),
                                    &quot;two or ten&quot; }),
                                 (#&#39;,),
case 3..4:                        ({ 3, (#&#39;[..]), 4 }),
 write(&quot;three to four&quot;);         ({ (#&#39;write),
                                    &quot;three to four&quot; }),
 break;  // leave switch         (#&#39;break),
default:                          ({ (#&#39;default) }),
 write(&quot;something else&quot;);        ({ (#&#39;write),
                                    &quot;something else&quot; }),
 break;                          (#&#39;break)
}                              }))
</pre></div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">#'&amp;&amp;</span></code></dt>
<dd>evaluates the arguments from the first on and stops if one evaluates to 0 and returns 0. If none evaluates to 0 it returns the result of the last argument.</dd>
<dt><code class="docutils literal"><span class="pre">#'||</span></code></dt>
<dd>evaluates the arguments from the first on and stops if one evaluates to true (not 0) and returns it. If all evaluate to 0 it returns 0.</dd>
<dt><code class="docutils literal"><span class="pre">#'catch</span></code></dt>
<dd>executes the closure given as argument, but catches any runtime error (see <a class="reference internal" href="../efun/catch.html#lpc.efun.catch" title="catch"><code class="xref lpc lpc-efun docutils literal"><span class="pre">catch</span></code>(E)</a>). Optionally the symbols &#8216;nolog, &#8216;publish and &#8216;reserve may be given as additional arguments to modify the behaviour of the catch.</dd>
<dt><code class="docutils literal"><span class="pre">#'sscanf</span></code></dt>
<dd>acts similar to how a funcall would, but passes the third and following arguments as lvalues, that is, values which can be assigned to.</dd>
<dt><code class="docutils literal"><span class="pre">#'=</span></code> and the <code class="docutils literal"><span class="pre">#'&lt;op&gt;=</span></code> variants</dt>
<dd>are also special because the first argument has to be an lvalue.</dd>
</dl>
</div>
</div>
<div class="section" id="Closures with Strange Names">
<h3><a class="toc-backref" href="#id11">Closures with Strange Names</a><a class="headerlink" href="#Closures with Strange Names" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt id="term-negate"><code class="docutils literal"><span class="pre">#'negate</span></code></dt>
<dd><p class="first">is the unary minus that returns -x for the argument x.:</p>
<div class="last highlight-pike"><div class="highlight"><pre><span></span>map(({ 1,2,3 }), #&#39;negate) // returns ({ -1,-2,-3 })
</pre></div>
</div>
</dd>
<dt id="term"><code class="docutils literal"><span class="pre">#'[</span></code></dt>
<dd><p class="first">is used for the things that in LPC are done with the <a class="reference internal" href="index.html#lpc.operator.[]" title="[]"><code class="xref lpc lpc-operator docutils literal"><span class="pre">[]</span></code></a> (it indexes an array or a mapping):</p>
<div class="last highlight-pike"><div class="highlight"><pre><span></span>lambda(0, ({ #&#39;[, quote(({ 10, 50, 30, 70 })), 2 })) ==&gt; 30
lambda(0, ({ #&#39;[, ([ &quot;x&quot;:10;50, &quot;y&quot;:30;70 ]), &quot;x&quot;, 1 })) ==&gt; 50
</pre></div>
</div>
</dd>
<dt id="term-2"><code class="docutils literal"><span class="pre">#'[&lt;</span></code></dt>
<dd>is the same as <code class="docutils literal"><span class="pre">#'[</span></code> but counts the elements from the end (like indexing with <code class="docutils literal"><span class="pre">[]</span></code> and the <code class="docutils literal"><span class="pre">&lt;</span></code>).</dd>
<dt id="term-3"><code class="docutils literal"><span class="pre">#'[..]</span></code></dt>
<dd>returns a subarray of the argument from the one given index to the other given index, both counted from the beginning of the array.</dd>
<dt id="term-4"><code class="docutils literal"><span class="pre">#'[..&lt;]</span></code><dt id="term-5"><code class="docutils literal"><span class="pre">#'[&lt;..]</span></code><dt id="term-6"><code class="docutils literal"><span class="pre">#'[&lt;..&lt;]</span></code></dt>
<dd><p class="first">same as above, but the indexes are counted from the end:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="kt">lambda</span><span class="p">(</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="p">({</span>
    <span class="cp">#&#39;[..&lt;],</span>
    <span class="n">quote</span><span class="p">(({</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span> <span class="p">})),</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="mi">3</span>
  <span class="p">})</span>
<span class="p">)</span>
</pre></div>
</div>
<p class="last">This will return <code class="docutils literal"><span class="pre">({</span> <span class="pre">2,3,4,5</span> <span class="pre">})</span></code>.</p>
</dd>
<dt id="term-7"><code class="docutils literal"><span class="pre">#'[..</span></code><dt id="term-8"><code class="docutils literal"><span class="pre">#'[&lt;..</span></code></dt>
<dd>same as above, but only the first index is given, the subarray will go till the end of the original (like with <code class="docutils literal"><span class="pre">[x..]</span></code>).</dd>
<dt id="term-9"><code class="docutils literal"><span class="pre">#'({</span></code></dt>
<dd><p class="first">is used to create arrays (as with <code class="docutils literal"><span class="pre">({</span> <span class="pre">})</span></code> in LPC). All arguments become the elements of the array.:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(
  0,
  ({
    #&#39;({,
    ({ (#&#39;random), 10 }),
    ({ (#&#39;random), 50 }),
    ({ (#&#39;random), 30 }),
    ({ (#&#39;random), 70 })
  })
)
</pre></div>
</div>
<p class="last">This returns <code class="docutils literal"><span class="pre">({</span> <span class="pre">random(10),</span> <span class="pre">random(50),</span> <span class="pre">random(30),</span> <span class="pre">random(70)</span> <span class="pre">})</span></code>.</p>
</dd>
<dt id="term-10"><code class="docutils literal"><span class="pre">#'([</span></code></dt>
<dd><p class="first">is used to create mappings out of single entries (with several values) like the <code class="docutils literal"><span class="pre">([</span> <span class="pre">])</span></code> in LPC. Very unusual is the fact that this closure gets arrays as argument that are not evaluated, although they are not quoted.:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="kt">lambda</span><span class="p">(</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="p">({</span>
    <span class="cp">#&#39;([,</span>
    <span class="p">({</span> <span class="s">&quot;x&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span> <span class="p">}),</span>
    <span class="p">({</span> <span class="s">&quot;y&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">})</span>
  <span class="p">})</span>
<span class="p">);</span>
</pre></div>
</div>
<p>This returns <code class="docutils literal"><span class="pre">([</span> <span class="pre">&quot;x&quot;:</span> <span class="pre">1;2;3,</span> <span class="pre">&quot;y&quot;:</span> <span class="pre">4;5;6</span> <span class="pre">])</span></code>.</p>
<p>However, the elements of the arrays are evaluated as lambda expressions, so if you want to create a mapping from values evaluated at call time, write them as lambda closures:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(0, ({ #&#39;([, ({ 1, ({ #&#39;ctime }) }) }) )
</pre></div>
</div>
<p>will return <code class="docutils literal"><span class="pre">([</span> <span class="pre">1:</span> <span class="pre">&lt;result</span> <span class="pre">of</span> <span class="pre">ctime()</span> <span class="pre">at</span> <span class="pre">call</span> <span class="pre">time&gt;</span> <span class="pre">])</span></code>.</p>
<p>Arrays can be put into the mapping by quoting:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>lambda(0, ({ #&#39;([, ({ 1, &#39;({ 2 }) }) }) )
</pre></div>
</div>
<p class="last">will return <code class="docutils literal"><span class="pre">([</span> <span class="pre">1:</span> <span class="pre">({</span> <span class="pre">2</span> <span class="pre">})</span> <span class="pre">])</span></code></p>
</dd>
<dt id="term-11"><code class="docutils literal"><span class="pre">#'[,]</span></code></dt>
<dd><p class="first">is nearly the same as <code class="docutils literal"><span class="pre">#'[</span></code>. The only difference shows up if you want to index a mapping with a width greater than 1 (with more than just one value per key) directly with <a class="reference internal" href="../efun/funcall.html#lpc.efun.funcall" title="funcall"><code class="xref lpc lpc-efun docutils literal"><span class="pre">funcall</span></code>(E)</a>. Example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>funcall(#&#39;[,([ 0:1;2, 3:4;5 ]),0,1)
</pre></div>
</div>
<p class="last">This will not work. Use <code class="docutils literal"><span class="pre">#'[,]</span></code> and it will work. If you want to use it in a lambda closure you do not have to use <code class="docutils literal"><span class="pre">#'[,]</span></code> and <code class="docutils literal"><span class="pre">#'[</span></code> will do fine. On the other hand, <code class="docutils literal"><span class="pre">#'[,]</span></code> cannot work with arrays, so in nearly all cases use <code class="docutils literal"><span class="pre">#'[</span></code> and just in the described special case, use <code class="docutils literal"><span class="pre">#'[,]</span></code>. This is a strange thing and I deem it a bug, so it might change in the future.</p>
</dd>
</dl>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id12">Operator-Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Most of the closures that are used for things which are done by operators are in fact not operator-closures but efun-closures. But there are a few which do not have the state of efun-closures but are called &#8220;operator-closures&#8221;. <code class="docutils literal"><span class="pre">#'return</span></code> is an example, a complete list of them is given below.</p>
<p>These closures cannot be called directly using <a class="reference internal" href="../efun/funcall.html#lpc.efun.funcall" title="funcall"><code class="xref lpc lpc-efun docutils literal"><span class="pre">funcall</span></code>(E)</a> or <a class="reference internal" href="../efun/apply.html#lpc.efun.apply" title="apply"><code class="xref lpc lpc-efun docutils literal"><span class="pre">apply</span></code>(E)</a> (or other efuns like <a class="reference internal" href="../efun/filter.html#lpc.efun.filter" title="filter"><code class="xref lpc lpc-efun docutils literal"><span class="pre">filter</span></code>(E)</a>), but must appear only in lambda-constructs.</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>funcall(#&#39;return,4);  // does not work! This will raise an Uncallable-closure error.
funcall(lambda(0, ({ (#&#39;return),4 }) ));   // this is a correct example
</pre></div>
</div>
<p>All operator-closures:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="cp">#&#39;&amp;&amp;</span>
<span class="cp">#&#39;||</span>
<span class="cp">#&#39;,</span>
<span class="cp">#&#39;?</span>
<span class="cp">#&#39;?!</span>
<span class="cp">#&#39;=</span>
<span class="cp">#&#39;&lt;op&gt;=</span>
<span class="cp">#&#39;++</span>
<span class="cp">#&#39;--</span>
<span class="cp">#&#39;break</span>
<span class="cp">#&#39;catch</span>
<span class="cp">#&#39;continue</span>
<span class="cp">#&#39;default</span>
<span class="cp">#&#39;do</span>
<span class="cp">#&#39;foreach</span>
<span class="cp">#&#39;return</span>
<span class="cp">#&#39;sscanf</span>
<span class="cp">#&#39;switch</span>
<span class="cp">#&#39;while</span>
<span class="cp">#&#39;({</span>
<span class="cp">#&#39;([</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">#'..</span></code> is very likely to be an operator closure too, but since it is not implemented yet, I cannot say for sure.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id13">Variable-Closures</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>All object-global variables might be &#8220;closured&#8221; by prepending a <code class="docutils literal"><span class="pre">#'</span></code> to them to allow access and/or manipulation of them. So if your object has a global variable x you can use <code class="docutils literal"><span class="pre">#'x</span></code> within a closure.</p>
<p>Normally you will treat those expressions like lfun-closures: put them into an array to get the value:</p>
<p>Anybody who now calls <code class="docutils literal"><span class="pre">object-&gt;foo()</span></code> will get a closure which will, when evaluated, write the actual value of object&#8217;s global variable x.</p>
<p>Variable closures do not accept arguments.</p>
</div>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h2><a class="toc-backref" href="#id14">Examples</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h2>
<p>In this section I will give and explain some examples coming out of praxis. If the explanation seems to be in some cases too detailed this can be explained by the trial to allow the reader to read the examples section first ;-)</p>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id15">Lfun-Closure</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>An item with a complex long-description like a watch that shall always show the actual time will usually base upon the complex/item-class and give an lfun-closure as argument to the <code class="docutils literal"><span class="pre">set_long()</span></code> method.</p>
<div class="literal-block-wrapper container" id="id1">
<div class="code-block-caption"><span class="caption-text">watch.c</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span>inherit &quot;complex/item&quot;;

string my_long() {
  return (&quot;The watch is small and has a strange otherworldly&quot;
    &quot; aura about it.\n&quot;
    &quot;The current time is: &quot;+ctime()+&quot;.\n&quot;);
}

void create() {
  set_short(&quot;a little watch&quot;);
  set_id(({ &quot;watch&quot;,&quot;little watch&quot; }));
  set_long(#&#39;my_long);  // the lfun-closure to the lfun my_long()
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3><a class="toc-backref" href="#id16">Lambda-Closure</a><a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The example from 3.1 can also be written using a lambda-closure.</p>
<div class="literal-block-wrapper container" id="id2">
<div class="code-block-caption"><span class="caption-text">watch-lambda.c</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span>inherit &quot;complex/item&quot;;

void create() {
  set_short(&quot;a little watch&quot;);
  set_id(({ &quot;watch&quot;,&quot;little watch&quot; }));
  set_long(lambda(
    0,
    ({
      (#&#39;+),
      &quot;The watch is small and has a strange&quot;
      &quot; otherworldly aura about it.\n&quot;
      &quot;The current time is: &quot;,
      ({
        (#&#39;+),
        ({ (#&#39;ctime) }),
        &quot;.\n&quot;
      })
    })
  ));
}
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Guide to closures</a><ul>
<li><a class="reference internal" href="#l">Overview and efun-closures</a></li>
<li><a class="reference internal" href="#l">Lfun- and Lambda-Closures</a><ul>
<li><a class="reference internal" href="#l">Lfun-Closures</a></li>
<li><a class="reference internal" href="#l">Inline Closures</a></li>
<li><a class="reference internal" href="#l">Lambda-Closures</a><ul>
<li><a class="reference internal" href="#l">Advantages of Lambda Closures</a></li>
<li><a class="reference internal" href="#l">Free Variables in Lambda-Closure Constructs</a></li>
<li><a class="reference internal" href="#l">Special Efun-Closures and Operator-Closures for Lambdas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#Closures with Strange Names">Closures with Strange Names</a></li>
<li><a class="reference internal" href="#l">Operator-Closures</a></li>
<li><a class="reference internal" href="#l">Variable-Closures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#l">Examples</a><ul>
<li><a class="reference internal" href="#l">Lfun-Closure</a></li>
<li><a class="reference internal" href="#l">Lambda-Closure</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../admin/overview.html">Administrating an ldmud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applied/overview.html">Driver-applied methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../efun/overview.html">External functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hook/overview.html">Driver-supported hooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internals/overview.html">Driver-internal docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../master/overview.html">Master-object methods</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="overview.html">LPC syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/overview.html">Other topics</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;good question.
      
      |
      <a href="../_sources/syntax/closure_guide.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>