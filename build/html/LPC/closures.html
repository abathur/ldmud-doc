<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>closures &mdash; LDMud UNRELEASED documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'UNRELEASED',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="LDMud UNRELEASED documentation" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="closures">
<div class="section" id="SYNOPSIS">
<h2>SYNOPSIS<a class="headerlink" href="#SYNOPSIS" title="Permalink to this headline">¶</a></h2>
<p id="lpc.closures">closures</p>
</div>
<div class="section" id="DESCRIPTION">
<h2>DESCRIPTION<a class="headerlink" href="#DESCRIPTION" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Is there a better way to structure the various closure documents so that there&#8217;s a single topical heading? Or is that the job of a :topics: or :tags: option?</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the official man page concerning closures. If you find
it hard to read maybe the Closure Guide is an easier introduction
for you: See <span class="xref lpc lpc-lang">closure_guide</span> and <strong class="xref lpc lpc-topic">closures-example</strong>.</p>
</div>
<p>Closures provide a means of creating code dynamically and
passing pieces of code as parameters, storing them in
variables. One might think of them as a very advanced form of
process_string(). However, this falls short of what you can
actually do with them.</p>
<p>The simplest kind of closures are efuns, lfuns or operators.
For example, #&#8217;this_player is an example of a closure. You can
assign it to a variable as in:</p>
<div class="highlight-c"><div class="highlight"><pre>closure f;
object p;
f = #&#39;this_player;
</pre></div>
</div>
<p>and later use either the funcall() or apply() efun to evaluate
it. Like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">funcall</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<p>In both cases there p will afterwards hold the value of
this_player().  Of course, this is only a rather simple
application.</p>
<p>Inline closures are a variant of lfun closures, the difference
being that the function text is written right where the
closure is used.  Since they are pretty powerful by
themselves, inline closures have their own manpage.</p>
<p>More useful instances of closures can be created
using the lambda() efun. It is much like the lambda function
in LISP. For example, you can do the following:</p>
<div class="highlight-c"><div class="highlight"><pre>f = lambda( ({ &#39;x }), ({ #&#39;environment, &#39;x }) );
</pre></div>
</div>
<p>This will create a lambda closure and assign it to f. The
first argument to lambda is an array describing the arguments
(symbols) passed to the closure upon evaluation by funcall()
or apply(). You can now evaluate f, for example by means of
funcall(f,this_object()). This will result in the following
steps:</p>
<ol class="arabic simple">
<li>The value of this_object() will be bound to symbol x.</li>
<li>environment(x) evaluates to environment(this_object())
and is returned as the result of the funcall().</li>
</ol>
<p>One might wonder why there are two functions, funcall() and
apply(), to perform the seemingly same job, namely evaluating
a closure. Of course there is a subtle difference. If the last
argument to apply() is an array, then each of its elements
gets expanded to an additional paramater. The obvious use
would be #&#8217;call_other as in:</p>
<div class="highlight-c"><div class="highlight"><pre>mixed eval(object ob,string func,mixed *args) {
  return apply(#&#39;call_other,ob,func,args);
}
</pre></div>
</div>
<p>This will result in calling
<code class="docutils literal"><span class="pre">ob-&gt;func(args[0],args[1],...,args[sizeof(args)-1])</span></code>.  Using
<code class="xref lpc lpc-efun docutils literal"><span class="pre">funcall</span> <span class="pre">instead</span> <span class="pre">of</span> <span class="pre">:efun:`apply</span></code> would have given us
<code class="docutils literal"><span class="pre">ob-&gt;func(args)</span></code>.</p>
<p>Of course, besides efuns there are closures for <span class="xref lpc lpc-lang">operators</span>,
like #&#8217;+, &#8216;-, #&#8217;&lt;, #&#8217;&amp;&amp;, etc.</p>
<p>Well, so far closures have been pretty much limited despite
their obvious flexibility. This changes now with the
introduction of conditional and loop operators. For example,
try:</p>
<div class="highlight-c"><div class="highlight"><pre>closure max;
max = lambda( ({ &#39;x, &#39;y }),
              ({ #&#39;? ,({ #&#39;&gt;, &#39;x, &#39;y }), &#39;x, &#39;y }) );
return funcall(max,7,3);
</pre></div>
</div>
<p>The above example will return 7. What happened? Of course #&#8217;?
is the conditional operator and its &#8216;syntax&#8217; is as follows:</p>
<div class="highlight-c"><div class="highlight"><pre>({ #&#39;?, cond1, val1, cond2, val2, ..., condn, valn,
  valdefault });
</pre></div>
</div>
<p>It evaluates cond1, cond2, ..., condn successively until it
gets a nonzero result and then returns the corresponding
value. If there is no condition evaluating to a nonzero
result, valdefault gets returned. If valdefault is omitted, 0
gets returned. #&#8217;?! works just like #&#8217;?, except that the !
operator is applied to conditions before testing. Therefore,
while #&#8217;? is somewhat like an if statement, #&#8217;?! resembles an
if_not statement if there were one.</p>
<p>There are also loops:</p>
<div class="highlight-c"><div class="highlight"><pre>({ #&#39;do, loopbody1, ..., loopbodyN, loopcond, loopresult })
</pre></div>
</div>
<p>will evaluate the loopbodies until loopcond evaluates to 0 and
then return the value of loopresult. Symbols may be used as
variables, of course.:</p>
<div class="highlight-c"><div class="highlight"><pre>({ #&#39;while, loopcond, loopresult, loopbody1, ..., loopbodyN })
</pre></div>
</div>
<p>works similar but evaluates loopcond before the loopbodies.</p>
<p>The foreach() loop also exists:</p>
<div class="highlight-c"><div class="highlight"><pre>({ #&#39;foreach, &#39;var, expr, loopbody1, ..., loopbodyN })
({ #&#39;foreach, ({ &#39;var1, ..., &#39;varN}) , expr
                        , loopbody1, ..., loopbodyN })
</pre></div>
</div>
<p>Now on to a couple of tricky things:</p>
<ol class="loweralpha">
<li><p class="first">How do I write down an array within a lambda closure to
avoid interpretation as a subclosure?</p>
<p><code class="docutils literal"><span class="pre">({</span> <span class="pre">#'member,</span> <span class="pre">({</span> <span class="pre">&quot;abc&quot;,</span> <span class="pre">&quot;xyz&quot;</span> <span class="pre">}),</span> <span class="pre">'x</span> <span class="pre">})</span></code> will obviously
result in an error as soon as lambda() tries to interpret
&#8220;abc&#8221; as a closure operator. The solution is to quote the
array, as in: <code class="docutils literal"><span class="pre">({</span> <span class="pre">#'member,</span> <span class="pre">'({</span> <span class="pre">&quot;abc&quot;,</span> <span class="pre">&quot;xyz&quot;</span> <span class="pre">}),</span> <span class="pre">'x</span> <span class="pre">})</span></code>.
Applying <a class="reference internal" href="../efun/lambda.html#lpc.lambda" title="lambda"><code class="xref lpc lpc-efun docutils literal"><span class="pre">lambda</span></code>(E)</a> to this will not result in an error.
Instead, the quote will be stripped from the array and the
result regarded as a normal array literal. The same can be
achieved by using <a class="reference internal" href="../efun/quote.html#lpc.quote" title="quote"><code class="xref lpc lpc-efun docutils literal"><span class="pre">quote</span></code>(E)</a>, e.g.:</p>
<div class="highlight-c"><div class="highlight"><pre>({ #&#39;member, quote( ({ &quot;abc&quot;, &quot;xyz&quot; }), &#39;x ) })
</pre></div>
</div>
</li>
<li><p class="first">Isn&#8217;t it a security risk to pass, say, a closure to the
master object which then evaluates it with all the
permissions it got?</p>
<p>Luckily, no. Each closure gets upon compilation bound to
the object defining it. That means that executing it first
sets this_object() to the object that defined it and then
evaluates the closure. This also allows us to call lfuns
which might otherwise be undefined in the calling object.</p>
<p>There is however, a variant of lambda(), called
unbound_lambda(), which works similar but does not allow
the use of lfuns and does not bind the closure to the
defining object. The drawback is that trying to evaluate it
by apply() or funcall() will result in an error. The
closure first needs to be bound by calling bind_lambda().
bind_lambda() normally takes one argument and transforms an
unbound closure into a closure bound to the object
executing the bind_lambda().</p>
<p>Privileged objects, like the master and the simul_efun
object (or those authorized by the privilege_violation()
function in the master) may also give an object as the
second argument to bind_lambda(). This will bind the
closure to that object. A sample application is:</p>
<div class="highlight-c"><div class="highlight"><pre>dump_object(ob)
// will dump the variables of ob to /dump.o
{
  closure save;
  save = unbound_lambda( ({ }),
                         ({ #&#39;save_object, &quot;/open/dump&quot; }) );
  bind_lambda(save,ob);
  funcall(save);
}
</pre></div>
</div>
<p>bind_lambda() can also be used with efun closures.</p>
</li>
<li><p class="first">It might be an interesting application to create closures
dynamically as an alternative to writing LPC code to a file
and then loading it. However, how do I avoid doing exactly
that if I need symbols like &#8216;x or &#8216;y?</p>
<p>To do that one uses the quote() efun. It takes a string as
its argument and transforms it into a symbol. For example,
writing quote(&#8220;x&#8221;) is exactly the same as writing &#8216;x.</p>
</li>
<li><p class="first">How do I test if a variable holds a closure?</p>
<p>Use the closurep() efun which works like all the other type
testing efuns. For symbols there is also symbolp()
available.</p>
</li>
<li><p class="first">That means, I can do:
<code class="docutils literal"><span class="pre">if</span> <span class="pre">(closurep(f))</span> <span class="pre">return</span> <span class="pre">funcall(f);</span> <span class="pre">else</span> <span class="pre">return</span> <span class="pre">f;</span></code> ?</p>
<p>Yes, but in the case of funcall() it is unnecessary. If
funcall() gets only one argument and it is not a closure it
will be returned unchanged. So return funcall(f); would
suffice.</p>
</li>
<li><p class="first">I want to use a function in some object as a closure. How do I do
that?</p>
<p>There are several ways. If the function resides in
this_object(), just use #&#8217;func_name. If not, or if you want
to create the function dnynamically, use the efun
symbol_function(). It takes a string as it first and an
object as its second argument and returns a closure which
upon evaluation calls the given function in the given
object (and faster than call_other(), too, if done from
inside a loop, since function search will be done only when
calling symbol_function().</p>
</li>
<li><p class="first">Can I create efun closures dynamically, too?</p>
<p>Yes, just use symbol_function() with a single argument.
Most useful for marker objects and the like. But
theoretically a security risk if not used properly and from
inside a security relevant object.  Take care, however,
that, if there is a simul_efun with the same name, it will
be preferred as in the case of #&#8217;function. Use the efun::
modifier to get the efun if you need it.</p>
</li>
<li><p class="first">Are there other uses of closures except using them to store
code?</p>
<p>Lots. For example, you can use them within almost all of
the efuns where you give a function as an argument, like
filter(), sort_array() or walk_mapping().
sort_array(array,#&#8217;&gt;) does indeed what is expected. Another
application is set_prompt(), where a closure can output
your own prompt based on the current time and other stuff
which changes all the time.</p>
</li>
</ol>
<p>Finally, there are some special efun/operator closures:</p>
<p>#&#8217;[ : indexes an array.
#&#8217;[&lt; : does the same, but starting at the end.
#&#8217;[..] : gets an array and two numbers</p>
<blockquote>
<div>and returns a sub-array.</div></blockquote>
<dl class="docutils">
<dt>#&#8217;[..&lt;] <span class="classifier-delimiter">:</span> <span class="classifier">same as above but the second index is</span></dt>
<dd>interpreted as counted from the left end.</dd>
</dl>
<p>#&#8217;[&lt;..]  and
#&#8217;[&lt;..&lt;] : should be clear now.
#&#8217;[.. : takes only one index and returns the sub-</p>
<blockquote>
<div>array from this index to the end.</div></blockquote>
<dl class="docutils">
<dt>#&#8217;[&lt;.. <span class="classifier-delimiter">:</span> <span class="classifier">same as above but the index is interpreted</span></dt>
<dd>as counted from the left end.</dd>
</dl>
<p>#&#8217;({ : puts all arguments into an array.
#&#8217;([ : gets an unquoted (!) array which must include</p>
<blockquote>
<div>at least one element as argument and returns a mapping of
the width of the given array&#8217;s size with one entry that
contains the first element as key and the other elements
as values to the key.</div></blockquote>
<p>#&#8217;negate is for unary minus.
#&#8217;, may be followed by any number of closures,
e.g.: ({ (#&#8217;,),</p>
<blockquote>
<div>({#&#8217;= &#8216;h, &#8216;a, }), ({#&#8217;=, &#8216;a, &#8216;b }), ({#&#8217;=, &#8216;b, &#8216;h }) })</div></blockquote>
<p>will swap &#8216;a and &#8216;b when compiled and executed.</p>
<div class="section" id="closures-abstract">
<span id="lpc.closures-abstract"></span><h3>CLOSURES-ABSTRACT<a class="headerlink" href="#closures-abstract" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">in the original docs, there is a separate file (closures-abstract) with a copy of the content in this section. Assuming we want to preserve it as an artifact, I&#8217;m still looking for a good way to advertise its presence. This may get resolved through the general process of cleaning up how closures is structured.</p>
</div>
<div class="section" id="Procedural elements:">
<span id="lpc.Procedural elements:"></span><h4>PROCEDURAL ELEMENTS:<a class="headerlink" href="#Procedural elements:" title="Permalink to this headline">¶</a></h4>
<p>definition of terms:
&lt;block&gt;</p>
<blockquote>
<div>zero or more values to be evaluated.</div></blockquote>
<dl class="docutils">
<dt>&lt;test&gt;</dt>
<dd>one value to be evaluated as branch or loop condition.</dd>
<dt>&lt;result&gt;</dt>
<dd>one value to be evaluated at the end of the
execution of the form; the value is returned.</dd>
<dt>&lt;lvalue&gt;</dt>
<dd>local variable/parameter, global variable, or an
indexed lvalue.</dd>
</dl>
<p>used EBNF operators:
{ }     iteration
[ ]     option</p>
<dl class="docutils">
<dt>forms:</dt>
<dd><p class="first">({#&#8217;, &lt;body&gt; &lt;result&gt;})
({#&#8217;? { &lt;test&gt; &lt;result&gt; } [ &lt;result&gt; ] })
({#&#8217;?! { &lt;test&gt; &lt;result&gt; } [ &lt;result&gt; ] })
({#&#8217;&amp;&amp; { test } })
({#&#8217;|| { test } })
({#&#8217;while &lt;test&gt; &lt;result&gt; &lt;body&gt;})    loop while test</p>
<blockquote>
<div>evaluates non-zero.</div></blockquote>
<dl class="last docutils">
<dt>({#&#8217;do &lt;body&gt; &lt;test&gt; &lt;result&gt;})       loop till test</dt>
<dd>evaluates zero.</dd>
<dt>({#&#8217;= { &lt;lvalue&gt; &lt;value&gt; } })         assignment</dt>
<dd>other assignment
operators work, too.</dd>
</dl>
</dd>
<dt>lisp similars:</dt>
<dd>#&#8217;,           progn
#&#8217;?           cond
#&#8217;&amp;&amp;          and
#&#8217;||          or
#&#8217;while       do      /* but lisp has more syntactic candy here <a href="#id1"><span class="problematic" id="id2">*</span></a>/
#&#8217;=           setq</dd>
</dl>
<p>A parameter / local variable &#8216;foo&#8217; is referenced as &#8216;foo , a
global variable as ({#&#8217;foo}) . In lvalue positions
(assignment), you need not enclose global variable closures in
arrays.</p>
<p>Call by reference parameters are given with ({#&#8217;&amp;, &lt;lvalue&gt;})</p>
<p>Some special efuns:
#&#8217;[             indexing
#&#8217;[&lt;            indexing from the end
#&#8217;negate        unary -</p>
</div>
<div class="section" id="Unbound lambda closures">
<span id="lpc.Unbound lambda closures"></span><h4>UNBOUND LAMBDA CLOSURES<a class="headerlink" href="#Unbound lambda closures" title="Permalink to this headline">¶</a></h4>
<p>These closures are not bound to any object. They are created
with the efun unbound_lambda() . They cannot contain
references to global variables, and all lfun closures are
inserted as is, since there is no native object for this
closure.  You can bind and rebind unbound lambda closures to
an object with efun bind_lambda() You need to bind it before
it can be called. Ordinary objects can obly bind to
themselves, binding to other objects causes a privilege
violation().  The point is that previous_object for calls done
from inside the closure will reflect the object doing
bind_lambda(), and all object / uid based security will also
refer to this object.</p>
</div>
</div>
<div class="section" id="AUTHORS">
<span id="lpc.AUTHORS"></span><h3>AUTHORS<a class="headerlink" href="#AUTHORS" title="Permalink to this headline">¶</a></h3>
<p>MacBeth, Amylaar, Hyp</p>
</div>
<h2 id="see2also">SEE ALSO<a class="headerlink" href="#DESCRIPTION" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#lpc.closures-abstract" title="closures-abstract"><strong class="xref lpc lpc-topic">closures-abstract</strong></a>, <strong class="xref lpc lpc-topic">closures-example</strong>, <span class="xref lpc lpc-lang">closure_guide</span>, <a class="reference internal" href="inline-closures.html#lpc.inline-closures" title="inline-closures"><span class="xref lpc lpc-lang">inline-closures</span>(LPC)</a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">closures</a><ul>
<li><a class="reference internal" href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a class="reference internal" href="#DESCRIPTION">DESCRIPTION</a><ul>
<li><a class="reference internal" href="#closures-abstract">CLOSURES-ABSTRACT</a><ul>
<li><a class="reference internal" href="#Procedural elements:">PROCEDURAL ELEMENTS:</a></li>
<li><a class="reference internal" href="#Unbound lambda closures">UNBOUND LAMBDA CLOSURES</a></li>
</ul>
</li>
<li><a class="reference internal" href="#AUTHORS">AUTHORS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hook/hook.html">hooks</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;good question.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="../_sources/LPC/closures.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>