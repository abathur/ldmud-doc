<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A step-by-step introduction to mappings &mdash; LDMud UNRELEASED documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'UNRELEASED',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="LDMud UNRELEASED documentation" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="A step-by-step introduction to mappings">
<span id="lpc.A step-by-step introduction to mappings"></span><div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#Introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#What are mappings good for?" id="id2">WHAT ARE MAPPINGS GOOD FOR?</a></li>
<li><a class="reference internal" href="#How do I create a mapping?" id="id3">HOW DO I CREATE A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I modify the data of a mapping?" id="id4">HOW CAN I MODIFY THE DATA OF A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I access the data stored in a mapping?" id="id5">HOW CAN I ACCESS THE DATA STORED IN A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I test for the existance of a key?" id="id6">HOW CAN I TEST FOR THE EXISTANCE OF A KEY?</a></li>
<li><a class="reference internal" href="#How can I copy a mapping?" id="id7">HOW CAN I COPY A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I get all keys of a mapping?" id="id8">HOW CAN I GET ALL KEYS OF A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I get all the values of a mapping?" id="id9">HOW CAN I GET ALL THE VALUES OF A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I determine the size of a mapping?" id="id10">HOW CAN I DETERMINE THE SIZE OF A MAPPING?</a></li>
<li><a class="reference internal" href="#What is the best method to iterate over a mapping?" id="id11">WHAT IS THE BEST METHOD TO ITERATE OVER A MAPPING?</a></li>
<li><a class="reference internal" href="#Is it possible to join/intersect/cut mappings with another?" id="id12">IS IT POSSIBLE TO JOIN/INTERSECT/CUT MAPPINGS WITH ANOTHER?</a></li>
<li><a class="reference internal" href="#What are those mappings without any values (besides keys) good for?" id="id13">WHAT ARE THOSE MAPPINGS WITHOUT ANY VALUES (BESIDES KEYS) GOOD FOR?</a></li>
<li><a class="reference internal" href="#How can I convert an alist into a  mapping and vice versa?" id="id14">HOW CAN I CONVERT AN ALIST INTO A  MAPPING AND VICE VERSA?</a></li>
<li><a class="reference internal" href="#Dirty Mappings" id="id15">DIRTY MAPPINGS</a></li>
<li><a class="reference internal" href="#HISTORY" id="id16">HISTORY</a></li>
<li><a class="reference internal" href="#LAST UPDATE" id="id17">LAST UPDATE</a></li>
<li><a class="reference internal" href="#see2also" id="id18">SEE ALSO</a></li>
</ul>
</div>
<div class="section" id="Introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#Introduction" title="Permalink to this headline">¶</a></h2>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">this was plaintext-justified; need to fix errant spaces</p>
</div>
<p>A mapping is a datatype which allows to store data associated to a key.
In other languages  they are also  known  as &#8216;dictionaries&#8217; or  &#8216;alists&#8217;.
There are also alists in LPC but they are not a separate datatype but are
implemented on  top of arrays.  Alists are  the predecessors of mappings.
The keys and the values  can be of  any type.  But most common  datatypes
for keys are strings, integers and objects.  Others like arrays, mappings
or closures aren&#8217;t a good choice because comparision between i.e.  arrays
often returns false  even if they equal  in content.  This is because the
driver compares i.e. two arrays by their internal pointers and not by
their content. The reason for this is simple: speed.</p>
<p>Mappings  are allways  treated  as references    when passing  them  to
functions. This means when you pass a mapping  to another object and this
object modifies the mapping the modification will  take place in a global
scope - visible to all objects holding this mapping in a variable.</p>
<div class="section" id="What are mappings good for?">
<span id="lpc.What are mappings good for?"></span><h2><a class="toc-backref" href="#id2">WHAT ARE MAPPINGS GOOD FOR?</a><a class="headerlink" href="#What are mappings good for?" title="Permalink to this headline">¶</a></h2>
<p>The term &#8216;dictionary&#8217;  probably describes the  use  of a mapping  best.
Opposed  to arrays mappings don&#8217;t have  a specific  order. They provide a
mechanism to   create  a set  of associations  between  values.  Such  an
association consists of a unique  key and data  that is identified by the
key. Think of  a dictionary  where you have  a  word and a definition  of
it. You use the word to lookup its definition.</p>
<p>Mappings can be used i.e.  to hold  aliases for commands. The key would
then be the  name of  the alias and  the  data the command(s) behind   an
alias.  Or they can be used for  the exits of a  room.  The keys would be
the directions where one can go  to and the associated  data would be the
file names of the  rooms.  But mappings can  also be used  as a kind of a
sparse array.   A  sparse array is  an  array where most of  the elements
aren&#8217;t used  (occupied by 0).  I.e.  if  you want to  store values at the
position 0, 13  and 37642 of an  array you would  have to create an array
with a size of at least 37643.  This  costs a lot  of memory so a mapping
would be  more useful because you would  then use the  numbers 0,  13 and
37642 as a key and not as an index to a position  (actually the keys of a
mapping are sometimes  called indices  but this  is just  because the way
data is accessed in a mapping is similar to  arrays: by the [] operator).
This also allows to  query all occupied   positions of a sparse array  by
querying for all  the keys of  the mapping opposed  to an array where you
have to iterate over all elements.</p>
</div>
<div class="section" id="How do I create a mapping?">
<span id="lpc.How do I create a mapping?"></span><h2><a class="toc-backref" href="#id3">HOW DO I CREATE A MAPPING?</a><a class="headerlink" href="#How do I create a mapping?" title="Permalink to this headline">¶</a></h2>
<p>There are several ways to do so. The most convenient is the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">mapping</span> <span class="n">map</span><span class="p">;</span>
<span class="n">map</span> <span class="o">=</span> <span class="p">([</span> <span class="nl">key0</span><span class="p">:</span> <span class="n">value00</span><span class="p">;</span> <span class="p">...;</span> <span class="n">value0n</span><span class="p">,</span>
         <span class="p">...</span> <span class="o">:</span> <span class="p">...</span>    <span class="p">;</span> <span class="p">...;</span> <span class="p">...</span>    <span class="p">,</span>
         <span class="nl">keyn</span><span class="p">:</span> <span class="n">valuen0</span><span class="p">;</span> <span class="p">...;</span> <span class="n">valuenn</span> <span class="p">]);</span>
</pre></div>
</div>
<p>As you can see, a key may  have more than  one value assigned.  But the
amount of values per key must always be equal.  It  is  even  possible to
have mappings without any values!</p>
<p>Another  method is  to use the   efun mkmapping().  This  efun gets two
arguments with the first beeing an array of keys and the following beeing
arrays of values:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">mapping</span> <span class="n">map</span><span class="p">;</span>
<span class="n">map</span> <span class="o">=</span> <span class="n">mkmapping</span> <span class="p">(({</span> <span class="n">key0</span>   <span class="p">,</span> <span class="p">...,</span> <span class="n">keyn</span>    <span class="p">}),</span>
                 <span class="p">({</span> <span class="n">value00</span><span class="p">,</span> <span class="p">...,</span> <span class="n">value0n</span> <span class="p">}),</span>
                 <span class="p">({</span> <span class="p">...</span>    <span class="p">,</span> <span class="p">...,</span> <span class="p">...</span>     <span class="p">}),</span>
                 <span class="p">({</span> <span class="n">valuen0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">valuenn</span> <span class="p">}));</span>
</pre></div>
</div>
<p>If the efun only gets one argument, then this argument will be taken as
an array of keys and a mapping  without values will  be returned.</p>
<p>An empty mapping can be created by using the above described methods by
simply ommitting the keys and values:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">mapping</span> <span class="n">map</span><span class="p">;</span>
<span class="n">map</span> <span class="o">=</span> <span class="p">([]);</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">=</span> <span class="n">mkmapping</span><span class="p">(({}),</span> <span class="p">({}));</span>
</pre></div>
</div>
<p>Or  by  using the efun   m_allocate().  This efun gets  as  first
argument the  amount  of keys which will  be  added soon and  an optional
second argument specifying the width of the mapping:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">=</span> <span class="n">m_allocate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</pre></div>
</div>
<p>The value &lt;n&gt;  may be a bit  confusing  since mappings shrink and  grow
dynamically. This value just tells the driver how &#8216;long&#8217; this  mapping is
going to be  so proper memory  allocations  will be  performed to  reduce
the overhead of memory reallocation.  I.e.  if you want to read in a file
and store the  read data in  a mapping  you probably  know  the amount of
keys.  So you allocate  a mapping with this  efun and tell the driver how
much memory should  be allocated  by specifing  a proper &lt;n&gt;  value.
Thus causing  a    speedup when adding  the  read   data to the   mapping
afterwards.    The &lt;width&gt; just specifies how   many  values per key this
mapping is   going to have. If  no  width is given, 1  will  be  taken as
default.</p>
<p>An empty mapping created with &#8216;([])&#8217; will always have a width of 1. To
create empty mappings with other widths, write it as:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">=</span> <span class="p">([</span><span class="o">:</span><span class="n">width</span> <span class="p">]);</span>
</pre></div>
</div>
<p>&lt;width&gt; can be any expression returning an integer value (including
function calls), and in fact this notation is just a fancy way of
writing:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">=</span> <span class="n">m_allocate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="How can I modify the data of a mapping?">
<span id="lpc.How can I modify the data of a mapping?"></span><h2><a class="toc-backref" href="#id4">HOW CAN I MODIFY THE DATA OF A MAPPING?</a><a class="headerlink" href="#How can I modify the data of a mapping?" title="Permalink to this headline">¶</a></h2>
<p>Adding a  new key is similiar to   modifying the associated  data of an
existing key:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">+=</span> <span class="p">([</span> <span class="nl">key</span><span class="p">:</span> <span class="n">value0</span><span class="p">;</span> <span class="p">...;</span> <span class="n">valuen</span> <span class="p">]);</span>
</pre></div>
</div>
<p>Or in case only a single value should be modified:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">valuen</span><span class="p">;</span>
</pre></div>
</div>
<p>If  &lt;n&gt; is out of  range or if &lt;key&gt; doesn&#8217;t  exists and &lt;n&gt; is greater
than 0 an &#8220;Illegal index&#8221; error will be reported. If &lt;n&gt; is equal to 0 or
the mapping only has a single value per key one can abbreviate it with:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</pre></div>
</div>
<p>If there is no &lt;key&gt; (and &lt;n&gt; is equal to 0 or  not specified at all) a
new one will be added automatically.</p>
<p>Deletion   of a key    is  done with    the  -=  operator or  the  efun
m_delete(). A mapping can only be substracted by one without any values:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">-=</span> <span class="p">([</span> <span class="n">key</span> <span class="p">]);</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">-=</span> <span class="p">([</span> <span class="n">key0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">keyn</span> <span class="p">]);</span>
</pre></div>
</div>
<p>The efun takes a mapping as first and a key as second argument:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">m_delete</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</pre></div>
</div>
<p>The  efun   m_delete() returns  the mapping   but because  mappings are
handled as references there is no need of an assignment like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">=</span> <span class="n">m_delete</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="How can I access the data stored in a mapping?">
<span id="lpc.How can I access the data stored in a mapping?"></span><h2><a class="toc-backref" href="#id5">HOW CAN I ACCESS THE DATA STORED IN A MAPPING?</a><a class="headerlink" href="#How can I access the data stored in a mapping?" title="Permalink to this headline">¶</a></h2>
<p>This can be done by:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">valuen</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">];</span>
</pre></div>
</div>
<p>Or in case of a mapping with just one value per key:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">value0</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</pre></div>
</div>
<p>If there is no  &lt;key&gt; in the mapping  and &lt;n&gt; is  0 or not specified at
all (which is the same) a 0 will be returned or if &lt;n&gt;  is greater than 0
an &#8220;Illegal index&#8221; error will be reported.</p>
</div>
<div class="section" id="How can I test for the existance of a key?">
<span id="lpc.How can I test for the existance of a key?"></span><h2><a class="toc-backref" href="#id6">HOW CAN I TEST FOR THE EXISTANCE OF A KEY?</a><a class="headerlink" href="#How can I test for the existance of a key?" title="Permalink to this headline">¶</a></h2>
<p>A  return value of 0 is  sufficient for most applications but sometimes
the ambiguity  between an existing value of  0 and  a nonexisting key can
lead   to  a  problem.  Therefore   one  can use   the  efun member()  or
mapping_contains() to check if there actually is a key in the mapping:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">member</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">mapping_contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value0</span><span class="p">,</span> <span class="p">...,</span> <span class="o">&amp;</span><span class="n">valuen</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This also shows how  one can retrieve all values   associated to a  key
from a mapping in a single step. The &#8216;&amp;&#8217; is  the reference operator which
is neccesary to let the efun store the values in the variables.</p>
<p>In case   of  mappings   with   no  values,   the  efun   member()  and
mapping_contains() are equal in their behaviour  and their way of calling
because mapping_contains() won&#8217;t get any reference variables to store the
values in (obviously, because there aren&#8217;t any).</p>
<p>Also normally member() is known to return the postion of an element in
a list (i.e.  a  character in a  string or data   in an array) and if  an
element couldn&#8217;t be  found -1 is returned.   But in the case  of mappings
there are no such things as order and postion. So member() only returns 0
or 1.</p>
</div>
<div class="section" id="How can I copy a mapping?">
<span id="lpc.How can I copy a mapping?"></span><h2><a class="toc-backref" href="#id7">HOW CAN I COPY A MAPPING?</a><a class="headerlink" href="#How can I copy a mapping?" title="Permalink to this headline">¶</a></h2>
<p>A  mapping can  be  copied   with  the  +  operator   or by the    efun
copy_mapping():</p>
<blockquote>
<div>newmap = ([]) + map;</div></blockquote>
<p>or:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">newmap</span> <span class="o">=</span> <span class="n">copy_mapping</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
</pre></div>
</div>
<p>A mapping should only be copied when it is neccesary to get an own copy
of it that  must not be  shared by other objects.</p>
</div>
<div class="section" id="How can I get all keys of a mapping?">
<span id="lpc.How can I get all keys of a mapping?"></span><h2><a class="toc-backref" href="#id8">HOW CAN I GET ALL KEYS OF A MAPPING?</a><a class="headerlink" href="#How can I get all keys of a mapping?" title="Permalink to this headline">¶</a></h2>
<p>The  efun m_indices() gets a mapping  as argument  and returns an array
holding all keys defined in this mapping:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">keys</span> <span class="o">=</span> <span class="n">m_indices</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="How can I get all the values of a mapping?">
<span id="lpc.How can I get all the values of a mapping?"></span><h2><a class="toc-backref" href="#id9">HOW CAN I GET ALL THE VALUES OF A MAPPING?</a><a class="headerlink" href="#How can I get all the values of a mapping?" title="Permalink to this headline">¶</a></h2>
<p>The efun m_values() gets  a mapping as  argument  and returns  an array
holding all the first (second, ...) values of it.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">values0</span> <span class="o">=</span> <span class="n">m_values</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>     <span class="n">returns</span> <span class="n">the</span> <span class="n">first</span> <span class="n">values</span>
<span class="n">values0</span> <span class="o">=</span> <span class="n">m_values</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="n">dito</span>
<span class="n">values1</span> <span class="o">=</span> <span class="n">m_values</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="n">returns</span> <span class="n">the</span> <span class="n">second</span> <span class="n">values</span>
  <span class="n">etc</span>
</pre></div>
</div>
</div>
<div class="section" id="How can I determine the size of a mapping?">
<span id="lpc.How can I determine the size of a mapping?"></span><h2><a class="toc-backref" href="#id10">HOW CAN I DETERMINE THE SIZE OF A MAPPING?</a><a class="headerlink" href="#How can I determine the size of a mapping?" title="Permalink to this headline">¶</a></h2>
<p>Because a mapping is a kind of rectangle it has two sizes: a length and
a width.  There are three different efuns  to query these values. The first
two are the  efuns sizeof(), which returns the  amount of key-value
associations (the length of  a mapping), and widthof(), which returns the
number of values per key (the width). The third is the efun get_type_info().
get_type_info() is meant  to be a function  to identify a datatype.   Its
return value is an  array of two  numerical values.  The first  specifies
the datatype   of the argument and   the second is a   datatype dependend
value. In the case of a mapping the first value  is T_MAPPING (which is a
value defined in  &lt;lpctypes.h&gt;) and the  second the amount of values  per
key (a.k.a.  columns or the width  of the mapping  - actually it would be
correct to say that the width of a mapping is the  amount of columns plus
one for the keys but this is uncommon).</p>
</div>
<div class="section" id="What is the best method to iterate over a mapping?">
<span id="lpc.What is the best method to iterate over a mapping?"></span><h2><a class="toc-backref" href="#id11">WHAT IS THE BEST METHOD TO ITERATE OVER A MAPPING?</a><a class="headerlink" href="#What is the best method to iterate over a mapping?" title="Permalink to this headline">¶</a></h2>
<p>First of all the main purpose of a mapping is not meant to  be a set of
data to iterate over. Afterall the keys in a mapping have no specific but
a random order (at least on the LPC side).  But  still it is possible and
sometimes even neccesary to do so.</p>
<p>If all key-value associations  should be processed  then one should use
walk_mapping().  If all keys of a mapping should be processed to create a
new mapping being a subset of the given one, then filter_mapping() should
be  used.  If all  keys  are going to  be  processed and  to create a new
mapping with the  same set of keys as  the given mapping, then one  would
use map_mapping().  But in the case of an  iteration that should/can stop
even if not all data is processed it is probably wise to iterate over the
mapping by first querying for the keys and then to iterate over them with
a for() or a while() loop and querying the values by &#8216;hand&#8217;.</p>
<p>The efun walk_mapping() gets  a mapping as  first argument and the name
of a function  as second one. All the  following arguments are treated as
extras which  will  be  passed to the   function specified  with the  2nd
argument. Instead of a string for the name of a function a closure can be
used, too. Nothing will be returned:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">...</span>
<span class="n">walk_mapping</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">&quot;func&quot;</span><span class="p">,</span> <span class="n">xarg0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">xargn</span><span class="p">);</span>
<span class="p">...</span>

<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">mixed</span> <span class="n">key</span><span class="p">,</span> <span class="n">mixed</span> <span class="n">value0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">mixed</span> <span class="n">valuen</span><span class="p">,</span>
          <span class="n">mixed</span> <span class="n">xarg0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">mixed</span> <span class="n">xargn</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>func() will be called for all key-value associations  and gets as first
argument the key.  The next arguments are the  values behind the key  and
are passed as references.  The  rest  of the  passed arguments are  those
specified as extras. Because the values are passed as references (opposed
to  copies) it is possible  to modify them  from  inside func() by simply
assigning new value to the variables &lt;value0&gt;, ..., &lt;valuen&gt;.</p>
<p>The efun filter_mapping() calls  a function for  each key in  a mapping
and creates a new mapping  which only contains key-value associations for
which the called function returned true (not  equal 0 that is). The first
argument is the mapping to iterate over and the second is a function name
given as a string or a closure:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">...</span>
<span class="n">submap</span> <span class="o">=</span> <span class="n">filter_mapping</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">&quot;func&quot;</span><span class="p">,</span> <span class="n">xarg0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">xargn</span><span class="p">);</span>
<span class="p">...</span>

<span class="kt">int</span> <span class="n">func</span><span class="p">(</span><span class="n">mixed</span> <span class="n">key</span><span class="p">,</span> <span class="n">mixed</span> <span class="n">xarg0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">mixed</span> <span class="n">xargn</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>func() gets  as first argument the key  and the others are those passed
as extras to filter_mapping().</p>
<p>The efun map_mapping() gets a mapping as first argument and a string as
a function name (or again a closure) as  second argument.  Any additional
arguments are again used  as extras that will  be passed to the iteration
function. This efun returns a new mapping with the same keys as the given
one.  The values  returned by the function  that is invoked  for each key
will be used as the associated data behind each key of the new mapping:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">...</span>
<span class="n">newmap</span> <span class="o">=</span> <span class="n">map_mapping</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">&quot;func&quot;</span><span class="p">,</span> <span class="n">xarg0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">xargn</span><span class="p">);</span>
<span class="p">...</span>

<span class="n">mixed</span> <span class="n">func</span><span class="p">(</span><span class="n">mixed</span> <span class="n">key</span><span class="p">,</span> <span class="n">mixed</span> <span class="n">xarg0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">mixed</span> <span class="n">xargn</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>func() gets  as first argument the key  and the others are those passed
as extras to map_mapping().</p>
<p>Because a function can only return  a single value  (even when it is an
array) it restricts the use  of map_mapping() to  only allow creation  of
mappings with a single value per key.</p>
</div>
<div class="section" id="Is it possible to join/intersect/cut mappings with another?">
<span id="lpc.Is it possible to join/intersect/cut mappings with another?"></span><h2><a class="toc-backref" href="#id12">IS IT POSSIBLE TO JOIN/INTERSECT/CUT MAPPINGS WITH ANOTHER?</a><a class="headerlink" href="#Is it possible to join/intersect/cut mappings with another?" title="Permalink to this headline">¶</a></h2>
<p>Joining mappings is only possible, if  they have the same width (amount
of values per key). One can use the + and += operator:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">map</span> <span class="o">=</span> <span class="n">map1</span> <span class="o">+</span> <span class="n">map2</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="n">mapn</span><span class="p">;</span>
<span class="n">map</span> <span class="o">+=</span> <span class="n">map1</span> <span class="o">+</span> <span class="n">map2</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="n">mapn</span><span class="p">;</span>
</pre></div>
</div>
<p>Intersection     of   two   mappings is    only      possible by  using
filter_mapping(). There is  no efun or operator  which features this. The
&#8216;easiest&#8217; way may be the following function:</p>
<div class="highlight-c"><div class="highlight"><pre>mapping intersect_mapping(mapping map1, mapping map2) {
  closure cl;

  cl = lambda(({ &#39;key }), ({ #&#39;member, map2, &#39;key }));
  return filter_mapping(map1, cl, map2);
}
</pre></div>
</div>
<p>This function returns a  new mapping which   consists of all  key-value
associations   of  &lt;map1&gt;  for which  an  equal  key  could   be found in
&lt;map2&gt;. This function uses  a closure which returns 0  or 1  depending on
wether a key from &lt;map1&gt; is contained in &lt;map2&gt; or not.</p>
<p>Cutting out  all key-value associations of a   mapping for which  a key
could be  found in another mapping  can  be done  by using  the  - and -=
operator:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">mapping</span> <span class="nf">cut_mapping</span><span class="p">(</span><span class="n">mapping</span> <span class="n">map1</span><span class="p">,</span> <span class="n">mapping</span> <span class="n">map2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">map1</span> <span class="o">-</span> <span class="n">mkmapping</span><span class="p">(</span><span class="n">m_indices</span><span class="p">(</span><span class="n">map2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because a maping can  only be substracted by one  without any values we
first have to create such by using m_indices() and mkmapping().</p>
</div>
<div class="section" id="What are those mappings without any values (besides keys) good for?">
<span id="lpc.What are those mappings without any values (besides keys) good for?"></span><h2><a class="toc-backref" href="#id13">WHAT ARE THOSE MAPPINGS WITHOUT ANY VALUES (BESIDES KEYS) GOOD FOR?</a><a class="headerlink" href="#What are those mappings without any values (besides keys) good for?" title="Permalink to this headline">¶</a></h2>
<p>Because the way how the driver  searches for a  key in a mapping is
rather fast, those mappings can be used as a  set of elements with a fast
method for testing if an element is  contained in the set. This technique
is called hashing (further  explanation   would lead  too far)  which  is
faster  than searching for  values  in array  (which  is done in a linear
fashion).</p>
<p>Another (maybe  more pratical) use  of these  mappings  are to create a
array of unique values out of an array with several equal values:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">uniques</span> <span class="o">=</span> <span class="n">m_indices</span><span class="p">(</span><span class="n">mkmapping</span><span class="p">(</span><span class="n">array</span><span class="p">));</span>
</pre></div>
</div>
<p>mkmapping() uses  &lt;array&gt; to  create  a mapping without any  values but
just keys. And  because a mapping can only  have unique keys all multiple
values in &lt;array&gt; are taken as one.  The call of m_indices() then returns
an  array  of  these  unique keys.  Actually we  only  make  use of those
mappings temporarily.</p>
</div>
<div class="section" id="How can I convert an alist into a  mapping and vice versa?">
<span id="lpc.How can I convert an alist into a  mapping and vice versa?"></span><h2><a class="toc-backref" href="#id14">HOW CAN I CONVERT AN ALIST INTO A  MAPPING AND VICE VERSA?</a><a class="headerlink" href="#How can I convert an alist into a  mapping and vice versa?" title="Permalink to this headline">¶</a></h2>
<p>There are no special efuns which handle such conversions. But it can be
done by the following functions:</p>
<div class="highlight-c"><div class="highlight"><pre>mapping alist_to_mapping(mixed *alist) {
  return apply(#&#39;mkmapping, alist);
}
</pre></div>
</div>
<p>The efun apply() takes a closure and an array of values and passes each
element of the  array as an  argument  to the  closure. Because  an alist
consists of an array of arrays with the first beeing the list of keys and
the others the values associated to each key passing them as arguments to
the efun closure #&#8217;mkmapping via apply() causes the creation of a mapping
out of an alist.</p>
<div class="highlight-c"><div class="highlight"><pre>mixed *mapping_to_alist(mapping map) {
  mixed *alist;
  symbol *vars;
  string var;
  closure cl;
  int width;

  width = get_type_info(map)[1];
  alist = allocate(width + 1);
  vars  = allocate(width + 2);
  for (var = &quot;a&quot;; width; var[0]++, width--) {
    alist[width] = ({});
    vars[width]  = quote(var);
  }
  alist[0] = ({});
  vars[0]  = &#39;key;
  vars[&lt;1] = &#39;alist;
  cl = lambda(vars, ({ #&#39;=, &#39;alist, ({ #&#39;insert_alist }) + vars }));
  walk_mapping(map, cl, &amp;alist);
  return alist;
}
</pre></div>
</div>
<p>This function is  a bit more  complicated  than the other  and detailed
description would lead   too far of   the topic.  This  function has  one
restriction:  it can only turn a  mappings with up to  26  values per key
into an  alist.    But  this  should  be   sufficient for probably    all
applications which use mappings.</p>
<p>And Hyps further comment on this:</p>
<blockquote>
<div>The function mapping_to_alist() is also not that
clever because insert_alist() allways creates a new
alist.  A second (optional) argument to m_values() to
specify the value column would be better. Besides
this, the conversion of a mapping into an alist could
be done by to_array().</div></blockquote>
</div>
<div class="section" id="Dirty Mappings">
<span id="lpc.Dirty Mappings"></span><h2><a class="toc-backref" href="#id15">DIRTY MAPPINGS</a><a class="headerlink" href="#Dirty Mappings" title="Permalink to this headline">¶</a></h2>
<p>&#8216;Dirty mappings&#8217; are nothing the LPC programmer directly is involved
with, however, as it relates to the way mappings are implemented
internally by the gamedriver. However, as this term shows up in
various driver statistics, it is explained here.</p>
<p>There are two fundamental approaches to implement mappings:</p>
<ol class="arabic simple">
<li>Store all data entries in an array-like structure, in sorted order.</li>
<li>Store all data in a hashtable, each entry allocaed separately.</li>
</ol>
<p>Method 1 is very space efficient, as it doesn&#8217;t need much overhead
per entry; however, insertions and deletions of entries are
relatively slow as all other entries need to be moved.
Method 2 is very fast as nothing needs to be moved in memory,
however it has a large overhead.</p>
<p>The gamedriver uses a hybrid method: at the basis is a mapping
implementation based on arrays. However the driver uses a hash table
in addition to handle all the ongoing insertions and deletions.
Every once in a while, the contents of the hash table are sorted
into the base array, reasoning that any entry surviving for longer
time in the hash table is worth keeping in a more space-efficient
manner. &#8216;Dirty&#8217; mappings are such mappings with both an array and a
hash part, &#8216;clean&#8217; mappings are those with just an array part.</p>
</div>
<h1 id="HISTORY"><a class="toc-backref" href="#id16">HISTORY</a><a class="headerlink" href="#A step-by-step introduction to mappings" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><strong>changed</strong> (<em>3.2.9/3.3.208</em>) &#8211; added ([:width ]) notation</li>
</ul>
<div class="section" id="LAST UPDATE">
<span id="lpc.LAST UPDATE"></span><h2><a class="toc-backref" href="#id17">LAST UPDATE</a><a class="headerlink" href="#LAST UPDATE" title="Permalink to this headline">¶</a></h2>
<p>Mon, 15 Mar 1999</p>
</div>
<h1 id="see2also"><a class="toc-backref" href="#id18">SEE ALSO</a><a class="headerlink" href="#A step-by-step introduction to mappings" title="Permalink to this headline">¶</a></h1>
<p><span class="xref lpc lpc-lang">alists</span>, <span class="xref lpc lpc-lang">closures</span>, <span class="xref lpc lpc-lang">structs</span>, <a class="reference internal" href="../efun/mkmapping.html#lpc.mkmapping" title="mkmapping"><code class="xref lpc lpc-efun docutils literal"><span class="pre">mkmapping</span></code>(E)</a>, <a class="reference internal" href="../efun/walk_mapping.html#lpc.walk_mapping" title="walk_mapping"><code class="xref lpc lpc-efun docutils literal"><span class="pre">walk_mapping</span></code>(E)</a></p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">A step-by-step introduction to mappings</a><ul>
<li><a class="reference internal" href="#Introduction">Introduction</a></li>
<li><a class="reference internal" href="#What are mappings good for?">WHAT ARE MAPPINGS GOOD FOR?</a></li>
<li><a class="reference internal" href="#How do I create a mapping?">HOW DO I CREATE A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I modify the data of a mapping?">HOW CAN I MODIFY THE DATA OF A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I access the data stored in a mapping?">HOW CAN I ACCESS THE DATA STORED IN A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I test for the existance of a key?">HOW CAN I TEST FOR THE EXISTANCE OF A KEY?</a></li>
<li><a class="reference internal" href="#How can I copy a mapping?">HOW CAN I COPY A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I get all keys of a mapping?">HOW CAN I GET ALL KEYS OF A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I get all the values of a mapping?">HOW CAN I GET ALL THE VALUES OF A MAPPING?</a></li>
<li><a class="reference internal" href="#How can I determine the size of a mapping?">HOW CAN I DETERMINE THE SIZE OF A MAPPING?</a></li>
<li><a class="reference internal" href="#What is the best method to iterate over a mapping?">WHAT IS THE BEST METHOD TO ITERATE OVER A MAPPING?</a></li>
<li><a class="reference internal" href="#Is it possible to join/intersect/cut mappings with another?">IS IT POSSIBLE TO JOIN/INTERSECT/CUT MAPPINGS WITH ANOTHER?</a></li>
<li><a class="reference internal" href="#What are those mappings without any values (besides keys) good for?">WHAT ARE THOSE MAPPINGS WITHOUT ANY VALUES (BESIDES KEYS) GOOD FOR?</a></li>
<li><a class="reference internal" href="#How can I convert an alist into a  mapping and vice versa?">HOW CAN I CONVERT AN ALIST INTO A  MAPPING AND VICE VERSA?</a></li>
<li><a class="reference internal" href="#Dirty Mappings">DIRTY MAPPINGS</a></li>
<li><a class="reference internal" href="#LAST UPDATE">LAST UPDATE</a></li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hook/hook.html">hooks</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;good question.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="../_sources/LPC/mappings.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>