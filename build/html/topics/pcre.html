
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Perl-compatible regular expressions &#8212; LDMud UNRELEASED documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'UNRELEASED',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PostgreSQL support" href="pgsql.html" />
    <link rel="prev" title="overloading" href="overloading.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="Perl-compatible regular expressions">
<span id="pcre"></span><span id="lpc.topic.Perl-compatible regular expressions"></span><span id="lpc.topic.pcre"></span><div class="section" id="TOPIC">
<h2>TOPIC<a class="headerlink" href="#TOPIC" title="Permalink to this headline">¶</a></h2>
<div class="container">
Perl-compatible regular expressions</div>
</div>
<div class="section" id="DESCRIPTION">
<h2>DESCRIPTION<a class="headerlink" href="#DESCRIPTION" title="Permalink to this headline">¶</a></h2>
<p>This document describes the regular expressions supported by the PCRE package. When the package is compiled into the driver, the macro <a class="reference internal" href="predefined.html#lpc.macro.__PCRE__" title="__PCRE__"><code class="xref lpc lpc-macro docutils literal"><span class="pre">__PCRE__</span></code></a> is defined.</p>
<p>Most of this manpage is lifted directly from the original PCRE manpage (dated January 2003).</p>
<p>The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5, with just a few differences (see below). The current implementation corresponds to Perl 5.005, with some additional features from later versions. This includes some experimental, incomplete support for UTF-8 encoded strings. Details of exactly what is and what is not supported are given below.</p>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Pcre Regular Expression Details<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The syntax and semantics of the regular expressions supported by PCRE are described below. Regular expressions are also described in the Perl documentation and in a number of other books, some of which have copious examples. Jeffrey Friedl&#8217;s &#8220;Mastering Regular Expressions&#8221;, published by O&#8217;Reilly, covers them in great detail. The description here is intended as reference documentation.</p>
<p>The basic operation of PCRE is on strings of bytes. However, there is also support for UTF-8 character strings. To use this support you must build PCRE to include UTF-8 support, and then call pcre_compile() with the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_UTF8</span></code> option. How this affects the pattern matching is mentioned in several places below. There is also a summary of UTF-8 features in the section on UTF-8 support in the main pcre page.</p>
<p>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern <code class="docutils literal"><span class="pre">The</span> <span class="pre">quick</span> <span class="pre">brown</span> <span class="pre">fox</span></code> matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters, which do not stand for themselves but instead are interpreted in some special way.</p>
<p>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the meta-characters are as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">\\</span></code></dt>
<dd>general escape character with several uses</dd>
<dt><code class="docutils literal"><span class="pre">^</span></code></dt>
<dd>assert start of string (or line, in multiline mode)</dd>
<dt><code class="docutils literal"><span class="pre">$</span></code></dt>
<dd>assert end of string (or line, in multiline mode)</dd>
<dt><code class="docutils literal"><span class="pre">.</span></code></dt>
<dd>match any character except newline (by default)</dd>
<dt><code class="docutils literal"><span class="pre">[</span></code></dt>
<dd>start character class definition</dd>
<dt><code class="docutils literal"><span class="pre">|</span></code></dt>
<dd>start of alternative branch</dd>
<dt><code class="docutils literal"><span class="pre">(</span></code></dt>
<dd>start subpattern</dd>
<dt><code class="docutils literal"><span class="pre">)</span></code></dt>
<dd>end subpattern</dd>
<dt><code class="docutils literal"><span class="pre">?</span></code></dt>
<dd><p class="first">extends the meaning of <code class="docutils literal"><span class="pre">(</span></code></p>
<p>also 0 or 1 quantifier</p>
<p class="last">also quantifier minimizer</p>
</dd>
<dt><code class="docutils literal"><span class="pre">*</span></code></dt>
<dd>0 or more quantifier</dd>
<dt><code class="docutils literal"><span class="pre">+</span></code></dt>
<dd><p class="first">1 or more quantifier</p>
<p class="last">also &#8220;possessive quantifier&#8221;</p>
</dd>
<dt><code class="docutils literal"><span class="pre">{</span></code></dt>
<dd>start min/max quantifier</dd>
</dl>
<p>Part of a pattern that is in square brackets is called a &#8220;character class&#8221;. In a character class the only meta-characters are:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">\</span></code></dt>
<dd>general escape character</dd>
<dt><code class="docutils literal"><span class="pre">^</span></code></dt>
<dd>negate the class, but only if the first character</dd>
<dt><code class="docutils literal"><span class="pre">-</span></code></dt>
<dd>indicates character range</dd>
<dt><code class="docutils literal"><span class="pre">[</span></code></dt>
<dd>POSIX character class (only if followed by POSIX syntax)</dd>
<dt><code class="docutils literal"><span class="pre">]</span></code></dt>
<dd>terminates the character class</dd>
</dl>
<p>The following sections describe the use of each of the meta-characters.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Backslash<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The backslash character has several uses. Firstly, if it is followed by a non-alphameric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</p>
<p>For example, if you want to match a * character, you write * in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a meta-character, so it is always safe to precede a non-alphameric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write \.</p>
<p>If a pattern is compiled with the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code> option, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline character are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</p>
<p>If you want to remove the special meaning from a sequence of characters, you can do so by putting them between Q and E. This is different from Perl in that $ and &#64; are handled as literals in Q...E sequences in PCRE, whereas in Perl, $ and &#64; cause variable interpolation. Note the following examples:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>Pattern            PCRE matches   Perl matches

\Qabc$xyz\E        abc$xyz        abc followed by the
                                   contents of $xyz
\Qabc\$xyz\E       abc\$xyz       abc\$xyz
\Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz
</pre></div>
</div>
<p>The Q...E sequence is recognized both inside and outside character classes.</p>
<p>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\a        alarm, that is, the BEL character (hex 07)
\cx       &quot;control-x&quot;, where x is any character
\e        escape (hex 1B)
\f        formfeed (hex 0C)
\n        newline (hex 0A)
\r        carriage return (hex 0D)
\t        tab (hex 09)
\ddd      character with octal code ddd, or backreference
\xhh      character with hex code hh
\x{hhh..} character with hex code hhh... (UTF-8 mode only)
</pre></div>
</div>
<p>The precise effect of cx is as follows: if x is a lower case letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus cz becomes hex 1A, but c{ becomes hex 3B, while c; becomes hex 7B.</p>
<p>After x, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal dig-its may appear between x{ and }, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between x{ and }, or if there is no terminating }, this form of escape is not recognized. Instead, the initial x will be interpreted as a basic hexadecimal escape, with no following digits, giving a byte whose value is zero.</p>
<p>Characters whose value is less than 256 can be defined by either of the two syntaxes for x when PCRE is in UTF-8 mode. There is no difference in the way they are handled. For example, xdc is exactly the same as x{dc}.</p>
<p>After 0 up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence 0x07 specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the character that follows is itself an octal digit.</p>
<p>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</p>
<p>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\040   is another way of writing a space
\40    is the same, provided there are fewer than 40
         previous capturing subpatterns
\7     is always a back reference
\11    might be a back reference, or another way of
         writing a tab
\011   is always a tab
\0113  is a tab followed by the character &quot;3&quot;
\113   might be a back reference, otherwise the
         character with octal code 113
\377   might be a back reference, otherwise
         the byte consisting entirely of 1 bits
\81    is either a back reference, or a binary zero
         followed by the two characters &quot;8&quot; and &quot;1&quot;
</pre></div>
</div>
<p>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</p>
<p>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence b is interpreted as the backspace character (hex 08). Outside a character class it has a different meaning (see below).</p>
<p>The third use of backslash is for specifying generic character types:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\d     any decimal digit
\D     any character that is not a decimal digit
\s     any whitespace character
\S     any character that is not a whitespace character
\w     any &quot;word&quot; character
\W     any &quot;non-word&quot; character
</pre></div>
</div>
<p>Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair.</p>
<p>In UTF-8 mode, characters with values greater than 255 never match d, s, or w, and always match D, S, and W.</p>
<p>For compatibility with Perl, s does not match the VT character (code 11). This makes it different from the the POSIX &#8220;space&#8221; class. The s characters are HT (9), LF (10), FF (12), CR (13), and space (32).</p>
<p>A &#8220;word&#8221; character is any letter or digit or the underscore character, that is, any character which can be part of a Perl &#8220;word&#8221;. The definition of letters and digits is controlled by PCRE&#8217;s character tables, and may vary if locale-specific matching is taking place (see &#8220;Locale support&#8221; in the pcreapi page). For example, in the &#8220;fr&#8221; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by w.</p>
<p>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</p>
<p>The fourth use of backslash is for certain simple assertions. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\b     matches at a word boundary
\B     matches when not at a word boundary
\A     matches at start of subject
\Z     matches at end of subject or before newline at end
\z     matches at end of subject
\G     matches at first matching position in subject
</pre></div>
</div>
<p>These assertions may not appear in character classes (but note that b has a different meaning, namely the backspace character, inside a character class).</p>
<p>A word boundary is a position in the subject string where the current character and the previous character do not both match w or W (i.e. one matches w and the other matches W), or the start or end of the string if the first or last character matches w, respectively.</p>
<p>The A, Z, and z assertions differ from the traditional circumflex and dollar (described below) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode.</p>
<p>They are not affected by the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_NOTBOL</span></code> or <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_NOTEOL</span></code> options. If the startoffset argument of <code class="docutils literal"><span class="pre">pcre_exec()</span></code> is non-zero, indicating that matching is to start at a point other than the beginning of the subject, A can never match. The difference between Z and z is that Z matches before a newline that is the last character of the string as well as at the end of the string, whereas z matches only at the end.</p>
<p>The G assertion is true only when the current matching position is at the start point of the match, as specified by the startoffset argument of <code class="docutils literal"><span class="pre">pcre_exec()</span></code>. It differs from A when the value of startoffset is non-zero. By calling <code class="docutils literal"><span class="pre">pcre_exec()</span></code> multiple times with appropriate arguments, you can mimic Perl&#8217;s /g option, and it is in this kind of implementation where G can be useful.</p>
<p>Note, however, that PCRE&#8217;s interpretation of G, as the start of the current match, is subtly different from Perl&#8217;s, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. Because PCRE does just one match at a time, it cannot reproduce this behaviour.</p>
<p>If all the alternatives of a pattern begin with G, the expression is anchored to the starting match position, and the &#8220;anchored&#8221; flag is set in the compiled regular expression.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Circumflex And Dollar<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, in the default matching mode, the circumflex character is an assertion which is true only if the current matching point is at the start of the subject string. If the startoffset argument of <code class="docutils literal"><span class="pre">pcre_exec()</span></code> is non-zero, circumflex can never match if the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> option is unset. Inside a character class, circumflex has an entirely different meaning (see below).</p>
<p>Circumflex need not be the first character of the pattern if a number of alternatives are involved, but it should be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an &#8220;anchored&#8221; pattern. (There are also other constructs that can cause a pattern to be anchored.)</p>
<p>A dollar character is an assertion which is true only if the current matching point is at the end of the subject string, or immediately before a newline character that is the last character in the string (by default). Dollar need not be the last character of the pattern if a number of alternatives are involved, but it should be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</p>
<p>The meaning of dollar can be changed so that it matches only at the very end of the string, by setting the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOLLAR_ENDONLY</span></code> option at compile time. This does not affect the Z assertion.</p>
<p>The meanings of the circumflex and dollar characters are changed if the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> option is set. When this is the case, they match immediately after and immediately before an internal newline character, respectively, in addition to matching at the start and end of the subject string. For example, the pattern /^abc$/ matches the subject string &#8220;defnabc&#8221; in multiline mode, but not otherwise. Consequently, patterns that are anchored in single line mode because all branches start with ^ are not anchored in multiline mode, and a match for circumflex is possible when the startoffset argument of <code class="docutils literal"><span class="pre">pcre_exec()</span></code> is non-zero. The <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOLLAR_ENDONLY</span></code> option is ignored if <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> is set.</p>
<p>Note that the sequences A, Z, and z can be used to match the start and end of the subject in both modes, and if all branches of a pattern start with A it is always anchored, whether <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> is set or not.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Full Stop (period, Dot)<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, a dot in the pattern matches any one character in the subject, including a non-printing character, but not (by default) newline. In UTF-8 mode, a dot matches any UTF-8 character, which might be more than one byte long, except (by default) for newline. If the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOTALL</span></code> option is set, dots match newlines as well. The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship being that they both involve newline characters. Dot has no special meaning in a character class.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Matching A Single Byte<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, the escape sequence C matches any one byte, both in and out of UTF-8 mode. Unlike a dot, it always matches a newline. The feature is provided in Perl in order to match individual bytes in UTF-8 mode. Because it breaks up UTF-8 characters into individual bytes, what remains in the string may be a malformed UTF-8 string. For this reason it is best avoided.</p>
<p>PCRE does not allow C to appear in lookbehind assertions (see below), because in UTF-8 mode it makes it impossible to calculate the length of the lookbehind.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Square Brackets<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>An opening square bracket introduces a character class, terminated by a closing square bracket. A closing square bracket on its own is not special. If a closing square bracket is required as a member of the class, it should be the first data character in the class (after an initial circumflex, if present) or escaped with a backslash.</p>
<p>A character class matches a single character in the subject. In UTF-8 mode, the character may occupy more than one byte. A matched character must be in the set of characters defined by the class, unless the first character in the class definition is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is actually required as a member of the class, ensure it is not the first character, or escape it with a backslash.</p>
<p>For example, the character class [aeiou] matches any lower case vowel, while [^aeiou] matches any character that is not a lower case vowel. Note that a circumflex is just a convenient notation for specifying the characters which are in the class by enumerating those that are not. It is not an assertion: it still consumes a character from the subject string, and fails if the current pointer is at the end of the string.</p>
<p>In UTF-8 mode, characters with values greater than 255 can be included in a class as a literal string of bytes, or by using the x{ escaping mechanism.</p>
<p>When caseless matching is set, any letters in a class represent both their upper case and lower case versions, so for example, a caseless [aeiou] matches &#8220;A&#8221; as well as &#8220;a&#8221;, and a caseless [^aeiou] does not match &#8220;A&#8221;, whereas a caseful version would. PCRE does not support the concept of case for characters with values greater than 255.</p>
<p>The newline character is never treated in any special way in character classes, whatever the setting of the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOTALL</span></code> or <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> options is. A class such as [^a] will always match a newline.</p>
<p>The minus (hyphen) character can be used to specify a range of characters in a character class. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class.</p>
<p>It is not possible to have the literal character &#8220;]&#8221; as the end character of a range. A pattern such as [W-]46] is interpreted as a class of two characters (&#8220;W&#8221; and &#8220;-&#8221;) followed by a literal string &#8220;46]&#8221;, so it would match &#8220;W46]&#8221; or &#8220;-46]&#8221;. However, if the &#8220;]&#8221; is escaped with a backslash it is interpreted as the end of range, so [W-]46] is interpreted as a single class containing a range followed by two separate characters. The octal or hexadecimal representation of &#8220;]&#8221; can also be used to end a range.</p>
<p>Ranges operate in the collating sequence of character values. They can also be used for characters specified numerically, for example [000-037]. In UTF-8 mode, ranges can include characters whose values are greater than 255, for example [x{100}-x{2ff}].</p>
<p>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][^_`wxyzabc], matched caselessly, and if character tables for the &#8220;fr&#8221; locale are in use, [xc8-xcb] matches accented E characters in both cases.</p>
<p>The character types d, D, s, S, w, and W may also appear in a character class, and add the characters that they match to the class. For example, [dABCDEF] matches any hexadecimal digit. A circumflex can conveniently be used with the upper case character types to specify a more restricted set of characters than the matching lower case type. For example, the class [^W_] matches any letter or digit, but not underscore.</p>
<p>All non-alphameric characters other than , -, ^ (at the start) and the terminating ] are non-special in character classes, but it does no harm if they are escaped.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Posix Character Classes<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Perl supports the POSIX notation for character classes, which uses names enclosed by [: and :] within the enclosing square brackets. PCRE also supports this notation. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mo">01</span><span class="p">[</span><span class="o">:</span><span class="nl">alpha</span><span class="p">:]</span><span class="o">%</span><span class="p">]</span>
</pre></div>
</div>
<p>matches &#8220;0&#8221;, &#8220;1&#8221;, any alphabetic character, or &#8220;%&#8221;. The supported class names are:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>alnum    letters and digits
alpha    letters
ascii    character codes 0 - 127
blank    space or tab only
cntrl    control characters
digit    decimal digits (same as \d)
graph    printing characters, excluding space
lower    lower case letters
print    printing characters, including space
punct    printing characters, excluding letters and digits
space    white space (not quite the same as \s)
upper    upper case letters
word     &quot;word&quot; characters (same as \w)
xdigit   hexadecimal digits
</pre></div>
</div>
<p>The &#8220;space&#8221; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). Notice that this list includes the VT character (code 11). This makes &#8220;space&#8221; different to s, which does not include VT (for Perl compatibility).</p>
<p>The name &#8220;word&#8221; is a Perl extension, and &#8220;blank&#8221; is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">12</span><span class="p">[</span><span class="o">:^</span><span class="nl">digit</span><span class="p">:]]</span>
</pre></div>
</div>
<p>matches &#8220;1&#8221;, &#8220;2&#8221;, or any non-digit. PCRE (and Perl) also recognize the POSIX syntax [.ch.] and [=ch=] where &#8220;ch&#8221; is a &#8220;collating element&#8221;, but these are not supported, and an error is given if they are encountered.</p>
<p>In UTF-8 mode, characters with values greater than 255 do not match any of the POSIX character classes.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Vertical Bar<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Vertical bar characters are used to separate alternative patterns. For example, the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">gilbert</span><span class="o">|</span><span class="n">sullivan</span>
</pre></div>
</div>
<p>matches either &#8220;gilbert&#8221; or &#8220;sullivan&#8221;. Any number of alternatives may appear, and an empty alternative is permitted (matching the empty string). The matching process tries each alternative in turn, from left to right, and the first one that succeeds is used. If the alternatives are within a subpattern (defined below), &#8220;succeeds&#8221; means matching the rest of the main pattern as well as the alternative in the subpattern.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Internal Option Setting<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The settings of the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_CASELESS</span></code>, <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code>, <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOTALL</span></code>, and <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code> options can be changed from within the pattern by a sequence of Perl option letters enclosed between &#8220;(?&#8221; and &#8221;)&#8221;. The option letters are:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">i</span>  <span class="k">for</span> <span class="n">PCRE_CASELESS</span>
<span class="n">m</span>  <span class="k">for</span> <span class="n">PCRE_MULTILINE</span>
<span class="n">s</span>  <span class="k">for</span> <span class="n">PCRE_DOTALL</span>
<span class="n">x</span>  <span class="k">for</span> <span class="n">PCRE_EXTENDED</span>
</pre></div>
</div>
<p>For example, (?im) sets caseless, multiline matching. It is also possible to unset these options by preceding the letter with a hyphen, and a combined setting and unsetting such as (?im-sx), which sets <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_CASELESS</span></code> and <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> while unsetting <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOTALL</span></code> and <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code>, is also permitted. If a letter appears both before and after the hyphen, the option is unset.</p>
<p>When an option change occurs at top level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows. If the change is placed right at the start of a pattern, PCRE extracts it into the global options (and it will therefore show up in data extracted by the <code class="docutils literal"><span class="pre">pcre_fullinfo()</span></code> function).</p>
<p>An option change within a subpattern affects only that part of the current pattern that follows it, so:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="o">?</span><span class="n">i</span><span class="p">)</span><span class="n">b</span><span class="p">)</span><span class="n">c</span>
</pre></div>
</div>
<p>matches abc and aBc and no other strings (assuming <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_CASELESS</span></code> is not used). By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="o">?</span><span class="n">i</span><span class="p">)</span><span class="n">b</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>matches &#8220;ab&#8221;, &#8220;aB&#8221;, &#8220;c&#8221;, and &#8220;C&#8221;, even though when matching &#8220;C&#8221; the first branch is abandoned before the option setting. This is because the effects of option settings happen at compile time. There would be some very weird behaviour otherwise.</p>
<p>The PCRE-specific options <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_UNGREEDY</span></code> and <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTRA</span></code> can be changed in the same way as the Perl-compatible options by using the characters U and X respectively. The (?X) flag setting is special in that it must always occur earlier in the pattern than any of the additional features it turns on, even when it is at top level. It is best put at the start.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Subpatterns<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Subpatterns are delimited by parentheses (round brackets), which can be nested. Marking part of a pattern as a subpattern does two things:</p>
<ol class="arabic">
<li><p class="first">It localizes a set of alternatives. For example, the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">cat</span><span class="p">(</span><span class="n">aract</span><span class="o">|</span><span class="n">erpillar</span><span class="o">|</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div>matches one of the words &#8220;cat&#8221;, &#8220;cataract&#8221;, or &#8220;caterpillar&#8221;. Without the parentheses, it would match &#8220;cataract&#8221;, &#8220;erpillar&#8221; or the empty string.</div></blockquote>
<ol class="arabic simple" start="2">
<li>It sets up the subpattern as a capturing subpattern (as defined above). When the whole pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller via the ovector argument of pcre_exec(). Opening parentheses are counted from left to right (starting from 1) to obtain the numbers of the capturing subpatterns.</li>
</ol>
<blockquote>
<div><p>For example, if the string &#8220;the red king&#8221; is matched against the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">the</span> <span class="p">((</span><span class="n">red</span><span class="o">|</span><span class="n">white</span><span class="p">)</span> <span class="p">(</span><span class="n">king</span><span class="o">|</span><span class="n">queen</span><span class="p">))</span>
</pre></div>
</div>
<p>the captured substrings are &#8220;red king&#8221;, &#8220;red&#8221;, and &#8220;king&#8221;, and are numbered 1, 2, and 3, respectively.</p>
<p>The fact that plain parentheses fulfil two functions is not always helpful. There are often times when a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &#8220;the white queen&#8221; is matched against the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">((</span><span class="o">?:</span><span class="n">red</span><span class="o">|</span><span class="n">white</span><span class="p">)</span> <span class="p">(</span><span class="n">king</span><span class="o">|</span><span class="n">queen</span><span class="p">))</span>
</pre></div>
</div>
<p>the captured substrings are &#8220;white queen&#8221; and &#8220;queen&#8221;, and are numbered 1 and 2. The maximum number of capturing subpatterns is 65535, and the maximum depth of nesting of all subpatterns, both capturing and noncapturing, is 200.</p>
<p>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters may appear between the &#8221;?&#8221; and the &#8221;:&#8221;. Thus the two patterns:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?</span><span class="nl">i</span><span class="p">:</span><span class="n">saturday</span><span class="o">|</span><span class="n">sunday</span><span class="p">)</span>
<span class="p">(</span><span class="o">?:</span><span class="p">(</span><span class="o">?</span><span class="n">i</span><span class="p">)</span><span class="n">saturday</span><span class="o">|</span><span class="n">sunday</span><span class="p">)</span>
</pre></div>
</div>
<p>match exactly the same set of strings. Because alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match &#8220;SUNDAY&#8221; as well as &#8220;Saturday&#8221;.</p>
</div></blockquote>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Named Subpatterns<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Identifying capturing parentheses by number is simple, but it can be very hard to keep track of the numbers in complicated regular expressions. Furthermore, if an expression is modified, the numbers may change. To help with the difficulty, PCRE supports the naming of subpatterns, something that Perl does not provide. The Python syntax (?P&lt;name&gt;...) is used. Names consist of alphanumeric characters and underscores, and must be unique within a pattern.</p>
<p>Named capturing parentheses are still allocated numbers as well as names. The PCRE API provides function calls for extracting the name-to- number translation table from a compiled pattern. For further details see the pcreapi documentation.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Repetition<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Repetition is specified by quantifiers, which can follow any of the following items:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>a literal data character
the . metacharacter
the \C escape sequence
escapes such as \d that match single characters
a character class
a back reference (see next section)
a parenthesized subpattern (unless it is an assertion)
</pre></div>
</div>
<p>The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be less than 65536, and the first must be less than or equal to the second. For example:</p>
<blockquote>
<div>z{2,4}</div></blockquote>
<p>matches &#8220;zz&#8221;, &#8220;zzz&#8221;, or &#8220;zzzz&#8221;. A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit; if the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus</p>
<blockquote>
<div>[aeiou]{3,}</div></blockquote>
<p>matches at least 3 successive vowels, but may match many more, while</p>
<blockquote>
<div>d{8}</div></blockquote>
<p>matches exactly 8 digits. An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal string of four characters.</p>
<p>In UTF-8 mode, quantifiers apply to UTF-8 characters rather than to individual bytes. Thus, for example, x{100}{2} matches two UTF-8 characters, each of which is represented by a two-byte sequence.</p>
<p>The quantifier {0} is permitted, causing the expression to behave as if the previous item and the quantifier were not present.</p>
<p>For convenience (and historical compatibility) the three most common quantifiers have single-character abbreviations:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="o">*</span>    <span class="n">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
<span class="o">+</span>    <span class="n">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="p">{</span><span class="mi">1</span><span class="p">,}</span>
<span class="o">?</span>    <span class="n">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
</pre></div>
</div>
<p>It is possible to construct infinite loops by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="o">?</span><span class="p">)</span><span class="o">*</span>
</pre></div>
</div>
<p>Earlier versions of Perl and PCRE used to give an error at compile time for such patterns. However, because there are cases where this can be useful, such patterns are now accepted, but if any repetition of the subpattern does in fact match no characters, the loop is forcibly broken.</p>
<p>By default, the quantifiers are &#8220;greedy&#8221;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the rest of the pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between the sequences <code class="docutils literal"><span class="pre">/*</span></code> and <code class="docutils literal"><span class="pre">*/</span></code> and within the sequence, individual <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">/</span></code> characters may appear. An attempt to match C comments by applying the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>/\*.*\*/
</pre></div>
</div>
<p>to the string:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="cm">/* first comment */</span> <span class="n">not</span> <span class="n">comment</span> <span class="cm">/* second comment */</span>
</pre></div>
</div>
<p>fails, because it matches the entire string owing to the greediness of the <code class="docutils literal"><span class="pre">.*</span></code> item.</p>
<p>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>/\*.*?\*/
</pre></div>
</div>
<p>does the right thing with the C comments. The meaning of the various quantifiers is not otherwise changed, just the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. Because it has two uses, it can sometimes appear doubled, as in:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\d??\d
</pre></div>
</div>
<p>which matches one digit by preference, but can match two if that is the only way the rest of the pattern matches.</p>
<p>If the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_UNGREEDY</span></code> option is set (an option which is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. In other words, it inverts the default behaviour.</p>
<p>When a parenthesized subpattern is quantified with a minimum repeat count that is greater than 1 or with a limited maximum, more store is required for the compiled pattern, in proportion to the size of the minimum or maximum.</p>
<p>If a pattern starts with <code class="docutils literal"><span class="pre">.*</span></code> or <code class="docutils literal"><span class="pre">.{0,}</span></code> and the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOTALL</span></code> option (equivalent to Perl&#8217;s <code class="docutils literal"><span class="pre">/s</span></code>) is set, thus allowing the <code class="docutils literal"><span class="pre">.</span></code> to match newlines, the pattern is implicitly anchored, because whatever follows will be tried against every character position in the subject string, so there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as though it were preceded by <code class="docutils literal"><span class="pre">\A</span></code>.</p>
<p>In cases where it is known that the subject string contains no newlines, it is worth setting <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOTALL</span></code> in order to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</p>
<p>However, there is one situation where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a backreference elsewhere in the pattern, a match at the start may fail, and a later one succeed. Consider, for example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(.*)abc\1
</pre></div>
</div>
<p>If the subject is &#8220;xyz123abc123&#8221; the match point is the fourth character. For this reason, such a pattern is not implicitly anchored.</p>
<p>When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(tweedle[dume]{3}\s*)+
</pre></div>
</div>
<p>has matched &#8220;tweedledum tweedledee&#8221; the value of the captured substring is &#8220;tweedledee&#8221;. However, if there are nested capturing subpatterns, the corresponding captured values may have been set in previous iterations. For example, after:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">+/</span>
</pre></div>
</div>
<p>matches &#8220;aba&#8221; the value of the second captured substring is &#8220;b&#8221;.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Atomic Grouping And Possessive Quantifiers<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>With both maximizing and minimizing repetition, failure of what follows normally causes the repeated item to be re-evaluated to see if a different number of repeats allows the rest of the pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it fail earlier than it otherwise might, when the author of the pattern knows there is no point in carrying on.</p>
<p>Consider, for example, the pattern d+foo when applied to the subject line:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="mi">123456</span><span class="n">bar</span>
</pre></div>
</div>
<p>After matching all 6 digits and then failing to match &#8220;foo&#8221;, the normal action of the matcher is to try again with only 5 digits matching the d+ item, and then with 4, and so on, before ultimately failing. &#8220;Atomic grouping&#8221; (a term taken from Jeffrey Friedl&#8217;s book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.</p>
<p>If we use atomic grouping for the previous example, the matcher would give up immediately on failing to match &#8220;foo&#8221; the first time. The notation is a kind of special parenthesis, starting with (?&gt; as in this example:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?&gt;\d+)foo
</pre></div>
</div>
<p>This kind of parenthesis &#8220;locks up&#8221; the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.</p>
<p>An alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match, if anchored at the current point in the subject string.</p>
<p>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both d+ and d+? are prepared to adjust the number of digits they match in order to make the rest of the pattern match, (?&gt;d+) can only match an entire sequence of digits.</p>
<p>Atomic groups in general can of course contain arbitrarily complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &#8220;possessive quantifier&#8221; can be used. This consists of an additional + character following a quantifier. Using this notation, the previous example can be rewritten as:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\d++bar
</pre></div>
</div>
<p>Possessive quantifiers are always greedy; the setting of the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_UNGREEDY</span></code> option is ignored. They are a convenient notation for the simpler forms of atomic group. However, there is no difference in the meaning or processing of a possessive quantifier and the equivalent atomic group.</p>
<p>The possessive quantifier syntax is an extension to the Perl syntax. It originates in Sun&#8217;s Java package.</p>
<p>When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a very long time indeed. The pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(\D+|&lt;\d+&gt;)*[!?]
</pre></div>
</div>
<p>matches an unlimited number of substrings that either consist of non- digits, or digits enclosed in &lt;&gt;, followed by either ! or ?. When it matches, it runs quickly. However, if it is applied to:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span>
</pre></div>
</div>
<p>it takes a long time before reporting failure. This is because the string can be divided between the two repeats in a large number of ways, and all have to be tried. (The example used [!?] rather than a single character at the end, because both PCRE and Perl have an optimization that allows for fast failure when a single character is used. They remember the last single character that is required for a match, and fail early if it is not present in the string.) If the pattern is changed to:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>((?&gt;\D+)|&lt;\d+&gt;)*[!?]
</pre></div>
</div>
<p>sequences of non-digits cannot be broken, and failure happens quickly.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Back References<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, a backslash followed by a digit greater than 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses.</p>
<p>However, if the decimal number following the backslash is less than 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. In other words, the parentheses that are referenced need not be to the left of the reference for numbers less than 10. See the section entitled &#8220;Backslash&#8221; above for further details of the handling of digits following a backslash.</p>
<p>A back reference matches whatever actually matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself (see &#8220;Subpatterns as subroutines&#8221; below for a way of doing that). So the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(sens|respons)e and \1ibility
</pre></div>
</div>
<p>matches &#8220;sense and sensibility&#8221; and &#8220;response and responsibility&#8221;, but not &#8220;sense and responsibility&#8221;. If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>((?i)rah)\s+\1
</pre></div>
</div>
<p>matches &#8220;rah rah&#8221; and &#8220;RAH RAH&#8221;, but not &#8220;RAH rah&#8221;, even though the original capturing subpattern is matched caselessly.</p>
<p>Back references to named subpatterns use the Python syntax (?P=name). We could rewrite the above example as follows:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?&lt;p1&gt;(?i)rah)\s+(?P=p1)
</pre></div>
</div>
<p>There may be more than one back reference to the same subpattern. If a subpattern has not actually been used in a particular match, any back references to it always fail. For example, the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(a|(bc))\2
</pre></div>
</div>
<p>always fails if it starts to match &#8220;a&#8221; rather than &#8220;bc&#8221;. Because there may be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code> option is set, this can be whitespace. Otherwise an empty comment can be used.</p>
<p>A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a1) never matches. However, such references can be useful inside repeated subpatterns. For example, the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(a|b\1)+
</pre></div>
</div>
<p>matches any number of &#8220;a&#8221;s and also &#8220;aba&#8221;, &#8220;ababbaa&#8221; etc. At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Assertions<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>An assertion is a test on the characters following or preceding the current matching point that does not actually consume any characters. The simple assertions coded as b, B, A, G, Z, z, ^ and $ are described above. More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it.</p>
<p>An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed. Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\w+(?=;)
</pre></div>
</div>
<p>matches a word followed by a semicolon, but does not include the semicolon in the match, and:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="p">(</span><span class="o">?!</span><span class="n">bar</span><span class="p">)</span>
</pre></div>
</div>
<p>matches any occurrence of &#8220;foo&#8221; that is not followed by &#8220;bar&#8221;. Note that the apparently similar pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?!</span><span class="n">foo</span><span class="p">)</span><span class="n">bar</span>
</pre></div>
</div>
<p>does not find an occurrence of &#8220;bar&#8221; that is preceded by something other than &#8220;foo&#8221;; it finds any occurrence of &#8220;bar&#8221; whatsoever, because the assertion (?!foo) is always true when the next three characters are &#8220;bar&#8221;. A lookbehind assertion is needed to achieve this effect.</p>
<p>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!) because an empty string always matches, so an assertion that requires there not to be an empty string must always fail.</p>
<p>Lookbehind assertions start with (?&lt;= for positive assertions and (?&lt;! for negative assertions. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?&lt;!</span><span class="n">foo</span><span class="p">)</span><span class="n">bar</span>
</pre></div>
</div>
<p>does find an occurrence of &#8220;bar&#8221; that is not preceded by &#8220;foo&#8221;. The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are several alternatives, they do not all have to have the same fixed length. Thus:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?&lt;=</span><span class="n">bullock</span><span class="o">|</span><span class="n">donkey</span><span class="p">)</span>
</pre></div>
</div>
<p>is permitted, but:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?&lt;!</span><span class="n">dogs</span><span class="o">?|</span><span class="n">cats</span><span class="o">?</span><span class="p">)</span>
</pre></div>
</div>
<p>causes an error at compile time. Branches that match different length strings are permitted only at the top level of a lookbehind assertion. This is an extension compared with Perl (at least for 5.8), which requires all branches to match the same length of string. An assertion such as:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?&lt;=</span><span class="n">ab</span><span class="p">(</span><span class="n">c</span><span class="o">|</span><span class="n">de</span><span class="p">))</span>
</pre></div>
</div>
<p>is not permitted, because its single top-level branch can match two different lengths, but it is acceptable if rewritten to use two top- level branches:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?&lt;=</span><span class="n">abc</span><span class="o">|</span><span class="n">abde</span><span class="p">)</span>
</pre></div>
</div>
<p>The implementation of lookbehind assertions is, for each alternative, to temporarily move the current position back by the fixed width and then try to match. If there are insufficient characters before the current position, the match is deemed to fail.</p>
<p>PCRE does not allow the C escape (which matches a single byte in UTF-8 mode) to appear in lookbehind assertions, because it makes it impossible to calculate the length of the lookbehind.</p>
<p>Atomic groups can be used in conjunction with lookbehind assertions to specify efficient matching at the end of the subject string. Consider a simple pattern such as:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>abcd$
</pre></div>
</div>
<p>when applied to a long string that does not match. Because matching proceeds from left to right, PCRE will look for each &#8220;a&#8221; in the subject and then see if what follows matches the rest of the pattern. If the pattern is specified as:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>^.*abcd$
</pre></div>
</div>
<p>the initial .* matches the entire string at first, but when this fails (because there is no following &#8220;a&#8221;), it backtracks to match all but the last character, then all but the last two characters, and so on. Once again the search for &#8220;a&#8221; covers the entire string, from right to left, so we are no better off. However, if the pattern is written as:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="o">^</span><span class="p">(</span><span class="o">?&gt;</span><span class="p">.</span><span class="o">*</span><span class="p">)(</span><span class="o">?&lt;=</span><span class="n">abcd</span><span class="p">)</span>
</pre></div>
</div>
<p>or, equivalently,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="o">^</span><span class="p">.</span><span class="o">*+</span><span class="p">(</span><span class="o">?&lt;=</span><span class="n">abcd</span><span class="p">)</span>
</pre></div>
</div>
<p>there can be no backtracking for the .* item; it can match only the entire string. The subsequent lookbehind assertion does a single test on the last four characters. If it fails, the match fails immediately. For long strings, this approach makes a significant difference to the processing time.</p>
<p>Several assertions (of any sort) may occur in succession. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?&lt;=\d{3})(?&lt;!999)foo
</pre></div>
</div>
<p>matches &#8220;foo&#8221; preceded by three digits that are not &#8220;999&#8221;. Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &#8220;999&#8221;. This pattern does not match &#8220;foo&#8221; preceded by six characters, the first of which are digits and the last three of which are not &#8220;999&#8221;. For example, it doesn&#8217;t match &#8220;123abcfoo&#8221;. A pattern to do that is:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?&lt;=\d{3}...)(?&lt;!999)foo
</pre></div>
</div>
<p>This time the first assertion looks at the preceding six characters, checking that the first three are digits, and then the second assertion checks that the preceding three characters are not &#8220;999&#8221;.</p>
<p>Assertions can be nested in any combination. For example,:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?&lt;=</span><span class="p">(</span><span class="o">?&lt;!</span><span class="n">foo</span><span class="p">)</span><span class="n">bar</span><span class="p">)</span><span class="n">baz</span>
</pre></div>
</div>
<p>matches an occurrence of &#8220;baz&#8221; that is preceded by &#8220;bar&#8221; which in turn is not preceded by &#8220;foo&#8221;, while:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?&lt;=\d{3}(?!999)...)foo
</pre></div>
</div>
<p>is another pattern which matches &#8220;foo&#8221; preceded by three digits and any three characters that are not &#8220;999&#8221;.</p>
<p>Assertion subpatterns are not capturing subpatterns, and may not be repeated, because it makes no sense to assert the same thing several times. If any kind of assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is carried out only for positive assertions, because it does not make sense for negative assertions.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>CONDITIONAL SUBPATTERNS<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a previous capturing subpattern matched or not. The two possible forms of conditional subpattern are:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="n">yes</span><span class="o">-</span><span class="n">pattern</span><span class="p">)</span>
<span class="p">(</span><span class="o">?</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="n">yes</span><span class="o">-</span><span class="n">pattern</span><span class="o">|</span><span class="n">no</span><span class="o">-</span><span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>If the condition is satisfied, the yes-pattern is used; otherwise the no-pattern (if present) is used. If there are more than two alternatives in the subpattern, a compile-time error occurs.</p>
<p>There are three kinds of condition. If the text between the parentheses consists of a sequence of digits, the condition is satisfied if the capturing subpattern of that number has previously matched. The number must be greater than zero. Consider the following pattern, which contains non-significant white space to make it more readable (assume the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code> option) and to divide it into three parts for ease of discussion:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>( \( )?    [^()]+   (?(1) \) )
</pre></div>
</div>
<p>The first part matches an optional opening parenthesis, and if that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, if subject started with an opening parenthesis, the condition is true, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, since no-pattern is not present, the subpattern matches nothing. In other words, this pattern matches a sequence of non-parentheses, optionally enclosed in parentheses.</p>
<p>If the condition is the string (R), it is satisfied if a recursive call to the pattern or subpattern has been made. At &#8220;top level&#8221;, the condition is false. This is a PCRE extension. Recursive patterns are described in the next section.</p>
<p>If the condition is not a sequence of digits or (R), it must be an assertion. This may be a positive or negative lookahead or lookbehind assertion. Consider this pattern, again containing non-significant white space, and with the two alternatives on the second line:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
</pre></div>
</div>
<p>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. In other words, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative; otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Comments<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The sequence (?# marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part in the pattern matching at all.</p>
<p>If the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code> option is set, an unescaped # character outside a character class introduces a comment that continues up to the next newline character in the pattern.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Recursive Patterns<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Consider the problem of matching a string in parentheses, allowing for unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth. Perl has provided an experimental facility that allows regular expressions to recurse (amongst other things). It does this by interpolating Perl code in the expression at run time, and the code can refer to the expression itself. A Perl pattern to solve the parentheses problem can be created like this:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>$re = qr{\( (?: (?&gt;[^()]+) | (?p{$re}) )* \)}x;
</pre></div>
</div>
<p>The (?p{...}) item interpolates Perl code at run time, and in this case refers recursively to the pattern in which it appears. Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports some special syntax for recursion of the entire pattern, and also for individual subpattern recursion.</p>
<p>The special item that consists of (? followed by a number greater than zero and a closing parenthesis is a recursive call of the subpattern of the given number, provided that it occurs inside that subpattern. (If not, it is a &#8220;subroutine&#8221; call, which is described in the next section.) The special item (?R) is a recursive call of the entire regular expression.</p>
<p>For example, this PCRE pattern solves the nested parentheses problem (assume the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTENDED</span></code> option is set so that white space is ignored):</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\( ( (?&gt;[^()]+) | (?R) )* \)
</pre></div>
</div>
<p>First it matches an opening parenthesis. Then it matches any number of substrings which can either be a sequence of non-parentheses, or a recursive match of the pattern itself (that is a correctly parenthesized substring). Finally there is a closing parenthesis.</p>
<p>If this were part of a larger pattern, you would not want to recurse the entire pattern, so instead you could use this:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>( \( ( (?&gt;[^()]+) | (?1) )* \) )
</pre></div>
</div>
<p>We have put the pattern into parentheses, and caused the recursion to refer to them instead of the whole pattern. In a larger pattern, keeping track of parenthesis numbers can be tricky. It may be more convenient to use named parentheses instead. For this, PCRE uses (?P&gt;name), which is an extension to the Python syntax that PCRE uses for named parentheses (Perl does not provide named parentheses). We could rewrite the above example as follows:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(?P&lt;pn&gt; \( ( (?&gt;[^()]+) | (?P&gt;pn) )* \) )
</pre></div>
</div>
<p>This particular example pattern contains nested unlimited repeats, and so the use of atomic grouping for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><span class="p">()</span>
</pre></div>
</div>
<p>it yields &#8220;no match&#8221; quickly. However, if atomic grouping is not used, the match runs for a very long time indeed because there are so many different ways the + and * repeats can carve up the subject, and all have to be tested before failure can be reported.</p>
<p>At the end of a match, the values set for any capturing subpatterns are those from the outermost level of the recursion at which the subpattern value is set. If you want to obtain intermediate values, a callout function can be used (see below and the pcrecallout documentation). If the pattern above is matched against:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ab</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span><span class="n">ef</span><span class="p">)</span>
</pre></div>
</div>
<p>the value for the capturing parentheses is &#8220;ef&#8221;, which is the last value taken on at the top level. If additional parentheses are added, giving:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)
   ^                        ^
   ^                        ^
</pre></div>
</div>
<p>the string they capture is &#8220;ab(cd)ef&#8221;, the contents of the top level parentheses. If there are more than 15 capturing parentheses in a pattern, PCRE has to obtain extra memory to store data during a recursion, which it does by using pcre_malloc, freeing it via pcre_free afterwards. If no memory can be obtained, the match fails with the <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_ERROR_NOMEMORY</span></code> error.</p>
<p>Do not confuse the (?R) item with the condition (R), which tests for recursion. Consider this pattern, which matches text in angle brackets, allowing for arbitrary nesting. Only digits are allowed in nested brackets (that is, when recursing), whereas any characters are permitted at the outer level.:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>&lt; (?: (?(R) \d++  | [^&lt;&gt;]*+) | (?R)) * &gt;
</pre></div>
</div>
<p>In this pattern, (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. The (?R) item is the actual recursive call.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Subpatterns As Subroutines<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>If the syntax for a recursive subpattern reference (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. An earlier example pointed out that the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>(sens|respons)e and \1ibility
</pre></div>
</div>
<p>matches &#8220;sense and sensibility&#8221; and &#8220;response and responsibility&#8221;, but not &#8220;sense and responsibility&#8221;. If instead the pattern:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sens</span><span class="o">|</span><span class="n">respons</span><span class="p">)</span><span class="n">e</span> <span class="n">and</span> <span class="p">(</span><span class="o">?</span><span class="mi">1</span><span class="p">)</span><span class="n">ibility</span>
</pre></div>
</div>
<p>is used, it does match &#8220;sense and responsibility&#8221; as well as the other two strings. Such references must, however, follow the subpattern to which they refer.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Callouts<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>Perl has a feature whereby using the sequence <code class="docutils literal"><span class="pre">(?{...})</span></code> causes arbitrary Perl code to be obeyed in the middle of matching a regular expression. This makes it possible, amongst other things, to extract different substrings that match the same pair of parentheses when there is a repetition.</p>
<p>PCRE provides a similar feature, but of course it cannot obey arbitrary Perl code. The feature is called &#8220;callout&#8221;. The caller of PCRE provides an external function by putting its entry point in the global variable pcre_callout. By default, this variable contains NULL, which disables all calling out.</p>
<p>Within a regular expression, (?C) indicates the points at which the external function is to be called. If you want to identify different callout points, you can put a number less than 256 after the letter C. The default value is zero. For example, this pattern has two callout points:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">?</span><span class="n">C1</span><span class="p">)</span><span class="n">abc</span><span class="p">(</span><span class="o">?</span><span class="n">C2</span><span class="p">)</span><span class="n">def</span>
</pre></div>
</div>
<p>During matching, when PCRE reaches a callout point (and pcre_callout is set), the external function is called. It is provided with the number of the callout, and, optionally, one item of data originally supplied by the caller of <code class="docutils literal"><span class="pre">pcre_exec()</span></code>. The callout function may cause matching to backtrack, or to fail altogether. A complete description of the interface to the callout function is given in the pcrecallout documentation.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Differences From Perl<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>This section escribes the differences in the ways that PCRE and Perl handle regular expressions. The differences described here are with respect to Perl 5.8.</p>
<ol class="arabic">
<li><p class="first">PCRE does not have full UTF-8 support. Details of what it does have are given in the section on UTF-8 support in the main pcre page.</p>
</li>
<li><p class="first">PCRE does not allow repeat quantifiers on lookahead assertions. Perl permits them, but they do not mean what you might think. For example, (?!a){3} does not assert that the next three characters are not &#8220;a&#8221;. It just asserts that the next character is not &#8220;a&#8221; three times.</p>
</li>
<li><p class="first">Capturing subpatterns that occur inside negative lookahead assertions are counted, but their entries in the offsets vector are never set. Perl sets its numerical variables from any such patterns that are matched before the assertion fails to match something (thereby succeeding), but only if the negative lookahead assertion contains just one branch.</p>
</li>
<li><p class="first">Though binary zero characters are supported in the subject string, they are not allowed in a pattern string because it is passed as a normal C string, terminated by zero. The escape sequence &#8220;0&#8221; can be used in the pattern to represent a binary zero.</p>
</li>
<li><p class="first">The following Perl escape sequences are not supported: l, u, L, U, P, p, N, and X. In fact these are implemented by Perl&#8217;s general string-handling and are not part of its pattern matching engine. If any of these are encountered by PCRE, an error is generated.</p>
</li>
<li><p class="first">PCRE does support the Q...E escape for quoting substrings. Characters in between are treated as literals. This is slightly different from Perl in that $ and &#64; are also handled as literals inside the quotes. In Perl, they cause variable interpolation (but of course PCRE does not have variables). Note the following examples:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span>Pattern            PCRE matches      Perl matches

\Qabc$xyz\E        abc$xyz           abc followed by the
                                      contents of $xyz
\Qabc\$xyz\E       abc\$xyz          abc\$xyz
\Qabc\E\$\Qxyz\E   abc$xyz           abc$xyz
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div>The Q...E sequence is recognized both inside and outside character classes.</div></blockquote>
<ol class="arabic simple" start="7">
<li>PCRE does not support the (?{code}) and (?p{code}) constructions. However, there is some experimental support for recursive patterns using the non-Perl items (?R), (?number) and (?P&gt;name). Also, the PCRE &#8220;callout&#8221; feature allows an external function to be called during pattern matching.</li>
<li>There are some differences that are concerned with the settings of captured strings when part of a pattern is repeated. For example, matching &#8220;aba&#8221; against the pattern <code class="regexp docutils literal"><span class="pre">/^(a(b)?)+$/</span></code> in Perl leaves $2 unset, but in PCRE it is set to &#8220;b&#8221;.</li>
<li>PCRE provides some extensions to the Perl regular expression facilities:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>Although lookbehind assertions must match fixed length strings, each alternative branch of a lookbehind assertion can match a different length of string. Perl requires them all to have the same length.</li>
<li>If <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_DOLLAR_ENDONLY</span></code> is set and <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_MULTILINE</span></code> is not set, the $ meta-character matches only at the very end of the string.</li>
<li>If <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_EXTRA</span></code> is set, a backslash followed by a letter with no special meaning is faulted.</li>
<li>If <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_UNGREEDY</span></code> is set, the greediness of the repetition quantifiers is inverted, that is, by default they are not greedy, but if followed by a question mark they are.</li>
<li><code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_ANCHORED</span></code> can be used to force a pattern to be tried only at the first matching position in the subject string.</li>
<li>The <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_NOTBOL</span></code>, <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_NOTEOL</span></code>, <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_NOTEMPTY</span></code>, and <code class="xref lpc lpc-macro docutils literal"><span class="pre">PCRE_NO_AUTO_CAPTURE</span></code> options for <code class="docutils literal"><span class="pre">pcre_exec()</span></code> have no Perl equivalents.</li>
<li>The (?R), (?number), and (?P&gt;name) constructs allows for recursive pattern matching (Perl can do this using the (?p{code}) construct, which PCRE cannot support.)</li>
<li>PCRE supports named capturing substrings, using the Python syntax.</li>
<li>PCRE supports the possessive quantifier &#8220;++&#8221; syntax, taken from Sun&#8217;s Java package.</li>
<li>The (R) condition, for testing recursion, is a PCRE extension.</li>
<li>The callout facility is PCRE-specific.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Notes<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>The &lt; and &gt; metacharacters from Henry Spencers package are not available in PCRE, but can be emulated with b, as required, also in conjunction with W or w.</p>
<p>In LDMud, backtracks are limited by the EVAL_COST runtime limit, to avoid freezing the driver with a match like <code class="docutils literal"><span class="pre">regexp(({&quot;=XX===================&quot;}),</span> <span class="pre">&quot;X(.+)+X&quot;)</span></code>.</p>
<p>LDMud doesn&#8217;t support PCRE callouts.</p>
</div>
<div class="section" id="l">
<span id="p"></span><span id="c"></span><span id=":"></span><span id="s"></span><span id="u"></span><span id="b"></span><span id="t"></span><span id="o"></span><span id="p"></span><span id="i"></span><span id="c"></span><h3>Limitations<a class="headerlink" href="#l" title="Permalink to this headline">¶</a></h3>
<p>There are some size limitations in PCRE but it is hoped that they will never in practice be relevant. The maximum length of a compiled pattern is 65539 (sic) bytes. All values in repeating quantifiers must be less than 65536. There maximum number of capturing subpatterns is 65535. There is no limit to the number of non-capturing subpatterns, but the maximum depth of nesting of all kinds of parenthesized subpattern, including capturing subpatterns, assertions, and other types of subpattern, is 200.</p>
<p>The maximum length of a subject string is the largest positive number that an integer variable can hold. However, PCRE uses recursion to handle subpatterns and indefinite repetition. This means that the available stack space may limit the size of a subject string that can be processed by certain patterns.</p>
</div>
<div class="section" id="LORE">
<h2>LORE<a class="headerlink" href="#LORE" title="Permalink to this headline">¶</a></h2>
<p>Author:</p>
<div class="highlight-pike"><div class="highlight"><pre><span></span><span class="n">Philip</span> <span class="n">Hazel</span> <span class="o">&lt;</span><span class="n">ph10</span><span class="o">@</span><span class="n">cam</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">uk</span><span class="o">&gt;</span>
<span class="n">University</span> <span class="n">Computing</span> <span class="n">Service</span><span class="p">,</span>
<span class="n">New</span> <span class="n">Museums</span> <span class="n">Site</span><span class="p">,</span>
<span class="n">Cambridge</span> <span class="n">CB2</span> <span class="mi">3</span><span class="n">QG</span><span class="p">,</span> <span class="n">England</span><span class="p">.</span>
<span class="nl">Phone</span><span class="p">:</span> <span class="o">+</span><span class="mi">44</span> <span class="mi">1223</span> <span class="mi">334714</span>
</pre></div>
</div>
</div>
<div class="section" id="see2also">
<h2>SEE ALSO<a class="headerlink" href="#see2also" title="Permalink to this headline">¶</a></h2>
<p><a href="#id1"><span class="problematic" id="id2">:concept:`regexp`</span></a>, <a href="#id3"><span class="problematic" id="id4">:concept:`hsregexp`</span></a></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Perl-compatible regular expressions</a><ul>
<li><a class="reference internal" href="#TOPIC">TOPIC</a></li>
<li><a class="reference internal" href="#DESCRIPTION">DESCRIPTION</a><ul>
<li><a class="reference internal" href="#l">Pcre Regular Expression Details</a></li>
<li><a class="reference internal" href="#l">Backslash</a></li>
<li><a class="reference internal" href="#l">Circumflex And Dollar</a></li>
<li><a class="reference internal" href="#l">Full Stop (period, Dot)</a></li>
<li><a class="reference internal" href="#l">Matching A Single Byte</a></li>
<li><a class="reference internal" href="#l">Square Brackets</a></li>
<li><a class="reference internal" href="#l">Posix Character Classes</a></li>
<li><a class="reference internal" href="#l">Vertical Bar</a></li>
<li><a class="reference internal" href="#l">Internal Option Setting</a></li>
<li><a class="reference internal" href="#l">Subpatterns</a></li>
<li><a class="reference internal" href="#l">Named Subpatterns</a></li>
<li><a class="reference internal" href="#l">Repetition</a></li>
<li><a class="reference internal" href="#l">Atomic Grouping And Possessive Quantifiers</a></li>
<li><a class="reference internal" href="#l">Back References</a></li>
<li><a class="reference internal" href="#l">Assertions</a></li>
<li><a class="reference internal" href="#l">CONDITIONAL SUBPATTERNS</a></li>
<li><a class="reference internal" href="#l">Comments</a></li>
<li><a class="reference internal" href="#l">Recursive Patterns</a></li>
<li><a class="reference internal" href="#l">Subpatterns As Subroutines</a></li>
<li><a class="reference internal" href="#l">Callouts</a></li>
<li><a class="reference internal" href="#l">Differences From Perl</a></li>
<li><a class="reference internal" href="#l">Notes</a></li>
<li><a class="reference internal" href="#l">Limitations</a></li>
<li><a class="reference internal" href="#LORE">LORE</a></li>
<li><a class="reference internal" href="#see2also">SEE ALSO</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../admin/overview.html">Administrating an ldmud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applied/overview.html">Driver-applied methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../efun/overview.html">External functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hook/overview.html">Driver-supported hooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internals/overview.html">Driver-internal docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../master/overview.html">Master-object methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../syntax/overview.html">LPC syntax</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="overview.html">Other topics</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;good question.
      
      |
      <a href="../_sources/topics/pcre.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>