<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>negotiation &mdash; LDMud UNRELEASED documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'UNRELEASED',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="LDMud UNRELEASED documentation" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="negotiation">
<div class="section" id="SYNOPSIS">
<h2>SYNOPSIS<a class="headerlink" href="#SYNOPSIS" title="Permalink to this headline">¶</a></h2>
<table class="docutils field-list" frame="void" id="lpc.negotiation" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">negotiation:</th><td class="field-body"><span class="first last">Telnet Negotiations</span></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="DESCRIPTION">
<h2>DESCRIPTION<a class="headerlink" href="#DESCRIPTION" title="Permalink to this headline">¶</a></h2>
<p>The telnet protocol is used to control textbased connections
between a client (the &#8216;telnet&#8217; program or a mud client) and a
server (the game driver). Most of the options offered by the
protocol are optional and need to be negotiated between the
client and the server. Consequently, and due to their
specialized nature, mud clients don&#8217;t have to support the full
telnet option feature set.</p>
<p>For the server to find out if a client supports the telnet
protocol at all, one good approach is to issue a simple,
commonly used telnet command to the client. If the client reaction
conforms to the protocol (or sends telnet commands itself), the
mud can continue to negotiate further options. If the client
does not react, the mud can safely refrain from further
negotiations.</p>
<p>The following list is a more or less comprehensive overview of
the telnet related RFCs (available for example on
<a class="reference external" href="http://www.faqs.org/rfcs">http://www.faqs.org/rfcs</a>):</p>
<blockquote>
<div><p>RFC Title                                              rel. Code</p>
<p>495 TELNET Protocol Specification
513 Comments on the new TELNET specifications
559 Comments on the new TELNET Protocol and its Implem
595 Some Thoughts in Defense of the TELNET Go-Ahead
596 Second Thoughts on Telnet Go-Ahead
652 Telnet Output Carriage-Return Disposition Option   NAOCRD     10
653 Telnet Output Horizontal Tabstops Option           NAOHTS     11
654 Telnet Output Horizontal Tab Disposition Option    NAOHTD     12
655 Telnet Output Formfeed Disposition Option          NAOFFD     13
656 Telnet Output Vertical Tabstops Option             NAOVTS     14
657 Telnet Output Vertical Tab Disposition Option      NAOVTD     15
658 Telnet Output Linefeed Disposition                 NAOLFD     16
698 Telnet Extended Ascii Option                       X-ASCII    17
727 Telnet Logout Option                               LOGOUT     18
728 A Minor Pitfall in the Telnet Protocol
735 Revised TELNET Byte Macro Option                   BM         19
749 Telnet SUPDUP-OUTPUT Option                        SUPDUP     22
764 Telnet Protocol Specification
779 Telnet SEND-LOCATION Option                        SENDLOC    23
818 The Remote User Telnet Service
854 Telnet Protocol Specification
855 Telnet Option Specifications
856 Telnet Binary Transmission                         BINARY      0
857 Telnet Echo Option                                 ECHO        1
858 Telnet Suppress Go Ahead Option                    SGA         3
859 Telnet Status Option                               STATUS      5
860 Telnet Timing Mark Option                          TM          6
861 Telnet Extended Options - List Option              EXOPL     255
884 Telnet Terminal Type Option                        TTYPE      24
885 Telnet End of Record Option                        EOR        25
930 Telnet Terminal Type Option                        TTYPE      24
933 Output Marking Telnet Option                       OUTMRK     27
946 Telnet Terminal Location Number Option             TTYLOC     28</p>
</div></blockquote>
<p>1043 Telnet Data Entry Terminal Option DODIIS Implement DET        20
1053 Telnet X.3 PAD Option                              X.3-PAD    30
1073 Telnet Window Size Option                          NAWS       31
1079 Telnet Terminal Speed Option                       TSPEED     32
1080 Telnet Remote Flow Control Option                  FLOWCTRL   33
1091 Telnet Terminal-Type Option                        TTYPE      24
1096 Telnet X Display Location Option                   XDISPLOC   35
1116 Telnet Linemode Option                             LINEMODE   34
1143 The Q Method of Implementing TELNET Option Negotia
1184 Telnet Linemode Option                             LINEMODE   34
1372 Telnet Remote Flow Control Option                  FLOWCTRL   33
1408 Telnet Environment Option                          ENVIRON    36
1571 Telnet Environment Option Interoperability Issues
1572 Telnet Environment Option                          NEWENV     39
2066 Telnet Charset Option                              CHARSET    42
2217 Telnet Com Port Control Option                     COMPORT    44
2877 5250 Telnet Enhancements</p>
<p>All negotiations start with the special character IAC which is
defined in /usr/include/arpa/telnet.h (or in
src/driver/telnet.h for 3.2(.1)) and has the decimal value of
255. Negotiations are based on different telnetoptions (their
values are defined in telnet.h too). Before a negotiation can
start the client and the server have to agree that they
support the option. This works in the following way:</p>
<p>If a client wants to send something to the server it has to
send &#8216;IAC WILL option&#8217; (For terminaltype negotation this would
be the 3 bytes 255,251,24; again, check telnet.h) to confirm
that it is able to do that. If the server is supporting that
option and wants to receive something it sends &#8216;IAC DO option&#8217;
(255,253,option)</p>
<p>If one side is receiving an &#8216;IAC WILL option&#8217; and has not yet
sent with DO or DONT it has to respond with either &#8216;IAC DO
option&#8217; if it will support this negotiation or &#8216;IAC DONT
option&#8217; if it won&#8217;t.</p>
<p>If one side is receiving an &#8216;IAC DO option&#8217; and has not yet
sent a WILL or WONT it has to reply with either &#8216;IAC WILL
option&#8217; if it supports the option or &#8216;IAC WONT option&#8217; if not.</p>
<p>A small example: Lets assume we want to negotiate
terminaltype. (TELOPT_TTYPE with value 24). client is the
telnet executable on the playerside, the server is the
gamedriver.</p>
<blockquote>
<div><blockquote>
<div>client                        server</div></blockquote>
<dl class="docutils">
<dt>IAC WILL TTYPE</dt>
<dd>IAC DO TTYPE</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Or:</dt>
<dd><blockquote class="first">
<div>IAC DO TTYPE</div></blockquote>
<p class="last">IAC WILL TTYPE</p>
</dd>
</dl>
<p>After this we are ready to transfer the terminaltype from the
client to the server as explained below.</p>
<p>Now we are ready to start the real negotiations. I explain the
3 options I have currently implemented.</p>
<p>First TerminalType aka TTYPE aka 24 aka TELOPT_TTYPE assuming
the client and the server have exchanged WILL/DO.</p>
<p>The server is now free to send &#8216;IAC SB TELOPT_TTYPE
TELQUAL_SEND IAC SE&#8217; which will be replied with &#8216;IAC SB
TELOPT_TTYPE TELQUAL_IS terminaltype IAC SE&#8217; where
terminaltype is a non-zero terminated string (it&#8217;s terminated
by the IAC) (For values look up telnet.h) AND switch the
client&#8217;s terminalemulation to &#8216;terminaltype&#8217;. terminaltype is
case-insensitive. terminal-type may be UNKNOWN. The server may
repeat the SEND request and the client will respond with the
next preferred terminaltype. If this is the same as the
previous received, it marks the end of the list of
terminaltypes. The next SEND request will start the
terminaltypes from the beginning.</p>
<dl class="docutils">
<dt>Example: (we have exchanged WILL/DO already)</dt>
<dd><dl class="first last docutils">
<dt>client                                server</dt>
<dd>IAC SB TTYPE SEND IAC SE</dd>
</dl>
</dd>
<dt>IAC SB TTYPE IS VT200 IAC SE</dt>
<dd>IAC SB TTYPE SEND IAC SE</dd>
<dt>IAC SB TTYPE IS VT100 IAC SE</dt>
<dd>IAC SB TTYPE SEND IAC SE</dd>
<dt>IAC SB TTYPE IS VT52 IAC SE</dt>
<dd>IAC SB TTYPE SEND IAC SE</dd>
</dl>
<p>IAC SB TTYPE IS VT52 IAC SE
/* this marks that we have all terminaltypes. We decide to use the</p>
<blockquote>
<div><ul class="simple">
<li>vt200 mode so we have to skip to VT200</li>
</ul>
<dl class="docutils">
<dt><a href="#id1"><span class="problematic" id="id2">*</span></a>/</dt>
<dd>IAC SB TTYPE SEND IAC SE</dd>
</dl>
</div></blockquote>
<p>IAC SB TTYPE IS VT200 IAC SE</p>
<p>Next important option is NAWS (31) or WindowSizeNegotiation.</p>
<p>This one is a bit easier than terminaltype. After having
received a IAC DO NAWS from the server, the client will reply
with IAC WILL NAWS and immediately after that send IAC SB NAWS
columns_high columns_low lines_high lines_low IAC SE where
xx_low refers to the lowbyte of xx and xx_high refers to the
highbyte of xx. This will be automagically resent at every
windowresize (when the client gets a SIGWINCH for example) or
at your request with &#8216;IAC SB NAWS SEND IAC SE&#8217;.</p>
<dl class="docutils">
<dt>Example: (WILL/DO exchanged)</dt>
<dd>client                                server</dd>
<dt>IAC SB NAWS 0 80 0 24 IAC SE         /* the standard vt100 windowsize <a href="#id3"><span class="problematic" id="id4">*</span></a>/</dt>
<dd>/* no reply <a href="#id5"><span class="problematic" id="id6">*</span></a>/</dd>
</dl>
<p>And, a bit less important but most complex, the LINEMODE (34)
option. It was implemented it due to the fact, that
some weird DOS telnets would not work otherwise. Implemented
are only the absolute basic feature, which is the actual
switching the telnet to linemode. After exchanging WILL/DO the
server sends a modechange request to the client using IAC SB
LINEMODE LM_MODE MODE_EDIT IAC SE, which should turn on local
commandline-editing for the client. If a client supports
LINEMODE it HAS to support this modechange. The client will
reply with IAC SB LINEMODE LM_MODE MODE_EDIT|MODE_ACK IAC SE
(x|y is bitwise or). That&#8217;s it for linemode. (You will perhaps
receive other IAC SB LINEMODEs with other LM_xxx ... you may
ignore them. (At least IRIX 5.x sends IAC SB LINEMODE LM_SLC
.... IAC SE which declares the local characterset.)).</p>
<p>Example: (WILL/DO negotiated)</p>
<blockquote>
<div><dl class="docutils">
<dt>client                                        server</dt>
<dd><dl class="first last docutils">
<dt>IAC SB LINEMODE LM_MODE</dt>
<dd>MODE_EDIT IAC SE</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>IAC SB LINEMODE LM_MODE</dt>
<dd>MODE_EDIT|MODE_ACK IAC SE</dd>
<dt>Note: The option is more interesting than it looks here. For</dt>
<dd>example it supports a mixed mode between linemode and
charactermode, flushing the input at certain characters (at
ESC or TAB for shell-like commandline completition). We suggest
reading RFC 1184.</dd>
</dl>
<p>You might be interested in TELOPT_XDISPLAYLOC and TELOPT_ENVIRON too.</p>
<p>Now, how to implement this using LDMud?</p>
<ol class="arabic" start="0">
<li><dl class="first docutils">
<dt>Patch src/driver/comm1.c, function init_telopts() to include</dt>
<dd><p class="first last">telopts_do[TELOPT_XXX] = reply_h_telnet_neg;
telopts_dont[TELOPT_XXX] = reply_h_telnet_neg;
telopts_will[TELOPT_XXX] = reply_h_telnet_neg;
telopts_wont[TELOPT_XXX] = reply_h_telnet_neg;</p>
</dd>
</dl>
<p>for every telnet negotiation you want to use.
Do not overwrite the TELOPT_ECHO and TELOPT_SGA hooks.</p>
<p>Alternatively, set the driver hook H_NOECHO in master.c:
this diverts _all_ telnet data into the mudlib.</p>
</li>
<li><dl class="first docutils">
<dt>Add a new driver hook to master.c just below the others.</dt>
<dd><p class="first last">set_driver_hook(H_TELNET_NEG,&#8221;telnet_neg&#8221;),</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Make a telnet.h for your mudlib... just change the arrays in</dt>
<dd><p class="first last">src/driver/telnet.h.</p>
</dd>
</dl>
</li>
<li><p class="first">define a function</p>
<blockquote>
<div><p>void telnet_neg(int cmd, int option, int * optargs)</p>
</div></blockquote>
<p>in your interactive objects (login.c , shells, player.c or
whereever). And note, in ALL objects, through which a
player is handed through (in TAPPMud these are login.c and
player.c). [Ok, master.c is interactive for a very short
time too, but it won&#8217;t accept input, will it?]
&#8216;cmd&#8217; will be TELCMD_xxxx (see telnet.h), &#8216;option&#8217; one of
TELOPT_xxxx and &#8216;optargs&#8217; will be an array of ints (bytes in
fact) when &#8216;cmd&#8217; is SB.
Parse &#8216;cmd&#8217;/&#8217;option&#8217; and reply with appropiate answers
using binary_message() (appropiate meaning sending the
right DO/DONT/WILL/WONT if not sent before and using the SB
return values).</p>
</li>
</ol>
<dl class="docutils">
<dt>3.1. Send IAC DO TTYPE IAC DO NAWS IAC DO LINEMODE at the</dt>
<dd>first time you can do it (before cat()ing /WELCOME perhaps).</dd>
<dt>3.2. Note all sent and received WILL/WONT/DO/DONT options for</dt>
<dd>conforming to the standard, avoiding endless loops and for
easy debugging :)</dd>
<dt>3.3. Pass those recevied/sent data and other data when the</dt>
<dd>interactive object is changed (from login.c to player.c or
at other bodychanges). Clear the data when the player goes
linkdead or quits. You won&#8217;t need to save this data.</dd>
</dl>
<p>3.4. Lower_case() terminaltypes... ;)
3.5. Use reasonable defaultvalues if the client does not</p>
<blockquote>
<div>support one of the options. (columns 80, lines 24 if not
NAWS, unknown or vt100 for no terminaltype)</div></blockquote>
<p>The WILL/WONT/DO/DONT data is best saved in a mapping looking
like this:</p>
<blockquote>
<div><dl class="docutils">
<dt>([ &#8220;received&#8221;: ([ option1: DO_DONT_OR_0;WILL_WONT_OR_0, ... ])</dt>
<dd>, &#8220;sent&#8221;    : ([ option1: DO_DONT_OR_0;WILL_WONT_OR_0, ... ])</dd>
</dl>
<p>])</p>
</div></blockquote>
<p>(Ok, it can be done better. But not without confusing <em>me</em>
more.)</p>
<dl class="docutils">
<dt>Before sending anything check</dt>
<dd>TN[&#8220;sent&#8221;][option,0_if_do_dont_or_1_if_will_wont]</dd>
</dl>
<p>so you don&#8217;t enter endless loops, save network traffic and the
like.</p>
<p>The windowsize is best saved in the players environment
variables so that he can modify them later on. (Or in two
integers in the player object...). Use for these values is
clear I think.</p>
<p>The terminaltypes received using above mentioned method are
best stored in an array. The actual set terminaltype is best
stored in an environment variable where the player can modify
it. Upon modifying it the IAC SB TTYPE SEND IAC SE cycle
should be started to match the emulation to the entered new
terminaltype. You then may use data retrieved from
/etc/termcap (man 5 termcap) or /usr/lib/terminfo/<em>/</em> (SysVID,
man 5 terminfo) to implement terminalcontrol codes dependend
on the terminaltype. /etc/termcap may prove to be the easiest
way tough /usr/lib/terminfo/<em>/</em> is the newer (and better) SysV
way of doing it.</p>
<p>[Anyone got a description of the internal terminfo format for
me? -Marcus]</p>
<p>LINEMODE replies may be left alone if only using the mode
change to MODE_EDIT</p>
<p>Some statistics about what clients support telnet negotiations:</p>
<p>Tinyfugue and some other mudclients usually do not support
negotiations.</p>
<p>Except for TF, which supports the Telnet End-Of-Record option
as marker for the end of the prompt. So if you send IAC EOR
after every prompt, it will print the prompt always in the
input window. (Do not forget to negotiate that. First IAC WILL
TELOPT_EOR/wait for IAC DO TELOPT_EOR). Newer versions of
TF will support NAWS and there will be a patch for TTYPE
negotiation available soon.</p>
<p>All telnets able to do negotiations I&#8217;ve encountered support
the TTYPE option.
HP9.x,Irix5.x,Linux,EP/IX,CUTELNET/NCSATELNET (Novell) and
perhaps more support NAWS.
At least Irix5.x,Linux,CU/NCSATELNET support LINEMODE.
SUN does not support NAWS and LINEMODE neither in SunOS 4.1.3
nor in Solaris 2.3.</p>
<p>For getting RFCs you can for example use
<a class="reference external" href="ftp://ftp.uni-erlangen.de/pub/doc/rfc/">ftp://ftp.uni-erlangen.de/pub/doc/rfc/</a></p>
<div class="section" id="BUGS">
<span id="lpc.BUGS"></span><h3>BUGS<a class="headerlink" href="#BUGS" title="Permalink to this headline">¶</a></h3>
</div>
<p>Not all aspects of the options are mentioned to keep this doc
at a reasonable size. Refer to the RFCs to get more confused.</p>
<div class="section" id="CREDITS">
<span id="lpc.CREDITS"></span><h3>CREDITS<a class="headerlink" href="#CREDITS" title="Permalink to this headline">¶</a></h3>
</div>
<p>Provided by <a class="reference external" href="mailto:Marcus&#37;&#52;&#48;TAPPMud">Marcus<span>&#64;</span>TAPPMud</a> (Marcus Meissner,
&lt;<a class="reference external" href="mailto:msmeissn&#37;&#52;&#48;cip&#46;informatik&#46;uni-erlangen&#46;de">msmeissn<span>&#64;</span>cip<span>&#46;</span>informatik<span>&#46;</span>uni-erlangen<span>&#46;</span>de</a>&gt;).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">negotiation</a><ul>
<li><a class="reference internal" href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a class="reference internal" href="#DESCRIPTION">DESCRIPTION</a><ul>
<li><a class="reference internal" href="#BUGS">BUGS</a></li>
<li><a class="reference internal" href="#CREDITS">CREDITS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hook/hook.html">hooks</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;good question.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="../_sources/concepts/negotiation.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>