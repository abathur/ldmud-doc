<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pcre &mdash; LDMud UNRELEASED documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'UNRELEASED',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="LDMud UNRELEASED documentation" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pcre">
<div class="section" id="SYNOPSIS">
<h2>SYNOPSIS<a class="headerlink" href="#SYNOPSIS" title="Permalink to this headline">¶</a></h2>
<table class="docutils field-list" frame="void" id="lpc.pcre" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">pcre:</th><td class="field-body"><span class="first last">Perl-compatible regular expressions</span></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="DESCRIPTION">
<h2>DESCRIPTION<a class="headerlink" href="#DESCRIPTION" title="Permalink to this headline">¶</a></h2>
<p>This document describes the regular expressions supported by the PCRE
package. When the package is compiled into the driver, the macro
__PCRE__ is defined.</p>
<p>Most of this manpage is lifted directly from the original PCRE manpage
(dated January 2003).</p>
<p>The PCRE library is a set of functions that implement regular
expression pattern matching using the same syntax and semantics as
Perl 5, with just a few differences (see below). The current
implementation corresponds to Perl 5.005, with some additional features
from later versions. This includes some experimental, incomplete
support for UTF-8 encoded strings. Details of exactly what is and what
is not supported are given below.</p>
<div class="section" id="PCRE REGULAR EXPRESSION DETAILS">
<span id="lpc.PCRE REGULAR EXPRESSION DETAILS"></span><h3>PCRE REGULAR EXPRESSION DETAILS<a class="headerlink" href="#PCRE REGULAR EXPRESSION DETAILS" title="Permalink to this headline">¶</a></h3>
<p>The syntax and semantics of the regular expressions supported by PCRE
are described below. Regular expressions are also described in the Perl
documentation and in a number of other books, some of which have
copious examples. Jeffrey Friedl&#8217;s &#8220;Mastering Regular Expressions&#8221;,
published by O&#8217;Reilly, covers them in great detail. The description
here is intended as reference documentation.</p>
<p>The basic operation of PCRE is on strings of bytes. However, there is
also support for UTF-8 character strings. To use this support you must
build PCRE to include UTF-8 support, and then call pcre_compile() with
the PCRE_UTF8 option. How this affects the pattern matching is
mentioned in several places below. There is also a summary of UTF-8
features in the section on UTF-8 support in the main pcre page.</p>
<p>A regular expression is a pattern that is matched against a subject
string from left to right. Most characters stand for themselves in a
pattern, and match the corresponding characters in the subject. As a
trivial example, the pattern:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">The</span> <span class="n">quick</span> <span class="n">brown</span> <span class="n">fox</span>
</pre></div>
</div>
<p>matches a portion of a subject string that is identical to itself. The
power of regular expressions comes from the ability to include
alternatives and repetitions in the pattern. These are encoded in the
pattern by the use of meta-characters, which do not stand for
themselves but instead are interpreted in some special way.</p>
<p>There are two different sets of meta-characters: those that are
recognized anywhere in the pattern except within square brackets, and
those that are recognized in square brackets. Outside square brackets,
the meta-characters are as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">\\</span></code></dt>
<dd>general escape character with several uses</dd>
<dt><code class="docutils literal"><span class="pre">^</span></code></dt>
<dd>assert start of string (or line, in multiline mode)</dd>
<dt><code class="docutils literal"><span class="pre">$</span></code></dt>
<dd>assert end of string (or line, in multiline mode)</dd>
<dt><code class="docutils literal"><span class="pre">.</span></code></dt>
<dd>match any character except newline (by default)</dd>
<dt><code class="docutils literal"><span class="pre">[</span></code></dt>
<dd>start character class definition</dd>
<dt><code class="docutils literal"><span class="pre">|</span></code></dt>
<dd>start of alternative branch</dd>
<dt><code class="docutils literal"><span class="pre">(</span></code></dt>
<dd>start subpattern</dd>
<dt><code class="docutils literal"><span class="pre">)</span></code></dt>
<dd>end subpattern</dd>
<dt><code class="docutils literal"><span class="pre">?</span></code></dt>
<dd><p class="first">extends the meaning of <code class="docutils literal"><span class="pre">(</span></code></p>
<p>also 0 or 1 quantifier</p>
<p class="last">also quantifier minimizer</p>
</dd>
<dt><code class="docutils literal"><span class="pre">*</span></code></dt>
<dd>0 or more quantifier</dd>
<dt><code class="docutils literal"><span class="pre">+</span></code></dt>
<dd><p class="first">1 or more quantifier</p>
<p class="last">also &#8220;possessive quantifier&#8221;</p>
</dd>
<dt><code class="docutils literal"><span class="pre">{</span></code></dt>
<dd>start min/max quantifier</dd>
</dl>
<p>Part of a pattern that is in square brackets is called a &#8220;character
class&#8221;. In a character class the only meta-characters are:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">\</span></code></dt>
<dd>general escape character</dd>
<dt><code class="docutils literal"><span class="pre">^</span></code></dt>
<dd>negate the class, but only if the first character</dd>
<dt><code class="docutils literal"><span class="pre">-</span></code></dt>
<dd>indicates character range</dd>
<dt><code class="docutils literal"><span class="pre">[</span></code></dt>
<dd>POSIX character class (only if followed by POSIX
syntax)</dd>
<dt><code class="docutils literal"><span class="pre">]</span></code></dt>
<dd>terminates the character class</dd>
</dl>
<p>The following sections describe the use of each of the meta-characters.</p>
</div>
<div class="section" id="BACKSLASH">
<span id="lpc.BACKSLASH"></span><h3>BACKSLASH<a class="headerlink" href="#BACKSLASH" title="Permalink to this headline">¶</a></h3>
<p>The backslash character has several uses. Firstly, if it is followed by
a non-alphameric character, it takes away any special meaning that
character may have. This use of backslash as an escape character
applies both inside and outside character classes.</p>
<p>For example, if you want to match a * character, you write * in the
pattern. This escaping action applies whether or not the following
character would otherwise be interpreted as a meta-character, so it is
always safe to precede a non-alphameric with backslash to specify that
it stands for itself. In particular, if you want to match a backslash,
you write \.</p>
<p>If a pattern is compiled with the PCRE_EXTENDED option, whitespace in
the pattern (other than in a character class) and characters between a
# outside a character class and the next newline character are ignored.
An escaping backslash can be used to include a whitespace or #
character as part of the pattern.</p>
<p>If you want to remove the special meaning from a sequence of
characters, you can do so by putting them between Q and E. This is
different from Perl in that $ and &#64; are handled as literals in Q...E
sequences in PCRE, whereas in Perl, $ and &#64; cause variable
interpolation. Note the following examples:</p>
<blockquote>
<div><p>Pattern            PCRE matches   Perl matches</p>
<dl class="docutils">
<dt>Qabc$xyzE        abc$xyz        abc followed by the</dt>
<dd>contents of $xyz</dd>
</dl>
<p>Qabc$xyzE       abc$xyz       abc$xyz
QabcE$QxyzE   abc$xyz        abc$xyz</p>
</div></blockquote>
<p>The Q...E sequence is recognized both inside and outside character
classes.</p>
<p>A second use of backslash provides a way of encoding non-printing
characters in patterns in a visible manner. There is no restriction on
the appearance of non-printing characters, apart from the binary zero
that terminates a pattern, but when a pattern is being prepared by text
editing, it is usually easier to use one of the following escape
sequences than the binary character it represents:</p>
<blockquote>
<div>a        alarm, that is, the BEL character (hex 07)
cx       &#8220;control-x&#8221;, where x is any character
e        escape (hex 1B)
f        formfeed (hex 0C)
n        newline (hex 0A)
r        carriage return (hex 0D)
t        tab (hex 09)
ddd      character with octal code ddd, or backreference
xhh      character with hex code hh
x{hhh..} character with hex code hhh... (UTF-8 mode only)</div></blockquote>
<p>The precise effect of cx is as follows: if x is a lower case letter,
it is converted to upper case. Then bit 6 of the character (hex 40) is
inverted. Thus cz becomes hex 1A, but c{ becomes hex 3B, while c;
becomes hex 7B.</p>
<p>After x, from zero to two hexadecimal digits are read (letters can be
in upper or lower case). In UTF-8 mode, any number of hexadecimal
dig-its may appear between x{ and }, but the value of the character
code must be less than 2**31 (that is, the maximum hexadecimal value is
7FFFFFFF). If characters other than hexadecimal digits appear between
x{ and }, or if there is no terminating }, this form of escape is not
recognized. Instead, the initial x will be interpreted as a basic
hexadecimal escape, with no following digits, giving a byte whose value
is zero.</p>
<p>Characters whose value is less than 256 can be defined by either of the
two syntaxes for x when PCRE is in UTF-8 mode. There is no difference
in the way they are handled. For example, xdc is exactly the same as
x{dc}.</p>
<p>After 0 up to two further octal digits are read. In both cases, if
there are fewer than two digits, just those that are present are used.
Thus the sequence 0x07 specifies two binary zeros followed by a BEL
character (code value 7). Make sure you supply two digits after the
initial zero if the character that follows is itself an octal digit.</p>
<p>The handling of a backslash followed by a digit other than 0 is
complicated. Outside a character class, PCRE reads it and any following
digits as a decimal number. If the number is less than 10, or if there
have been at least that many previous capturing left parentheses in the
expression, the entire sequence is taken as a back reference. A
description of how this works is given later, following the discussion
of parenthesized subpatterns.</p>
<p>Inside a character class, or if the decimal number is greater than 9
and there have not been that many capturing subpatterns, PCRE re-reads
up to three octal digits following the backslash, and generates a
single byte from the least significant 8 bits of the value. Any
subsequent digits stand for themselves. For example:</p>
<blockquote>
<div><p>040   is another way of writing a space
40    is the same, provided there are fewer than 40</p>
<blockquote>
<div>previous capturing subpatterns</div></blockquote>
<p>7     is always a back reference
11    might be a back reference, or another way of</p>
<blockquote>
<div>writing a tab</div></blockquote>
<p>011   is always a tab
0113  is a tab followed by the character &#8220;3&#8221;
113   might be a back reference, otherwise the</p>
<blockquote>
<div>character with octal code 113</div></blockquote>
<dl class="docutils">
<dt>377   might be a back reference, otherwise</dt>
<dd>the byte consisting entirely of 1 bits</dd>
<dt>81    is either a back reference, or a binary zero</dt>
<dd>followed by the two characters &#8220;8&#8221; and &#8220;1&#8221;</dd>
</dl>
</div></blockquote>
<p>Note that octal values of 100 or greater must not be introduced by a
leading zero, because no more than three octal digits are ever read.</p>
<p>All the sequences that define a single byte value or a single UTF-8
character (in UTF-8 mode) can be used both inside and outside character
classes. In addition, inside a character class, the sequence b is
interpreted as the backspace character (hex 08). Outside a character
class it has a different meaning (see below).</p>
<p>The third use of backslash is for specifying generic character types:</p>
<blockquote>
<div>d     any decimal digit
D     any character that is not a decimal digit
s     any whitespace character
S     any character that is not a whitespace character
w     any &#8220;word&#8221; character
W     any &#8220;non-word&#8221; character</div></blockquote>
<p>Each pair of escape sequences partitions the complete set of characters
into two disjoint sets. Any given character matches one, and only one,
of each pair.</p>
<p>In UTF-8 mode, characters with values greater than 255 never match d,
s, or w, and always match D, S, and W.</p>
<p>For compatibility with Perl, s does not match the VT character (code
11). This makes it different from the the POSIX &#8220;space&#8221; class. The s
characters are HT (9), LF (10), FF (12), CR (13), and space (32).</p>
<p>A &#8220;word&#8221; character is any letter or digit or the underscore character,
that is, any character which can be part of a Perl &#8220;word&#8221;. The
definition of letters and digits is controlled by PCRE&#8217;s character
tables, and may vary if locale-specific matching is taking place (see
&#8220;Locale support&#8221; in the pcreapi page). For example, in the &#8220;fr&#8221;
(French) locale, some character codes greater than 128 are used for
accented letters, and these are matched by w.</p>
<p>These character type sequences can appear both inside and outside
character classes. They each match one character of the appropriate
type. If the current matching point is at the end of the subject
string, all of them fail, since there is no character to match.</p>
<p>The fourth use of backslash is for certain simple assertions. An
assertion specifies a condition that has to be met at a particular
point in a match, without consuming any characters from the subject
string. The use of subpatterns for more complicated assertions is
described below. The backslashed assertions are:</p>
<blockquote>
<div>b     matches at a word boundary
B     matches when not at a word boundary
A     matches at start of subject
Z     matches at end of subject or before newline at end
z     matches at end of subject
G     matches at first matching position in subject</div></blockquote>
<p>These assertions may not appear in character classes (but note that b
has a different meaning, namely the backspace character, inside a
character class).</p>
<p>A word boundary is a position in the subject string where the current
character and the previous character do not both match w or W (i.e.
one matches w and the other matches W), or the start or end of the
string if the first or last character matches w, respectively.</p>
<p>The A, Z, and z assertions differ from the traditional circumflex
and dollar (described below) in that they only ever match at the very
start and end of the subject string, whatever options are set. Thus,
they are independent of multiline mode.</p>
<p>They are not affected by the PCRE_NOTBOL or PCRE_NOTEOL options. If the
startoffset argument of pcre_exec() is non-zero, indicating that
matching is to start at a point other than the beginning of the
subject, A can never match. The difference between Z and z is that
Z matches before a newline that is the last character of the string as
well as at the end of the string, whereas z matches only at the end.</p>
<p>The G assertion is true only when the current matching position is at
the start point of the match, as specified by the startoffset argument
of pcre_exec(). It differs from A when the value of startoffset is
non-zero. By calling pcre_exec() multiple times with appropriate
arguments, you can mimic Perl&#8217;s /g option, and it is in this kind of
implementation where G can be useful.</p>
<p>Note, however, that PCRE&#8217;s interpretation of G, as the start of the
current match, is subtly different from Perl&#8217;s, which defines it as the
end of the previous match. In Perl, these can be different when the
previously matched string was empty. Because PCRE does just one match
at a time, it cannot reproduce this behaviour.</p>
<p>If all the alternatives of a pattern begin with G, the expression is
anchored to the starting match position, and the &#8220;anchored&#8221; flag is set
in the compiled regular expression.</p>
</div>
<div class="section" id="CIRCUMFLEX AND DOLLAR">
<span id="lpc.CIRCUMFLEX AND DOLLAR"></span><h3>CIRCUMFLEX AND DOLLAR<a class="headerlink" href="#CIRCUMFLEX AND DOLLAR" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, in the default matching mode, the circumflex
character is an assertion which is true only if the current matching
point is at the start of the subject string. If the startoffset
argument of pcre_exec() is non-zero, circumflex can never match if the
PCRE_MULTILINE option is unset. Inside a character class, circumflex
has an entirely different meaning (see below).</p>
<p>Circumflex need not be the first character of the pattern if a number
of alternatives are involved, but it should be the first thing in each
alternative in which it appears if the pattern is ever to match that
branch. If all possible alternatives start with a circumflex, that is,
if the pattern is constrained to match only at the start of the
subject, it is said to be an &#8220;anchored&#8221; pattern. (There are also other
constructs that can cause a pattern to be anchored.)</p>
<p>A dollar character is an assertion which is true only if the current
matching point is at the end of the subject string, or immediately
before a newline character that is the last character in the string (by
default). Dollar need not be the last character of the pattern if a
number of alternatives are involved, but it should be the last item in
any branch in which it appears. Dollar has no special meaning in a
character class.</p>
<p>The meaning of dollar can be changed so that it matches only at the
very end of the string, by setting the PCRE_DOLLAR_ENDONLY option at
compile time. This does not affect the Z assertion.</p>
<p>The meanings of the circumflex and dollar characters are changed if the
PCRE_MULTILINE option is set. When this is the case, they match
immediately after and immediately before an internal newline character,
respectively, in addition to matching at the start and end of the
subject string. For example, the pattern /^abc$/ matches the subject
string &#8220;defnabc&#8221; in multiline mode, but not otherwise. Consequently,
patterns that are anchored in single line mode because all branches
start with ^ are not anchored in multiline mode, and a match for
circumflex is possible when the startoffset argument of pcre_exec() is
non-zero. The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE
is set.</p>
<p>Note that the sequences A, Z, and z can be used to match the start
and end of the subject in both modes, and if all branches of a pattern
start with A it is always anchored, whether PCRE_MULTILINE is set or
not.</p>
</div>
<div class="section" id="FULL STOP (PERIOD, DOT)">
<span id="lpc.FULL STOP (PERIOD, DOT)"></span><h3>FULL STOP (PERIOD, DOT)<a class="headerlink" href="#FULL STOP (PERIOD, DOT)" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, a dot in the pattern matches any one
character in the subject, including a non-printing character, but not
(by default) newline. In UTF-8 mode, a dot matches any UTF-8 character,
which might be more than one byte long, except (by default) for
newline. If the PCRE_DOTALL option is set, dots match newlines as well.
The handling of dot is entirely independent of the handling of
circumflex and dollar, the only relationship being that they both
involve newline characters. Dot has no special meaning in a character
class.</p>
</div>
<div class="section" id="MATCHING A SINGLE BYTE">
<span id="lpc.MATCHING A SINGLE BYTE"></span><h3>MATCHING A SINGLE BYTE<a class="headerlink" href="#MATCHING A SINGLE BYTE" title="Permalink to this headline">¶</a></h3>
<p>Outside a character class, the escape sequence C matches any one byte,
both in and out of UTF-8 mode. Unlike a dot, it always matches a
newline. The feature is provided in Perl in order to match individual
bytes in UTF-8 mode. Because it breaks up UTF-8 characters into
individual bytes, what remains in the string may be a malformed UTF-8
string. For this reason it is best avoided.</p>
<p>PCRE does not allow C to appear in lookbehind assertions (see below),
because in UTF-8 mode it makes it impossible to calculate the length of
the lookbehind.</p>
</div>
<div class="section" id="SQUARE BRACKETS">
<span id="lpc.SQUARE BRACKETS"></span><h3>SQUARE BRACKETS<a class="headerlink" href="#SQUARE BRACKETS" title="Permalink to this headline">¶</a></h3>
<p>An opening square bracket introduces a character class, terminated by a
closing square bracket. A closing square bracket on its own is not
special. If a closing square bracket is required as a member of the
class, it should be the first data character in the class (after an
initial circumflex, if present) or escaped with a backslash.</p>
<p>A character class matches a single character in the subject. In UTF-8
mode, the character may occupy more than one byte. A matched character
must be in the set of characters defined by the class, unless the first
character in the class definition is a circumflex, in which case the
subject character must not be in the set defined by the class. If a
circumflex is actually required as a member of the class, ensure it is
not the first character, or escape it with a backslash.</p>
<p>For example, the character class [aeiou] matches any lower case vowel,
while [^aeiou] matches any character that is not a lower case vowel.
Note that a circumflex is just a convenient notation for specifying the
characters which are in the class by enumerating those that are not. It
is not an assertion: it still consumes a character from the subject
string, and fails if the current pointer is at the end of the string.</p>
<p>In UTF-8 mode, characters with values greater than 255 can be included
in a class as a literal string of bytes, or by using the x{ escaping
mechanism.</p>
<p>When caseless matching is set, any letters in a class represent both
their upper case and lower case versions, so for example, a caseless
[aeiou] matches &#8220;A&#8221; as well as &#8220;a&#8221;, and a caseless [^aeiou] does not
match &#8220;A&#8221;, whereas a caseful version would. PCRE does not support the
concept of case for characters with values greater than 255.</p>
<p>The newline character is never treated in any special way in character
classes, whatever the setting of the PCRE_DOTALL or PCRE_MULTILINE
options is. A class such as [^a] will always match a newline.</p>
<p>The minus (hyphen) character can be used to specify a range of
characters in a character class. For example, [d-m] matches any letter
between d and m, inclusive. If a minus character is required in a
class, it must be escaped with a backslash or appear in a position
where it cannot be interpreted as indicating a range, typically as the
first or last character in the class.</p>
<p>It is not possible to have the literal character &#8220;]&#8221; as the end
character of a range. A pattern such as [W-]46] is interpreted as a
class of two characters (&#8220;W&#8221; and &#8220;-&#8221;) followed by a literal string
&#8220;46]&#8221;, so it would match &#8220;W46]&#8221; or &#8220;-46]&#8221;. However, if the &#8220;]&#8221; is
escaped with a backslash it is interpreted as the end of range, so
[W-]46] is interpreted as a single class containing a range followed
by two separate characters. The octal or hexadecimal representation of
&#8220;]&#8221; can also be used to end a range.</p>
<p>Ranges operate in the collating sequence of character values. They can
also be used for characters specified numerically, for example
[000-037]. In UTF-8 mode, ranges can include characters whose values
are greater than 255, for example [x{100}-x{2ff}].</p>
<p>If a range that includes letters is used when caseless matching is set,
it matches the letters in either case. For example, [W-c] is equivalent
to [][^_`wxyzabc], matched caselessly, and if character tables for the
&#8220;fr&#8221; locale are in use, [xc8-xcb] matches accented E characters in
both cases.</p>
<p>The character types d, D, s, S, w, and W may also appear in a
character class, and add the characters that they match to the class.
For example, [dABCDEF] matches any hexadecimal digit. A circumflex can
conveniently be used with the upper case character types to specify a
more restricted set of characters than the matching lower case type.
For example, the class [^W_] matches any letter or digit, but not
underscore.</p>
<p>All non-alphameric characters other than , -, ^ (at the start) and the
terminating ] are non-special in character classes, but it does no harm
if they are escaped.</p>
</div>
<div class="section" id="POSIX CHARACTER CLASSES">
<span id="lpc.POSIX CHARACTER CLASSES"></span><h3>POSIX CHARACTER CLASSES<a class="headerlink" href="#POSIX CHARACTER CLASSES" title="Permalink to this headline">¶</a></h3>
<p>Perl supports the POSIX notation for character classes, which uses
names enclosed by [: and :] within the enclosing square brackets. PCRE
also supports this notation. For example,</p>
<blockquote>
<div>[01[:alpha:]%]</div></blockquote>
<p>matches &#8220;0&#8221;, &#8220;1&#8221;, any alphabetic character, or &#8220;%&#8221;. The supported class
names are</p>
<blockquote>
<div>alnum    letters and digits
alpha    letters
ascii    character codes 0 - 127
blank    space or tab only
cntrl    control characters
digit    decimal digits (same as d)
graph    printing characters, excluding space
lower    lower case letters
print    printing characters, including space
punct    printing characters, excluding letters and digits
space    white space (not quite the same as s)
upper    upper case letters
word     &#8220;word&#8221; characters (same as w)
xdigit   hexadecimal digits</div></blockquote>
<p>The &#8220;space&#8221; characters are HT (9), LF (10), VT (11), FF (12), CR (13),
and space (32). Notice that this list includes the VT character (code
11). This makes &#8220;space&#8221; different to s, which does not include VT (for
Perl compatibility).</p>
<p>The name &#8220;word&#8221; is a Perl extension, and &#8220;blank&#8221; is a GNU extension
from Perl 5.8. Another Perl extension is negation, which is indicated
by a ^ character after the colon. For example,</p>
<blockquote>
<div>[12[:^digit:]]</div></blockquote>
<p>matches &#8220;1&#8221;, &#8220;2&#8221;, or any non-digit. PCRE (and Perl) also recognize the
POSIX syntax [.ch.] and [=ch=] where &#8220;ch&#8221; is a &#8220;collating element&#8221;, but
these are not supported, and an error is given if they are encountered.</p>
<p>In UTF-8 mode, characters with values greater than 255 do not match any
of the POSIX character classes.</p>
</div>
<div class="section" id="VERTICAL BAR">
<span id="lpc.VERTICAL BAR"></span><h3>VERTICAL BAR<a class="headerlink" href="#VERTICAL BAR" title="Permalink to this headline">¶</a></h3>
<p>Vertical bar characters are used to separate alternative patterns. For
example, the pattern</p>
<blockquote>
<div>gilbert|sullivan</div></blockquote>
<p>matches either &#8220;gilbert&#8221; or &#8220;sullivan&#8221;. Any number of alternatives may
appear, and an empty alternative is permitted (matching the empty
string). The matching process tries each alternative in turn, from
left to right, and the first one that succeeds is used. If the
alternatives are within a subpattern (defined below), &#8220;succeeds&#8221; means
matching the rest of the main pattern as well as the alternative in the
subpattern.</p>
</div>
<div class="section" id="INTERNAL OPTION SETTING">
<span id="lpc.INTERNAL OPTION SETTING"></span><h3>INTERNAL OPTION SETTING<a class="headerlink" href="#INTERNAL OPTION SETTING" title="Permalink to this headline">¶</a></h3>
<p>The settings of the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and
PCRE_EXTENDED options can be changed from within the pattern by a
sequence of Perl option letters enclosed between &#8220;(?&#8221; and &#8221;)&#8221;. The
option letters are</p>
<blockquote>
<div>i  for PCRE_CASELESS
m  for PCRE_MULTILINE
s  for PCRE_DOTALL
x  for PCRE_EXTENDED</div></blockquote>
<p>For example, (?im) sets caseless, multiline matching. It is also
possible to unset these options by preceding the letter with a hyphen,
and a combined setting and unsetting such as (?im-sx), which sets
PCRE_CASELESS and PCRE_MULTILINE while unsetting PCRE_DOTALL and
PCRE_EXTENDED, is also permitted. If a letter appears both before and
after the hyphen, the option is unset.</p>
<p>When an option change occurs at top level (that is, not inside
subpattern parentheses), the change applies to the remainder of the
pattern that follows. If the change is placed right at the start of a
pattern, PCRE extracts it into the global options (and it will
therefore show up in data extracted by the pcre_fullinfo() function).</p>
<p>An option change within a subpattern affects only that part of the
current pattern that follows it, so</p>
<blockquote>
<div>(a(?i)b)c</div></blockquote>
<p>matches abc and aBc and no other strings (assuming PCRE_CASELESS is not
used). By this means, options can be made to have different settings
in different parts of the pattern. Any changes made in one alternative
do carry on into subsequent branches within the same subpattern. For
example,</p>
<blockquote>
<div>(a(?i)b|c)</div></blockquote>
<p>matches &#8220;ab&#8221;, &#8220;aB&#8221;, &#8220;c&#8221;, and &#8220;C&#8221;, even though when matching &#8220;C&#8221; the
first branch is abandoned before the option setting. This is because
the effects of option settings happen at compile time. There would be
some very weird behaviour otherwise.</p>
<p>The PCRE-specific options PCRE_UNGREEDY and PCRE_EXTRA can be changed
in the same way as the Perl-compatible options by using the characters
U and X respectively. The (?X) flag setting is special in that it must
always occur earlier in the pattern than any of the additional features
it turns on, even when it is at top level. It is best put at the start.</p>
</div>
<div class="section" id="SUBPATTERNS">
<span id="lpc.SUBPATTERNS"></span><h3>SUBPATTERNS<a class="headerlink" href="#SUBPATTERNS" title="Permalink to this headline">¶</a></h3>
<p>Subpatterns are delimited by parentheses (round brackets), which can be
nested. Marking part of a pattern as a subpattern does two things:</p>
<ol class="arabic simple">
<li>It localizes a set of alternatives. For example, the pattern</li>
</ol>
<blockquote>
<div>cat(aract|erpillar|)</div></blockquote>
<p>matches one of the words &#8220;cat&#8221;, &#8220;cataract&#8221;, or &#8220;caterpillar&#8221;. Without
the parentheses, it would match &#8220;cataract&#8221;, &#8220;erpillar&#8221; or the empty
string.</p>
<p>2. It sets up the subpattern as a capturing subpattern (as defined
above). When the whole pattern matches, that portion of the subject
string that matched the subpattern is passed back to the caller via the
ovector argument of pcre_exec(). Opening parentheses are counted from
left to right (starting from 1) to obtain the numbers of the capturing
subpatterns.</p>
<p>For example, if the string &#8220;the red king&#8221; is matched against the
pattern</p>
<blockquote>
<div>the ((red|white) (king|queen))</div></blockquote>
<p>the captured substrings are &#8220;red king&#8221;, &#8220;red&#8221;, and &#8220;king&#8221;, and are
numbered 1, 2, and 3, respectively.</p>
<p>The fact that plain parentheses fulfil two functions is not always
helpful. There are often times when a grouping subpattern is required
without a capturing requirement. If an opening parenthesis is followed
by a question mark and a colon, the subpattern does not do any
capturing, and is not counted when computing the number of any
subsequent capturing subpatterns. For example, if the string &#8220;the white
queen&#8221; is matched against the pattern</p>
<blockquote>
<div>the ((?:red|white) (king|queen))</div></blockquote>
<p>the captured substrings are &#8220;white queen&#8221; and &#8220;queen&#8221;, and are numbered
1 and 2. The maximum number of capturing subpatterns is 65535, and the
maximum depth of nesting of all subpatterns, both capturing and
noncapturing, is 200.</p>
<p>As a convenient shorthand, if any option settings are required at the
start of a non-capturing subpattern, the option letters may appear
between the &#8221;?&#8221; and the &#8221;:&#8221;. Thus the two patterns</p>
<blockquote>
<div>(?i:saturday|sunday)
(?:(?i)saturday|sunday)</div></blockquote>
<p>match exactly the same set of strings. Because alternative branches are
tried from left to right, and options are not reset until the end of
the subpattern is reached, an option setting in one branch does affect
subsequent branches, so the above patterns match &#8220;SUNDAY&#8221; as well as
&#8220;Saturday&#8221;.</p>
</div>
<div class="section" id="NAMED SUBPATTERNS">
<span id="lpc.NAMED SUBPATTERNS"></span><h3>NAMED SUBPATTERNS<a class="headerlink" href="#NAMED SUBPATTERNS" title="Permalink to this headline">¶</a></h3>
<p>Identifying capturing parentheses by number is simple, but it can be
very hard to keep track of the numbers in complicated regular
expressions. Furthermore, if an expression is modified, the numbers may
change. To help with the difficulty, PCRE supports the naming of
subpatterns, something that Perl does not provide. The Python syntax
(?P&lt;name&gt;...) is used. Names consist of alphanumeric characters and
underscores, and must be unique within a pattern.</p>
<p>Named capturing parentheses are still allocated numbers as well as
names. The PCRE API provides function calls for extracting the name-to-
number translation table from a compiled pattern. For further details
see the pcreapi documentation.</p>
</div>
<div class="section" id="REPETITION">
<span id="lpc.REPETITION"></span><h3>REPETITION<a class="headerlink" href="#REPETITION" title="Permalink to this headline">¶</a></h3>
<p>Repetition is specified by quantifiers, which can follow any of the
following items:</p>
<blockquote>
<div>a literal data character
the . metacharacter
the C escape sequence
escapes such as d that match single characters
a character class
a back reference (see next section)
a parenthesized subpattern (unless it is an assertion)</div></blockquote>
<p>The general repetition quantifier specifies a minimum and maximum
number of permitted matches, by giving the two numbers in curly
brackets (braces), separated by a comma. The numbers must be less than
65536, and the first must be less than or equal to the second. For
example:</p>
<blockquote>
<div>z{2,4}</div></blockquote>
<p>matches &#8220;zz&#8221;, &#8220;zzz&#8221;, or &#8220;zzzz&#8221;. A closing brace on its own is not a
special character. If the second number is omitted, but the comma is
present, there is no upper limit; if the second number and the comma
are both omitted, the quantifier specifies an exact number of required
matches. Thus</p>
<blockquote>
<div>[aeiou]{3,}</div></blockquote>
<p>matches at least 3 successive vowels, but may match many more, while</p>
<blockquote>
<div>d{8}</div></blockquote>
<p>matches exactly 8 digits. An opening curly bracket that appears in a
position where a quantifier is not allowed, or one that does not match
the syntax of a quantifier, is taken as a literal character. For
example, {,6} is not a quantifier, but a literal string of four
characters.</p>
<p>In UTF-8 mode, quantifiers apply to UTF-8 characters rather than to
individual bytes. Thus, for example, x{100}{2} matches two UTF-8
characters, each of which is represented by a two-byte sequence.</p>
<p>The quantifier {0} is permitted, causing the expression to behave as if
the previous item and the quantifier were not present.</p>
<p>For convenience (and historical compatibility) the three most common
quantifiers have single-character abbreviations:</p>
<blockquote>
<div><ul class="simple">
<li>is equivalent to {0,}</li>
</ul>
<ul class="simple">
<li>is equivalent to {1,}</li>
</ul>
<p>?    is equivalent to {0,1}</p>
</div></blockquote>
<p>It is possible to construct infinite loops by following a subpattern
that can match no characters with a quantifier that has no upper limit,
for example:</p>
<blockquote>
<div>(a?)*</div></blockquote>
<p>Earlier versions of Perl and PCRE used to give an error at compile time
for such patterns. However, because there are cases where this can be
useful, such patterns are now accepted, but if any repetition of the
subpattern does in fact match no characters, the loop is forcibly
broken.</p>
<p>By default, the quantifiers are &#8220;greedy&#8221;, that is, they match as much
as possible (up to the maximum number of permitted times), without
causing the rest of the pattern to fail. The classic example of where
this gives problems is in trying to match comments in C programs. These
appear between the sequences /* and <a href="#id1"><span class="problematic" id="id2">*</span></a>/ and within the sequence,
individual * and / characters may appear. An attempt to match C
comments by applying the pattern</p>
<blockquote>
<div>/*.**/</div></blockquote>
<p>to the string</p>
<blockquote>
<div>/* first command <em>/ not comment /</em> second comment <a href="#id3"><span class="problematic" id="id4">*</span></a>/</div></blockquote>
<p>fails, because it matches the entire string owing to the greediness of
the .* item.</p>
<p>However, if a quantifier is followed by a question mark, it ceases to
be greedy, and instead matches the minimum number of times possible, so
the pattern</p>
<blockquote>
<div>/*.*?*/</div></blockquote>
<p>does the right thing with the C comments. The meaning of the various
quantifiers is not otherwise changed, just the preferred number of
matches. Do not confuse this use of question mark with its use as a
quantifier in its own right. Because it has two uses, it can sometimes
appear doubled, as in</p>
<blockquote>
<div>d??d</div></blockquote>
<p>which matches one digit by preference, but can match two if that is the
only way the rest of the pattern matches.</p>
<p>If the PCRE_UNGREEDY option is set (an option which is not available in
Perl), the quantifiers are not greedy by default, but individual ones
can be made greedy by following them with a question mark. In other
words, it inverts the default behaviour.</p>
<p>When a parenthesized subpattern is quantified with a minimum repeat
count that is greater than 1 or with a limited maximum, more store is
required for the compiled pattern, in proportion to the size of the
minimum or maximum.</p>
<p>If a pattern starts with .* or .{0,} and the PCRE_DOTALL option
(equivalent to Perl&#8217;s /s) is set, thus allowing the . to match
newlines, the pattern is implicitly anchored, because whatever follows
will be tried against every character position in the subject string,
so there is no point in retrying the overall match at any position
after the first. PCRE normally treats such a pattern as though it were
preceded by A.</p>
<p>In cases where it is known that the subject string contains no
newlines, it is worth setting PCRE_DOTALL in order to obtain this
optimization, or alternatively using ^ to indicate anchoring
explicitly.</p>
<p>However, there is one situation where the optimization cannot be used.
When .* is inside capturing parentheses that are the subject of a
backreference elsewhere in the pattern, a match at the start may fail,
and a later one succeed. Consider, for example:</p>
<blockquote>
<div>(.*)abc1</div></blockquote>
<p>If the subject is &#8220;xyz123abc123&#8221; the match point is the fourth
character. For this reason, such a pattern is not implicitly anchored.</p>
<p>When a capturing subpattern is repeated, the value captured is the
substring that matched the final iteration. For example, after</p>
<blockquote>
<div>(tweedle[dume]{3}s*)+</div></blockquote>
<p>has matched &#8220;tweedledum tweedledee&#8221; the value of the captured substring
is &#8220;tweedledee&#8221;. However, if there are nested capturing subpatterns,
the corresponding captured values may have been set in previous
iterations. For example, after</p>
<blockquote>
<div>/(a|(b))+/</div></blockquote>
<p>matches &#8220;aba&#8221; the value of the second captured substring is &#8220;b&#8221;.</p>
<p>ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS
With both maximizing and minimizing repetition, failure of what follows
normally causes the repeated item to be re-evaluated to see if a
different number of repeats allows the rest of the pattern to match.
Sometimes it is useful to prevent this, either to change the nature of
the match, or to cause it fail earlier than it otherwise might, when
the author of the pattern knows there is no point in carrying on.</p>
<p>Consider, for example, the pattern d+foo when applied to the subject
line</p>
<blockquote>
<div>123456bar</div></blockquote>
<p>After matching all 6 digits and then failing to match &#8220;foo&#8221;, the normal
action of the matcher is to try again with only 5 digits matching the
d+ item, and then with 4, and so on, before ultimately failing.
&#8220;Atomic grouping&#8221; (a term taken from Jeffrey Friedl&#8217;s book) provides
the means for specifying that once a subpattern has matched, it is not
to be re-evaluated in this way.</p>
<p>If we use atomic grouping for the previous example, the matcher would
give up immediately on failing to match &#8220;foo&#8221; the first time. The
notation is a kind of special parenthesis, starting with (?&gt; as in this
example:</p>
<blockquote>
<div>(?&gt;d+)foo</div></blockquote>
<p>This kind of parenthesis &#8220;locks up&#8221; the part of the pattern it
contains once it has matched, and a failure further into the pattern is
prevented from backtracking into it. Backtracking past it to previous
items, however, works as normal.</p>
<p>An alternative description is that a subpattern of this type matches
the string of characters that an identical standalone pattern would
match, if anchored at the current point in the subject string.</p>
<p>Atomic grouping subpatterns are not capturing subpatterns. Simple cases
such as the above example can be thought of as a maximizing repeat that
must swallow everything it can. So, while both d+ and d+? are
prepared to adjust the number of digits they match in order to make the
rest of the pattern match, (?&gt;d+) can only match an entire sequence of
digits.</p>
<p>Atomic groups in general can of course contain arbitrarily complicated
subpatterns, and can be nested. However, when the subpattern for an
atomic group is just a single repeated item, as in the example above, a
simpler notation, called a &#8220;possessive quantifier&#8221; can be used. This
consists of an additional + character following a quantifier. Using
this notation, the previous example can be rewritten as</p>
<blockquote>
<div>d++bar</div></blockquote>
<p>Possessive quantifiers are always greedy; the setting of the
PCRE_UNGREEDY option is ignored. They are a convenient notation for the
simpler forms of atomic group. However, there is no difference in the
meaning or processing of a possessive quantifier and the equivalent
atomic group.</p>
<p>The possessive quantifier syntax is an extension to the Perl syntax. It
originates in Sun&#8217;s Java package.</p>
<p>When a pattern contains an unlimited repeat inside a subpattern that
can itself be repeated an unlimited number of times, the use of an
atomic group is the only way to avoid some failing matches taking a
very long time indeed. The pattern</p>
<blockquote>
<div>(D+|&lt;d+&gt;)*[!?]</div></blockquote>
<p>matches an unlimited number of substrings that either consist of non-
digits, or digits enclosed in &lt;&gt;, followed by either ! or ?. When it
matches, it runs quickly. However, if it is applied to</p>
<blockquote>
<div>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div></blockquote>
<p>it takes a long time before reporting failure. This is because the
string can be divided between the two repeats in a large number of
ways, and all have to be tried. (The example used [!?] rather than a
single character at the end, because both PCRE and Perl have an
optimization that allows for fast failure when a single character is
used. They remember the last single character that is required for a
match, and fail early if it is not present in the string.) If the
pattern is changed to</p>
<blockquote>
<div>((?&gt;D+)|&lt;d+&gt;)*[!?]</div></blockquote>
<p>sequences of non-digits cannot be broken, and failure happens quickly.</p>
<p>BACK REFERENCES
Outside a character class, a backslash followed by a digit greater than
0 (and possibly further digits) is a back reference to a capturing
subpattern earlier (that is, to its left) in the pattern, provided
there have been that many previous capturing left parentheses.</p>
<p>However, if the decimal number following the backslash is less than 10,
it is always taken as a back reference, and causes an error only if
there are not that many capturing left parentheses in the entire
pattern. In other words, the parentheses that are referenced need not
be to the left of the reference for numbers less than 10. See the
section entitled &#8220;Backslash&#8221; above for further details of the handling
of digits following a backslash.</p>
<p>A back reference matches whatever actually matched the capturing
subpattern in the current subject string, rather than anything matching
the subpattern itself (see &#8220;Subpatterns as subroutines&#8221; below for a way
of doing that). So the pattern</p>
<blockquote>
<div>(sens|respons)e and 1ibility</div></blockquote>
<p>matches &#8220;sense and sensibility&#8221; and &#8220;response and responsibility&#8221;, but
not &#8220;sense and responsibility&#8221;. If caseful matching is in force at the
time of the back reference, the case of letters is relevant. For
example,</p>
<blockquote>
<div>((?i)rah)s+1</div></blockquote>
<p>matches &#8220;rah rah&#8221; and &#8220;RAH RAH&#8221;, but not &#8220;RAH rah&#8221;, even though the
original capturing subpattern is matched caselessly.</p>
<p>Back references to named subpatterns use the Python syntax (?P=name).
We could rewrite the above example as follows:</p>
<blockquote>
<div>(?&lt;p1&gt;(?i)rah)s+(?P=p1)</div></blockquote>
<p>There may be more than one back reference to the same subpattern. If a
subpattern has not actually been used in a particular match, any back
references to it always fail. For example, the pattern</p>
<blockquote>
<div>(a|(bc))2</div></blockquote>
<p>always fails if it starts to match &#8220;a&#8221; rather than &#8220;bc&#8221;. Because there
may be many capturing parentheses in a pattern, all digits following
the backslash are taken as part of a potential back reference number.
If the pattern continues with a digit character, some delimiter must be
used to terminate the back reference. If the PCRE_EXTENDED option is
set, this can be whitespace. Otherwise an empty comment can be used.</p>
<p>A back reference that occurs inside the parentheses to which it refers
fails when the subpattern is first used, so, for example, (a1) never
matches. However, such references can be useful inside repeated
subpatterns. For example, the pattern</p>
<blockquote>
<div>(a|b1)+</div></blockquote>
<p>matches any number of &#8220;a&#8221;s and also &#8220;aba&#8221;, &#8220;ababbaa&#8221; etc. At each
iteration of the subpattern, the back reference matches the character
string corresponding to the previous iteration. In order for this to
work, the pattern must be such that the first iteration does not need
to match the back reference. This can be done using alternation, as in
the example above, or by a quantifier with a minimum of zero.</p>
</div>
<div class="section" id="ASSERTIONS">
<span id="lpc.ASSERTIONS"></span><h3>ASSERTIONS<a class="headerlink" href="#ASSERTIONS" title="Permalink to this headline">¶</a></h3>
<p>An assertion is a test on the characters following or preceding the
current matching point that does not actually consume any characters.
The simple assertions coded as b, B, A, G, Z, z, ^ and $ are
described above. More complicated assertions are coded as subpatterns.
There are two kinds: those that look ahead of the current position in
the subject string, and those that look behind it.</p>
<p>An assertion subpattern is matched in the normal way, except that it
does not cause the current matching position to be changed. Lookahead
assertions start with (?= for positive assertions and (?! for negative
assertions. For example,</p>
<blockquote>
<div>w+(?=;)</div></blockquote>
<p>matches a word followed by a semicolon, but does not include the
semicolon in the match, and</p>
<blockquote>
<div>foo(?!bar)</div></blockquote>
<p>matches any occurrence of &#8220;foo&#8221; that is not followed by &#8220;bar&#8221;. Note
that the apparently similar pattern</p>
<blockquote>
<div>(?!foo)bar</div></blockquote>
<p>does not find an occurrence of &#8220;bar&#8221; that is preceded by something
other than &#8220;foo&#8221;; it finds any occurrence of &#8220;bar&#8221; whatsoever, because
the assertion (?!foo) is always true when the next three characters are
&#8220;bar&#8221;. A lookbehind assertion is needed to achieve this effect.</p>
<p>If you want to force a matching failure at some point in a pattern, the
most convenient way to do it is with (?!) because an empty string
always matches, so an assertion that requires there not to be an empty
string must always fail.</p>
<p>Lookbehind assertions start with (?&lt;= for positive assertions and (?&lt;!
for negative assertions. For example,</p>
<blockquote>
<div>(?&lt;!foo)bar</div></blockquote>
<p>does find an occurrence of &#8220;bar&#8221; that is not preceded by &#8220;foo&#8221;. The
contents of a lookbehind assertion are restricted such that all the
strings it matches must have a fixed length. However, if there are
several alternatives, they do not all have to have the same fixed
length. Thus</p>
<blockquote>
<div>(?&lt;=bullock|donkey)</div></blockquote>
<p>is permitted, but</p>
<blockquote>
<div>(?&lt;!dogs?|cats?)</div></blockquote>
<p>causes an error at compile time. Branches that match different length
strings are permitted only at the top level of a lookbehind assertion.
This is an extension compared with Perl (at least for 5.8), which
requires all branches to match the same length of string. An assertion
such as</p>
<blockquote>
<div>(?&lt;=ab(c|de))</div></blockquote>
<p>is not permitted, because its single top-level branch can match two
different lengths, but it is acceptable if rewritten to use two top-
level branches:</p>
<blockquote>
<div>(?&lt;=abc|abde)</div></blockquote>
<p>The implementation of lookbehind assertions is, for each alternative,
to temporarily move the current position back by the fixed width and
then try to match. If there are insufficient characters before the
current position, the match is deemed to fail.</p>
<p>PCRE does not allow the C escape (which matches a single byte in UTF-8
mode) to appear in lookbehind assertions, because it makes it
impossible to calculate the length of the lookbehind.</p>
<p>Atomic groups can be used in conjunction with lookbehind assertions to
specify efficient matching at the end of the subject string. Consider a
simple pattern such as</p>
<blockquote>
<div>abcd$</div></blockquote>
<p>when applied to a long string that does not match. Because matching
proceeds from left to right, PCRE will look for each &#8220;a&#8221; in the subject
and then see if what follows matches the rest of the pattern. If the
pattern is specified as</p>
<blockquote>
<div>^.*abcd$</div></blockquote>
<p>the initial .* matches the entire string at first, but when this fails
(because there is no following &#8220;a&#8221;), it backtracks to match all but the
last character, then all but the last two characters, and so on. Once
again the search for &#8220;a&#8221; covers the entire string, from right to left,
so we are no better off. However, if the pattern is written as</p>
<blockquote>
<div>^(?&gt;.*)(?&lt;=abcd)</div></blockquote>
<p>or, equivalently,</p>
<blockquote>
<div>^.*+(?&lt;=abcd)</div></blockquote>
<p>there can be no backtracking for the .* item; it can match only the
entire string. The subsequent lookbehind assertion does a single test
on the last four characters. If it fails, the match fails immediately.
For long strings, this approach makes a significant difference to the
processing time.</p>
<p>Several assertions (of any sort) may occur in succession. For example,</p>
<blockquote>
<div>(?&lt;=d{3})(?&lt;!999)foo</div></blockquote>
<p>matches &#8220;foo&#8221; preceded by three digits that are not &#8220;999&#8221;. Notice that
each of the assertions is applied independently at the same point in
the subject string. First there is a check that the previous three
characters are all digits, and then there is a check that the same
three characters are not &#8220;999&#8221;. This pattern does not match &#8220;foo&#8221;
preceded by six characters, the first of which are digits and the last
three of which are not &#8220;999&#8221;. For example, it doesn&#8217;t match
&#8220;123abcfoo&#8221;. A pattern to do that is</p>
<blockquote>
<div>(?&lt;=d{3}...)(?&lt;!999)foo</div></blockquote>
<p>This time the first assertion looks at the preceding six characters,
checking that the first three are digits, and then the second assertion
checks that the preceding three characters are not &#8220;999&#8221;.</p>
<p>Assertions can be nested in any combination. For example,</p>
<blockquote>
<div>(?&lt;=(?&lt;!foo)bar)baz</div></blockquote>
<p>matches an occurrence of &#8220;baz&#8221; that is preceded by &#8220;bar&#8221; which in turn
is not preceded by &#8220;foo&#8221;, while</p>
<blockquote>
<div>(?&lt;=d{3}(?!999)...)foo</div></blockquote>
<p>is another pattern which matches &#8220;foo&#8221; preceded by three digits and any
three characters that are not &#8220;999&#8221;.</p>
<p>Assertion subpatterns are not capturing subpatterns, and may not be
repeated, because it makes no sense to assert the same thing several
times. If any kind of assertion contains capturing subpatterns within
it, these are counted for the purposes of numbering the capturing
subpatterns in the whole pattern. However, substring capturing is
carried out only for positive assertions, because it does not make
sense for negative assertions.</p>
</div>
<div class="section" id="CONDITIONAL SUBPATTERNS">
<span id="lpc.CONDITIONAL SUBPATTERNS"></span><h3>CONDITIONAL SUBPATTERNS<a class="headerlink" href="#CONDITIONAL SUBPATTERNS" title="Permalink to this headline">¶</a></h3>
<p>It is possible to cause the matching process to obey a subpattern
conditionally or to choose between two alternative subpatterns,
depending on the result of an assertion, or whether a previous
capturing subpattern matched or not. The two possible forms of
conditional subpattern are</p>
<blockquote>
<div>(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)</div></blockquote>
<p>If the condition is satisfied, the yes-pattern is used; otherwise the
no-pattern (if present) is used. If there are more than two
alternatives in the subpattern, a compile-time error occurs.</p>
<p>There are three kinds of condition. If the text between the parentheses
consists of a sequence of digits, the condition is satisfied if the
capturing subpattern of that number has previously matched. The number
must be greater than zero. Consider the following pattern, which
contains non-significant white space to make it more readable (assume
the PCRE_EXTENDED option) and to divide it into three parts for ease of
discussion:</p>
<blockquote>
<div>( ( )?    [^()]+   (?(1) ) )</div></blockquote>
<p>The first part matches an optional opening parenthesis, and if that
character is present, sets it as the first captured substring. The
second part matches one or more characters that are not parentheses.
The third part is a conditional subpattern that tests whether the first
set of parentheses matched or not. If they did, that is, if subject
started with an opening parenthesis, the condition is true, and so the
yes-pattern is executed and a closing parenthesis is required.
Otherwise, since no-pattern is not present, the subpattern matches
nothing. In other words, this pattern matches a sequence of
non-parentheses, optionally enclosed in parentheses.</p>
<p>If the condition is the string (R), it is satisfied if a recursive call
to the pattern or subpattern has been made. At &#8220;top level&#8221;, the
condition is false. This is a PCRE extension. Recursive patterns are
described in the next section.</p>
<p>If the condition is not a sequence of digits or (R), it must be an
assertion. This may be a positive or negative lookahead or lookbehind
assertion. Consider this pattern, again containing non-significant
white space, and with the two alternatives on the second line:</p>
<blockquote>
<div>(?(?=[^a-z]*[a-z])
d{2}-[a-z]{3}-d{2}  |  d{2}-d{2}-d{2} )</div></blockquote>
<p>The condition is a positive lookahead assertion that matches an
optional sequence of non-letters followed by a letter. In other words,
it tests for the presence of at least one letter in the subject. If a
letter is found, the subject is matched against the first alternative;
otherwise it is matched against the second. This pattern matches
strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are
letters and dd are digits.</p>
</div>
<div class="section" id="COMMENTS">
<span id="lpc.COMMENTS"></span><h3>COMMENTS<a class="headerlink" href="#COMMENTS" title="Permalink to this headline">¶</a></h3>
<p>The sequence (?# marks the start of a comment which continues up to the
next closing parenthesis. Nested parentheses are not permitted. The
characters that make up a comment play no part in the pattern matching
at all.</p>
<p>If the PCRE_EXTENDED option is set, an unescaped # character outside a
character class introduces a comment that continues up to the next
newline character in the pattern.</p>
</div>
<div class="section" id="RECURSIVE PATTERNS">
<span id="lpc.RECURSIVE PATTERNS"></span><h3>RECURSIVE PATTERNS<a class="headerlink" href="#RECURSIVE PATTERNS" title="Permalink to this headline">¶</a></h3>
<p>Consider the problem of matching a string in parentheses, allowing for
unlimited nested parentheses. Without the use of recursion, the best
that can be done is to use a pattern that matches up to some fixed
depth of nesting. It is not possible to handle an arbitrary nesting
depth. Perl has provided an experimental facility that allows regular
expressions to recurse (amongst other things). It does this by
interpolating Perl code in the expression at run time, and the code can
refer to the expression itself. A Perl pattern to solve the parentheses
problem can be created like this:</p>
<blockquote>
<div>$re = qr{( (?: (?&gt;[^()]+) | (?p{$re}) )* )}x;</div></blockquote>
<p>The (?p{...}) item interpolates Perl code at run time, and in this case
refers recursively to the pattern in which it appears. Obviously, PCRE
cannot support the interpolation of Perl code. Instead, it supports
some special syntax for recursion of the entire pattern, and also for
individual subpattern recursion.</p>
<p>The special item that consists of (? followed by a number greater than
zero and a closing parenthesis is a recursive call of the subpattern of
the given number, provided that it occurs inside that subpattern. (If
not, it is a &#8220;subroutine&#8221; call, which is described in the next
section.) The special item (?R) is a recursive call of the entire
regular expression.</p>
<p>For example, this PCRE pattern solves the nested parentheses problem
(assume the PCRE_EXTENDED option is set so that white space is
ignored):</p>
<blockquote>
<div>( ( (?&gt;[^()]+) | (?R) )* )</div></blockquote>
<p>First it matches an opening parenthesis. Then it matches any number of
substrings which can either be a sequence of non-parentheses, or a
recursive match of the pattern itself (that is a correctly
parenthesized substring). Finally there is a closing parenthesis.</p>
<p>If this were part of a larger pattern, you would not want to recurse
the entire pattern, so instead you could use this:</p>
<blockquote>
<div>( ( ( (?&gt;[^()]+) | (?1) )* ) )</div></blockquote>
<p>We have put the pattern into parentheses, and caused the recursion to
refer to them instead of the whole pattern. In a larger pattern,
keeping track of parenthesis numbers can be tricky. It may be more
convenient to use named parentheses instead. For this, PCRE uses
(?P&gt;name), which is an extension to the Python syntax that PCRE uses
for named parentheses (Perl does not provide named parentheses). We
could rewrite the above example as follows:</p>
<blockquote>
<div>(?P&lt;pn&gt; ( ( (?&gt;[^()]+) | (?P&gt;pn) )* ) )</div></blockquote>
<p>This particular example pattern contains nested unlimited repeats, and
so the use of atomic grouping for matching strings of non-parentheses
is important when applying the pattern to strings that do not match.
For example, when this pattern is applied to</p>
<blockquote>
<div>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</div></blockquote>
<p>it yields &#8220;no match&#8221; quickly. However, if atomic grouping is not used,
the match runs for a very long time indeed because there are so many
different ways the + and * repeats can carve up the subject, and all
have to be tested before failure can be reported.</p>
<p>At the end of a match, the values set for any capturing subpatterns are
those from the outermost level of the recursion at which the subpattern
value is set. If you want to obtain intermediate values, a callout
function can be used (see below and the pcrecallout documentation). If
the pattern above is matched against</p>
<blockquote>
<div>(ab(cd)ef)</div></blockquote>
<p>the value for the capturing parentheses is &#8220;ef&#8221;, which is the last
value taken on at the top level. If additional parentheses are added,
giving</p>
<blockquote>
<div><dl class="docutils">
<dt>( ( ( (?&gt;[^()]+) | (?R) )* ) )</dt>
<dd>^                        ^
^                        ^</dd>
</dl>
</div></blockquote>
<p>the string they capture is &#8220;ab(cd)ef&#8221;, the contents of the top level
parentheses. If there are more than 15 capturing parentheses in a
pattern, PCRE has to obtain extra memory to store data during a
recursion, which it does by using pcre_malloc, freeing it via pcre_free
afterwards. If no memory can be obtained, the match fails with the
PCRE_ERROR_NOMEMORY error.</p>
<p>Do not confuse the (?R) item with the condition (R), which tests for
recursion. Consider this pattern, which matches text in angle
brackets, allowing for arbitrary nesting. Only digits are allowed in
nested brackets (that is, when recursing), whereas any characters are
permitted at the outer level.</p>
<blockquote>
<div>&lt; (?: (?(R) d++  | [^&lt;&gt;]*+) | (?R)) * &gt;</div></blockquote>
<p>In this pattern, (?(R) is the start of a conditional subpattern, with
two different alternatives for the recursive and non-recursive cases.
The (?R) item is the actual recursive call.</p>
</div>
<div class="section" id="SUBPATTERNS AS SUBROUTINES">
<span id="lpc.SUBPATTERNS AS SUBROUTINES"></span><h3>SUBPATTERNS AS SUBROUTINES<a class="headerlink" href="#SUBPATTERNS AS SUBROUTINES" title="Permalink to this headline">¶</a></h3>
<p>If the syntax for a recursive subpattern reference (either by number or
by name) is used outside the parentheses to which it refers, it
operates like a subroutine in a programming language. An earlier
example pointed out that the pattern</p>
<blockquote>
<div>(sens|respons)e and 1ibility</div></blockquote>
<p>matches &#8220;sense and sensibility&#8221; and &#8220;response and responsibility&#8221;, but
not &#8220;sense and responsibility&#8221;. If instead the pattern</p>
<blockquote>
<div>(sens|respons)e and (?1)ibility</div></blockquote>
<p>is used, it does match &#8220;sense and responsibility&#8221; as well as the other
two strings. Such references must, however, follow the subpattern to
which they refer.</p>
</div>
<div class="section" id="CALLOUTS">
<span id="lpc.CALLOUTS"></span><h3>CALLOUTS<a class="headerlink" href="#CALLOUTS" title="Permalink to this headline">¶</a></h3>
<p>Perl has a feature whereby using the sequence (?{...}) causes arbitrary
Perl code to be obeyed in the middle of matching a regular expression.
This makes it possible, amongst other things, to extract different
substrings that match the same pair of parentheses when there is a
repetition.</p>
<p>PCRE provides a similar feature, but of course it cannot obey arbitrary
Perl code. The feature is called &#8220;callout&#8221;. The caller of PCRE provides
an external function by putting its entry point in the global variable
pcre_callout. By default, this variable contains NULL, which disables
all calling out.</p>
<p>Within a regular expression, (?C) indicates the points at which the
external function is to be called. If you want to identify different
callout points, you can put a number less than 256 after the letter C.
The default value is zero. For example, this pattern has two callout
points:</p>
<blockquote>
<div>(?C1)abc(?C2)def</div></blockquote>
<p>During matching, when PCRE reaches a callout point (and pcre_callout is
set), the external function is called. It is provided with the number
of the callout, and, optionally, one item of data originally supplied
by the caller of pcre_exec(). The callout function may cause matching
to backtrack, or to fail altogether. A complete description of the
interface to the callout function is given in the pcrecallout
documentation.</p>
</div>
<div class="section" id="DIFFERENCES FROM PERL">
<span id="lpc.DIFFERENCES FROM PERL"></span><h3>DIFFERENCES FROM PERL<a class="headerlink" href="#DIFFERENCES FROM PERL" title="Permalink to this headline">¶</a></h3>
<p>This section escribes the differences in the ways that PCRE and Perl
handle regular expressions. The differences described here are with
respect to Perl 5.8.</p>
<p>1.  PCRE does not have full UTF-8 support. Details of what it does have
are given in the section on UTF-8 support in the main pcre page.</p>
<p>2.  PCRE does not allow repeat quantifiers on lookahead assertions.
Perl permits them, but they do not mean what you might think. For
example, (?!a){3} does not assert that the next three characters are
not &#8220;a&#8221;. It just asserts that the next character is not &#8220;a&#8221; three
times.</p>
<p>3.  Capturing subpatterns that occur inside negative lookahead
assertions are counted, but their entries in the offsets vector are
never set. Perl sets its numerical variables from any such patterns
that are matched before the assertion fails to match something
(thereby succeeding), but only if the negative lookahead assertion
contains just one branch.</p>
<p>4.  Though binary zero characters are supported in the subject string,
they are not allowed in a pattern string because it is passed as a
normal C string, terminated by zero. The escape sequence &#8220;0&#8221; can be
used in the pattern to represent a binary zero.</p>
<p>5.  The following Perl escape sequences are not supported: l, u, L,
U, P, p, N, and X. In fact these are implemented by Perl&#8217;s general
string-handling and are not part of its pattern matching engine. If any
of these are encountered by PCRE, an error is generated.</p>
<p>6.  PCRE does support the Q...E escape for quoting substrings.
Characters in between are treated as literals. This is slightly
different from Perl in that $ and &#64; are also handled as literals inside
the quotes. In Perl, they cause variable interpolation (but of course
PCRE does not have variables). Note the following examples:</p>
<blockquote>
<div><p>Pattern            PCRE matches      Perl matches</p>
<dl class="docutils">
<dt>Qabc$xyzE        abc$xyz           abc followed by the</dt>
<dd>contents of $xyz</dd>
</dl>
<p>Qabc$xyzE       abc$xyz          abc$xyz
QabcE$QxyzE   abc$xyz           abc$xyz</p>
</div></blockquote>
<p>The Q...E sequence is recognized both inside and outside character
classes.</p>
<p>7.  Fairly obviously, PCRE does not support the (?{code}) and
(?p{code}) constructions. However, there is some experimental support
for recursive patterns using the non-Perl items (?R), (?number) and
(?P&gt;name). Also, the PCRE &#8220;callout&#8221; feature allows an external function
to be called during pattern matching.</p>
<p>8.  There are some differences that are concerned with the settings of
captured strings when part of a pattern is repeated. For example,
matching &#8220;aba&#8221; against the pattern /^(a(b)?)+$/ in Perl leaves $2
unset, but in PCRE it is set to &#8220;b&#8221;.</p>
<p>9.  PCRE provides some extensions to the Perl regular expression
facilities:</p>
<p>(a)  Although lookbehind assertions must match fixed length strings,
each alternative branch of a lookbehind assertion can match a different
length of string. Perl requires them all to have the same length.</p>
<p>(b)  If PCRE_DOLLAR_ENDONLY is set and PCRE_MULTILINE is not set, the $
meta-character matches only at the very end of the string.</p>
<p>(c) If PCRE_EXTRA is set, a backslash followed by a letter with no
special meaning is faulted.</p>
<p>(d)  If PCRE_UNGREEDY is set, the greediness of the repetition
quantifiers is inverted, that is, by default they are not greedy, but
if followed by a question mark they are.</p>
<p>(e)  PCRE_ANCHORED can be used to force a pattern to be tried only at
the first matching position in the subject string.</p>
<p>(f) The PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, and
PCRE_NO_AUTO_CAPTURE options for pcre_exec() have no Perl equivalents.</p>
<p>(g)  The (?R), (?number), and (?P&gt;name) constructs allows for recursive
pattern matching (Perl can do this using the (?p{code}) construct,
which PCRE cannot support.)</p>
<ol class="loweralpha simple" start="8">
<li>PCRE supports named capturing substrings, using the Python syntax.</li>
</ol>
<p>(i)  PCRE supports the possessive quantifier &#8220;++&#8221; syntax, taken from
Sun&#8217;s Java package.</p>
<ol class="loweralpha simple" start="10">
<li>The (R) condition, for testing recursion, is a PCRE extension.</li>
<li>The callout facility is PCRE-specific.</li>
</ol>
</div>
<div class="section" id="NOTES">
<span id="lpc.NOTES"></span><h3>NOTES<a class="headerlink" href="#NOTES" title="Permalink to this headline">¶</a></h3>
<p>The &lt; and &gt; metacharacters from Henry Spencers package
are not available in PCRE, but can be emulated with b,
as required, also in conjunction with W or w.</p>
<p>In LDMud, backtracks are limited by the EVAL_COST runtime
limit, to avoid freezing the driver with a match
like regexp(({&#8220;=XX===================&#8221;}), &#8220;X(.+)+X&#8221;).</p>
<p>LDMud doesn&#8217;t support PCRE callouts.</p>
</div>
<div class="section" id="LIMITATIONS">
<span id="lpc.LIMITATIONS"></span><h3>LIMITATIONS<a class="headerlink" href="#LIMITATIONS" title="Permalink to this headline">¶</a></h3>
<p>There are some size limitations in PCRE but it is hoped that
they will never in practice be relevant. The maximum length
of a compiled pattern is 65539 (sic) bytes. All values in
repeating quantifiers must be less than 65536. There
maximum number of capturing subpatterns is 65535. There is no
limit to the number of non-capturing subpatterns, but the
maximum depth of nesting of all kinds of parenthesized
subpattern, including capturing subpatterns, assertions,
and other types of subpattern, is 200.</p>
<p>The maximum length of a subject string is the largest
positive number that an integer variable can hold. However,
PCRE uses recursion to handle subpatterns and indefinite
repetition. This means that the available stack space may
limit the size of a subject string that can be processed by
certain patterns.</p>
</div>
<div class="section" id="AUTHOR">
<span id="lpc.AUTHOR"></span><h3>AUTHOR<a class="headerlink" href="#AUTHOR" title="Permalink to this headline">¶</a></h3>
<p>Philip Hazel &lt;<a class="reference external" href="mailto:ph10&#37;&#52;&#48;cam&#46;ac&#46;uk">ph10<span>&#64;</span>cam<span>&#46;</span>ac<span>&#46;</span>uk</a>&gt;
University Computing Service,
New Museums Site,
Cambridge CB2 3QG, England.
Phone: +44 1223 334714</p>
</div>
<h2 id="see2also">SEE ALSO<a class="headerlink" href="#DESCRIPTION" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="regexp.html#lpc.regexp" title="regexp"><span class="xref lpc lpc-concept">regexp</span></a>, <a class="reference internal" href="hsregexp.html#lpc.hsregexp" title="hsregexp"><span class="xref lpc lpc-concept">hsregexp</span></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pcre</a><ul>
<li><a class="reference internal" href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a class="reference internal" href="#DESCRIPTION">DESCRIPTION</a><ul>
<li><a class="reference internal" href="#PCRE REGULAR EXPRESSION DETAILS">PCRE REGULAR EXPRESSION DETAILS</a></li>
<li><a class="reference internal" href="#BACKSLASH">BACKSLASH</a></li>
<li><a class="reference internal" href="#CIRCUMFLEX AND DOLLAR">CIRCUMFLEX AND DOLLAR</a></li>
<li><a class="reference internal" href="#FULL STOP (PERIOD, DOT)">FULL STOP (PERIOD, DOT)</a></li>
<li><a class="reference internal" href="#MATCHING A SINGLE BYTE">MATCHING A SINGLE BYTE</a></li>
<li><a class="reference internal" href="#SQUARE BRACKETS">SQUARE BRACKETS</a></li>
<li><a class="reference internal" href="#POSIX CHARACTER CLASSES">POSIX CHARACTER CLASSES</a></li>
<li><a class="reference internal" href="#VERTICAL BAR">VERTICAL BAR</a></li>
<li><a class="reference internal" href="#INTERNAL OPTION SETTING">INTERNAL OPTION SETTING</a></li>
<li><a class="reference internal" href="#SUBPATTERNS">SUBPATTERNS</a></li>
<li><a class="reference internal" href="#NAMED SUBPATTERNS">NAMED SUBPATTERNS</a></li>
<li><a class="reference internal" href="#REPETITION">REPETITION</a></li>
<li><a class="reference internal" href="#ASSERTIONS">ASSERTIONS</a></li>
<li><a class="reference internal" href="#CONDITIONAL SUBPATTERNS">CONDITIONAL SUBPATTERNS</a></li>
<li><a class="reference internal" href="#COMMENTS">COMMENTS</a></li>
<li><a class="reference internal" href="#RECURSIVE PATTERNS">RECURSIVE PATTERNS</a></li>
<li><a class="reference internal" href="#SUBPATTERNS AS SUBROUTINES">SUBPATTERNS AS SUBROUTINES</a></li>
<li><a class="reference internal" href="#CALLOUTS">CALLOUTS</a></li>
<li><a class="reference internal" href="#DIFFERENCES FROM PERL">DIFFERENCES FROM PERL</a></li>
<li><a class="reference internal" href="#NOTES">NOTES</a></li>
<li><a class="reference internal" href="#LIMITATIONS">LIMITATIONS</a></li>
<li><a class="reference internal" href="#AUTHOR">AUTHOR</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hook/hook.html">hooks</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;good question.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="../_sources/concepts/pcre.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>